<!DOCTYPE html>
<!--
  ============================================
  포커 핸드 로거 (Poker Hand Logger)
  Version: 3.5.0
  Last Modified: 2025-09-22 KST

  Change Log:
  - v3.5.0 (2025-09-24): Phase 5 - 수동 중복 제거 시스템 구현
    • 자동 실행 완전 제거: duplicate-remover.js 스크립트 태그 제거
    • 관리 모달에 🧹 중복 제거 버튼 추가 (빨간색 테마)
    • 조건부 실행 로직: 앱 초기화 및 Apps Script URL 검증
    • 사용자 경험 개선: 확인 대화상자, 로딩 상태, 결과 요약 표시
    • 동적 모듈 로딩: 필요 시에만 duplicate-remover.js 로드
    • Phase 5 전용 테스트 시나리오 및 검증 도구 제공
  - v3.4.26 (2025-09-22): Type 시트 구조 변경 대응 및 Camera Preset 로직 제거
    • Type 시트 새 구조: A:Player, B:Table, C:Notable, D:Chips, E:UpdatedAt, F:Seat, G:Status
    • Camera Preset 처리 로직 완전 제거 (기본값으로 변경)
    • buildTypeFromCsv() 함수 칼럼 매핑 업데이트
    • Apps Script v66 상수 업데이트 (TYPE_COLUMNS, RANGE_COLUMNS)
    • DuplicateRemover 칼럼 인덱스 수정
    • updatePlayerChips, batchUpdatePlayers, addPlayer 함수 구조 변경
  - v3.4.25 (2025-09-19): ActionOrderManagerV2 완전 통합
    • 기존 ActionOrderManager 제거
    • 절대 순위 시스템으로 전면 교체
    • 핸드별 고정 순서로 안정성 향상
    • 폴드/올인 시에도 순서 유지
  - v3.4.10 (2025-09-18): GitHub 저장소 구조 통합 및 간소화
    • 파일들을 루트 레벨로 이동 (virtual_data 서브폴더 제거)
    • GitHub Pages 경로 단순화: garimto81.github.io/virtual_data
    • 관리 포인트 통합으로 유지보수성 향상
  - v3.4.9 (2025-09-18): openCardSelector 함수 전역 접근 문제 해결
    • openCardSelector 함수를 window 객체에 등록
    • ActionOrderManager에서 카드 선택 UI 정상 호출 가능
  - v3.4.8 (2025-09-18): JavaScript 파일 경로 버그 수정
    • archive 폴더로 스크립트 경로 수정 (404 에러 해결)
    • 모든 JavaScript 파일이 정상 로드됨
  - v3.4.7 (2025-09-18): 텍스트 카드 입력 UI 완전 제거
    • 텍스트 입력 필드 제거, 비주얼 카드 선택기로 통합
    • showFeedback 함수 전역 접근 문제 해결
    • promptForBoardCards가 openCardSelector 사용하도록 변경
    • 모든 카드 입력이 일관된 UI로 통합
  - v3.4.6 (2025-09-18): 중복 플레이어 검사 사용자 경험 개선
    • 백그라운드 검사로 변경 (UI 차단 없음)
    • 진행 메시지 간소화 (콘솔 위주)
    • 중요한 결과만 짧게 표시 (2초 스낵바)
    • 페이지 로드 시 조용한 실행
  - v3.4.5 (2025-09-18): 카드 입력 시스템 통합
    • 비주얼 카드 선택 UI로 완전 통일
    • 이미 입력된 카드가 있으면 자동 스킵
  - v3.3.3 (2025-09-17): 유연한 칩 처리 시스템
    • 칩 초과 베팅 허용 - 경고만 표시하고 진햗
    • 마이너스 칩 허용 및 시각적 표시 (빨간색)
    • 수동 칩 조정으로 유연한 처리 가능
    • 현실적인 상황에 대응하는 설계
  - v3.3.2 (2025-09-17): 칩 초과 베팅 방지 시스템 (deprecated)
  - v3.3.1 (2025-09-17): 칩 초과 베팅 자동 올인 처리 (deprecated)
  - v3.3.0 (2025-09-17): 칩 수정 시 중복 플레이어 생성 문제 해결
    • Apps Script v65로 업그레이드
    • updatePlayerChips 함수 개선: 기존 플레이어 없으면 새로 추가
    • 칩 수정 시 자동 중복 제거 로직 추가
  - v3.2.9 (2025-09-17): 중복 제거 아키텍처 개선
    • 별도 중복 제거 버튼 제거
    • 일괄 등록 시 자동 중복 제거 처리
    • Apps Script v64로 업그레이드
  - v3.2.8 (2025-09-17): 중복 플레이어 감지 및 제거 시스템 구현
    • Apps Script에 removeDuplicatePlayers() 함수 추가
    • batchUpdate 및 addPlayer에서 자동 중복 제거
    • 프론트엔드에 중복 제거 버튼 추가 (관리 모달)
    • 자동 플레이어 등록 로직 제거 (중복 방지)
    • 강화된 중복 체크 시스템 (테이블_플레이어 조합)
  - v3.2.7 (2025-09-17): Apps Script 삭제 로직 디버깅 강화 및 조건 완화
  - v3.2.7 (2025-09-17): 시트 정렬 버튼 제거, 플레이어 삭제 로직 개선
  - v3.2.7 (2025-09-17): 정렬 기준 변경 (Table > Seat)
  - v3.2.4 (2025-09-17): Google Sheets 자동 정렬 기능 추가
  - v3.2.3 (2025-09-17): 디버귵 로그 개선 및 캐시 버스팅
  - v3.2.2 (2025-09-17): 플레이어 삭제 성능 최적화
  - v3.2.1 (2025-09-17): 플레이어 삭제 로직 버그 수정
  - v3.2.0 (2025-09-17): Phase 3 - 모바일 최적화 완성
    • 터치 인터페이스 최적화 (44x44px 최소 크기)
    • 스와이프 제스처로 실행취소 (오른쪽 스와이프)
    • 롱프레스 컨텍스트 메뉴 시스템
    • 햅틱 피드백 및 진동 API 지원
    • 가상 스크롤로 대용량 리스트 성능 최적화
    • IndexedDB 기반 오프라인 저장소
    • 자동 동기화 큐 및 재시도 로직
    • 메모리 관리 및 성능 모니터링
  - v3.1.0 (2025-01-17): Phase 2 - 기능별 즉시 실행
    • 더블탭으로 위험 작업 보호
    • 트랜잭션 방식의 일괄 처리
    • API 배치 호출 최적화
    • 더블탭 타이머 충돌 방지
  - v3.0.0 (2025-01-17): 모바일 최적화 - Phase 1 완료
    • confirm 팝업 제거, 즉시 실행 + 실행취소 시스템 구현
    • ActionHistory 시스템으로 작업 이력 관리
    • 스낵바 UI로 실시간 피드백 제공
    • 메모리 최적화 (히스토리 20개 제한)
  - v2.29.0 (2025-09-16): 10개 시트 고정 플레이어 관리 시스템
    • 스트릿 선택 시 자동으로 액션 패드 열기
    • 포커 포지션 순서대로 자동 플레이어 진행
    • Check/Call 버튼 상황별 동적 변경 (금액 표시)
    • 베팅 입력 버그 수정 및 팝업 즉시 표시
  - v2.15.0 (2025-09-16): 테이블 관리 UI 단순화 - 테이블 전용 관리 모달로 변경
  - v2.31.0 (2025-09-16): 로딩 중 UI 잠금 및 플레이어 관리 일괄 업데이트 시스템 구현 - 충돌 방지 및 즉시 반영
  - v2.30.0 (2025-09-16): Apps Script URL 클라우드 동기화 시스템 구현 - GitHub Gist API 활용 기기간 설정 동기화
  - v2.14.0 (2025-09-16): 플레이어 관리 기능 추가 - 관리 버튼에서 플레이어 추가/삭제/좌석 변경
  - v2.10.9 (2025-09-15): 팟 계산 로직 버그 수정 - 중간 베팅 금액 누적 문제 해결
  - v2.10.8 (2025-09-15): 키패드 중복 입력 버그 수정 - 중복 이벤트 리스너 제거
  - v2.10.7 (2025-09-15): 버튼/SB/BB 선택 로직 개선 - 전체 플레이어 리스트에서 선택 가능
  - v2.10.6 (2025-09-15): 버튼 드롭다운 작동 버그 수정, 버전 중앙 관리 시스템 구현
  - v2.10.5 (2025-09-15): 버튼 위치 중복 입력 버그 수정
  - v2.10.4 (2025-09-15): 버튼 설정 UI 최적화
  - v2.10.3 (2025-09-15): 버튼 설정 UI 개선
  - v2.10.2 (2025-09-15): 보드 카드 한번에 입력 기능
  - v2.10.1 (2025-09-15): 플레이어 칩 버튼 이벤트 버그 수정
  - v2.10.0 (2025-09-15): 폴드 되돌리기 버그 수정 외
  - v2.9.5 (2025-09-12): 시작 칩 업데이트 버그 수정
  - v2.9.4 (2025-09-12): 플레이어 이름 표시 버그 수정
  - v2.9.3 (2025-09-12): 좌석 번호 제거, 0.5x11 그리드, 버튼 드롭다운 버그 수정
  - v2.9.2 (2025-01-11): 1x11 그리드로 좌석 배치 개선
  - v2.9.1 (2025-01-11): 좌석 배치 UI 공간 최적화
  - v2.9.0 (2025-01-11): 좌석 배치 시스템 및 액션 순서 로직 추가
  - v2.8.3 (2025-01-11): 카드 입력 다이얼로그 버튼 위치 변경 (UX 개선)
  - v2.8.2 (2025-01-10): 문서 통합 및 프로젝트 정리
  - v2.8.1 (2025-01-10): 2백만 칩 이상 무한 표시 버그 수정
  - v2.8.0 (2025-01-09): 올인 제한 고려한 정확한 팟 계산 로직 구현
  - v2.7.0 (2025-01-08): 팟 계산 로직 개선 - 블라인드/안티를 플레이어별 기여액에 포함
  - v2.0.0 (2025-01-02): Smart Check/Call 버튼 및 스트리트 자동 진행 시스템 구현
  - v1.9.0 (2024-12-30): 팟 사이즈 조정 로직 및 올인 콜 버그 수정
  - v1.8.0 (2024-12-28): 플레이어 상태 추적 시스템 추가
  ============================================
-->
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <meta http-equiv="cache-control" content="no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="pragma" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <title>포커 핸드 로거 v3.4.42-debug</title>
  <script src="https://cdn-tailwindcss.vercel.app/"></script>
  <script src="archive/chip-analysis-module.js?v=3.0.0" defer></script>
  <!-- 테이블 관리 모듈 v59 - IN/OUT 두 가지 상태만 사용 -->
  <script src="archive/table-management-v59.js?v=3.0.0" defer></script>
  <!-- ActionHistory 시스템 - Phase 1 -->
  <script src="archive/action-history.js?v=3.2.5" defer></script>
  <!-- Phase 2: 더블탭 & 배치 처리 -->
  <script src="archive/double-tap-handler.js?v=3.2.5" defer></script>
  <script src="archive/batch-processor.js?v=3.2.5" defer></script>
  <!-- Phase 3: 모바일 최적화 -->
  <script src="archive/mobile-optimizer.js?v=3.2.5" defer></script>
  <script src="archive/virtual-scroll.js?v=3.2.5" defer></script>
  <script src="archive/offline-storage.js?v=3.2.5" defer></script>
  <!-- 🔧 로거 시스템 (먼저 로드) -->
  <script src="src/js/logger.js?v=1.0.0"></script>
  <!-- 📦 상수 정의 (로거 다음에 로드) -->
  <script src="src/js/constants.js?v=1.0.0"></script>
  <!-- 🛠️ 유틸리티 함수들 -->
  <script src="src/utils/formatters.js?v=1.0.0"></script>
  <script src="src/utils/validators.js?v=1.0.0"></script>
  <script src="src/utils/helpers.js?v=1.0.0"></script>
  <!-- 🔥 에러 처리 시스템 -->
  <script src="src/js/errorHandler.js?v=1.0.0"></script>
  <!-- ⚡ 성능 최적화 모듈 -->
  <script src="src/js/lazy-loader.js?v=1.0.0"></script>
  <script src="src/js/cache-manager.js?v=1.0.0"></script>
  <script src="src/js/performance-monitor.js?v=1.0.0"></script>
  <!-- 모달 자동 닫기 모듈 -->
  <script src="src/js/modal-auto-close.js?v=1.0.0" defer></script>

  <!-- Phase 4: API 호출 보호 시스템 -->
  <script src="phase4-functions.js?v=4.0.0" defer></script>
  <!-- 액션 순서 관리자 V2 - 절대 순위 시스템 -->
  <script src="src/js/action-order-manager-v2.js?v=2.0.0" defer></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@700&family=Noto+Sans+KR:wght@400;500;700&display=swap');
    html, body { height: 100vh; overflow: hidden; font-family: 'Noto Sans KR', sans-serif; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    #app-container { display: flex; flex-direction: column; height: 100%; }
    main { flex-grow: 1; overflow-y: auto; }
    .btn { /* transition removed for instant response */ }
    .btn:active { transform: scale(0.95); }
    .btn-selected { background-color: #FBBF24 !important; color: #111827 !important; font-weight: bold; }
    .card-placeholder { border: 2px dashed #4B5563; cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 1px; background-color: rgba(255,255,255,0.05); flex-shrink: 0; }
    .card-display { font-family: 'Roboto', sans-serif; background-color: white; border-radius: 4px; padding: 1px; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.8rem; }
    .card-display .rank { font-weight: bold; font-size: 1rem; }
    .modal { /* transition removed for instant popup */ backdrop-filter: blur(4px); }
    .card-selector-btn { font-family: 'Roboto', sans-serif; font-size: 1rem; font-weight: bold; }
    .card-selector-btn.card-red { color: #DC2626; }
    .card-selector-btn.card-black { color: #111827; }
    .card-selector-btn.selected { border: 3px solid #FBBF24; transform: scale(0.95); }

    /* 새로운 보드 카드 상태 스타일 */
    .card-selector-btn[data-status="editable"] {
      background: #FCD34D;
      border: 2px solid #F59E0B;
      box-shadow: 0 0 8px rgba(245, 158, 11, 0.3);
    }
    .card-selector-btn[data-status="locked"] {
      background: #6B7280;
      color: #9CA3AF;
      border: 2px solid #374151;
      cursor: not-allowed;
      position: relative;
    }
    .card-selector-btn[data-status="locked"]:after {
      content: '🔒';
      position: absolute;
      top: 1px;
      right: 2px;
      font-size: 10px;
    }
    .card-selector-btn[data-status="used"] {
      background: #6B7280;
      color: #9CA3AF;
      cursor: not-allowed;
    }
    .card-selector-btn[data-status="available"]:hover {
      background: #FEF3C7;
    }
    .player-card.is-winner { background-color: rgba(251, 191, 36, 0.1); }
    select, input[type="text"] { font-size: 0.875rem; }
    .chip-color-sample { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #4B5563; cursor: pointer; }
    .chip-analysis-btn { font-size: 0.75rem; padding: 0.25rem 0.5rem; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .pulse-animation { animation: pulse 2s infinite; }

    /* 스낵바 스타일 (모바일 최적화) */
    .snackbar {
      position: fixed;
      bottom: -60px;
      left: 10px;
      right: 10px;
      background: #333;
      color: white;
      padding: 12px;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: bottom 0.2s ease-out;
      z-index: 10000;
      font-size: 14px;
      max-width: 500px;
      margin: 0 auto;
    }

    .snackbar.show {
      bottom: 10px;
    }

    .snackbar-undo-btn {
      background: transparent;
      border: 1px solid white;
      color: white;
      padding: 4px 12px;
      border-radius: 3px;
      font-size: 12px;
      margin-left: 10px;
      cursor: pointer;
      min-width: 44px;
      min-height: 30px;
    }

    .snackbar-undo-btn:active {
      transform: scale(0.95);
    }

    .snackbar-info {
      background: #2563eb;
    }

    .snackbar-error {
      background: #dc2626;
    }

    .snackbar-success {
      background: #16a34a;
    }

    .snackbar-warning {
      background: #f59e0b;
    }

    /* 더블탭 스타일 (Phase 2) */
    .double-tap-required {
      position: relative;
    }

    .double-tap-warning {
      animation: pulse 0.5s ease-in-out infinite;
      background: #f59e0b !important;
      color: white !important;
    }

    .danger-critical {
      background: #dc2626 !important;
      color: white !important;
    }

    .danger-warning {
      background: #f59e0b !important;
      color: white !important;
    }

    .executing {
      opacity: 0.6;
      pointer-events: none;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
  </style>
</head>
<body class="bg-gray-900 text-white antialiased">
  <div id="app-container">
    <!-- 버전 표시 헤더 -->
    <div class="bg-gray-900 border-b border-gray-700 px-3 py-1">
      <div class="flex justify-between items-center text-xs">
        <span class="font-bold text-amber-400">포커 핸드 로거</span>
        <div class="flex items-center gap-2">
          <button id="settings-btn" class="text-gray-400 hover:text-amber-400" title="설정">
            ⚙️
          </button>
          <span id="version-display" class="text-gray-400">v2.26.6</span>
        </div>
      </div>
    </div>
    <main class="p-2 space-y-2">
      <div class="bg-gray-800 p-2 rounded-lg space-y-2">
        <div class="flex items-center gap-2 text-sm">
          <div class="flex-1 flex items-center gap-1 bg-gray-700 p-1 rounded-md min-w-0">
            <span id="hand-number-display" class="font-bold px-1 whitespace-nowrap">#--</span>
            <button id="load-hand-btn" class="btn bg-gray-600 px-2 py-1 rounded-md text-xs">Load</button>
            <label class="flex items-center gap-1 text-xs ml-2">
              <input type="checkbox" id="smart-mode-toggle" checked class="h-3 w-3">
              <span>Smart</span>
            </label>
          </div>
          <div class="flex-1 min-w-0">
            <button id="table-selector-btn" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1 text-left flex items-center justify-between hover:bg-gray-600">
              <span id="selected-table-display">테이블 선택</span>
              <span class="text-gray-400">▼</span>
            </button>
          </div>
          <div class="flex-1 flex items-center gap-1 min-w-0">
            <select id="timezone-selector" class="flex-grow bg-gray-700 border border-gray-600 rounded-md px-2 py-1 text-xs"></select>
            <span id="time-display" class="bg-gray-900/50 p-1 rounded-md font-mono text-xs"></span>
          </div>
          <div class="flex items-center gap-1">
            <button id="manage-players-btn" class="btn bg-gray-600 hover:bg-gray-700 px-2 py-1 rounded-md text-xs">관리</button>
            <button id="refresh-data" class="text-lg" title="데이터 새로고침">🔄</button>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <div class="text-xs text-gray-300 flex items-center gap-2">
            <button id="cam-btn-1" class="btn bg-gray-700 px-2 py-1 rounded"></button>
            <button id="cam-btn-2" class="btn bg-gray-700 px-2 py-1 rounded"></button>
          </div>
          <div class="text-right text-xs text-gray-400">
            <span id="data-stamp"></span>
          </div>
        </div>
        <!-- 좌석 배치 및 플레이어 선택 (1x11 그리드) -->
        <div class="bg-gray-700 p-2 rounded-lg">
          <div id="seat-buttons" class="grid grid-cols-11 gap-1">
            <!-- 10개 좌석 + 버튼 드롭다운 (11번째) -->
          </div>
          <div id="position-indicators" class="text-xs text-gray-400 mt-1 text-center">
            <!-- SB, BB 표시 -->
          </div>
          <div id="position-display" class="mt-1 text-xs">
            <!-- 버튼 위치 상세 표시 -->
          </div>
        </div>
      </div>

      <div id="player-details-section" class="bg-gray-800 p-2 rounded-lg space-y-1"></div>

      <div class="bg-gray-800 p-2 rounded-lg space-y-2">
        <div class="flex flex-wrap items-center gap-2">
          <div class="flex items-center gap-1">
            <button id="small-blind-btn" data-purpose="smallBlind" class="btn bg-gray-700 p-1 rounded-md text-sm min-w-[60px]">0</button>
            <button id="big-blind-btn" data-purpose="bigBlind" class="btn bg-gray-700 p-1 rounded-md text-sm min-w-[60px]">0</button>
            <div class="flex items-center">
              <input id="bb-ante-checkbox" type="checkbox" class="h-4 w-4 bg-gray-700 border-gray-600 rounded text-amber-500">
              <label for="bb-ante-checkbox" class="ml-1 text-xs">Ante</label>
            </div>
          </div>
          <div id="board-card-placeholders" class="flex flex-wrap gap-1 items-center flex-grow justify-end"></div>
        </div>
        <div class="space-y-1" id="street-logs-container"></div>
        
        <!-- 현재 차례 표시 & 빠른 액션 버튼 (자동 모드) -->
        <div id="current-turn-indicator" class="hidden mt-2 p-2 bg-gray-700 rounded-md">
          <div class="text-center text-sm mb-2">
            <!-- 동적으로 생성됨 -->
          </div>
          <div id="quick-action-buttons" class="grid grid-cols-5 gap-1">
            <button onclick="addAutoAction('Checks')" class="btn bg-green-600 hover:bg-green-500 text-white text-xs py-1 px-2 rounded">
              체크
            </button>
            <button onclick="handleSmartCall()" class="btn bg-blue-600 hover:bg-blue-500 text-white text-xs py-1 px-2 rounded">
              콜
            </button>
            <button onclick="openQuickBetRaise()" class="btn bg-orange-600 hover:bg-orange-500 text-white text-xs py-1 px-2 rounded">
              벳/레이즈
            </button>
            <button onclick="addAutoAction('Folds')" class="btn bg-red-600 hover:bg-red-500 text-white text-xs py-1 px-2 rounded">
              폴드
            </button>
            <button onclick="handleAllIn()" class="btn bg-purple-600 hover:bg-purple-500 text-white text-xs py-1 px-2 rounded">
              올인
            </button>
          </div>
        </div>
      </div>


      <div class="bg-gray-800 p-2 rounded-lg space-y-2">
        <div class="flex flex-wrap gap-1 items-center">
          <span class="text-sm font-bold mr-2">승자:</span>
          <div id="winner-buttons" class="flex flex-wrap gap-1 flex-grow"></div>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <button id="reset-btn" class="w-full btn bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-3 rounded-md text-sm">새 핸드</button>
          <button id="send-to-sheet-btn" class="w-full btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md text-sm">시트 전송</button>
        </div>
        <p id="feedback-message" class="text-center h-4 text-xs font-semibold"></p>
      </div>

    </main>
    <footer class="flex-shrink-0 p-1 text-center">
      <button id="show-log-btn" class="text-gray-500 hover:text-gray-300 text-xs">로그 보기</button>
    </footer>
  </div>

  <!-- Modals -->
  <div id="card-selector-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-2 z-50 hidden opacity-0"></div>
  <div id="action-pad-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0"></div>
  <div id="keypad-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0"></div>
  <div id="load-hand-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0"></div>
  <!-- 관리 모달 -->
  <div id="registration-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0">
    <div class="bg-gray-800 rounded-lg p-4 max-w-lg w-full max-h-[90vh] overflow-y-auto">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold text-amber-400">관리 설정</h2>
        <button id="close-registration-modal" class="text-2xl hover:text-gray-400">&times;</button>
      </div>

      <!-- 메인 관리 버튼들 -->
      <div id="management-menu" class="space-y-3 mb-4">
        <!-- 버튼들 -->
        <div class="grid grid-cols-2 gap-3">
          <button id="open-table-management-btn" class="bg-blue-600 hover:bg-blue-700 py-3 px-4 rounded-lg text-sm font-medium flex flex-col items-center">
            <span class="text-2xl mb-1">🎯</span>
            <span>테이블 선택</span>
          </button>
          <button id="remove-duplicates-btn" class="bg-red-600 hover:bg-red-700 py-3 px-4 rounded-lg text-sm font-medium flex flex-col items-center">
            <span class="text-2xl mb-1">🧹</span>
            <span>중복 제거</span>
          </button>
        </div>

        <!-- Apps Script URL 설정 -->
        <div class="bg-gray-700 p-3 rounded-lg">
          <label class="block text-sm font-medium text-gray-300 mb-2">
            Apps Script URL
            <span class="text-xs text-gray-500 ml-2">(재배포 후 새 URL 입력)</span>
          </label>
          <div class="space-y-2">
            <!-- 현재 저장된 URL 표시 -->
            <div id="current-url-display" class="bg-gray-800 p-2 rounded border border-gray-600">
              <div class="text-xs text-gray-400 mb-1">현재 저장된 URL:</div>
              <div id="management-current-url" class="text-xs text-amber-400 break-all font-mono"></div>
            </div>

            <!-- 재배포 안내 메시지 -->
            <div class="bg-blue-900 border border-blue-700 p-2 rounded text-xs">
              <div class="text-blue-300 font-semibold mb-1">📌 Apps Script 재배포 필요</div>
              <div class="text-blue-200">
                "Unknown action: batchUpdate" 오류가 발생하면:
                <ol class="list-decimal list-inside mt-1 text-blue-100">
                  <li>apps-script/Code_v59_InOut.gs 파일 복사</li>
                  <li>Google Apps Script에 붙여넣기</li>
                  <li>배포 → 새 배포 관리 → 편집 → 버전: 새 버전</li>
                  <li>새 URL을 아래에 입력하여 저장</li>
                </ol>
              </div>
            </div>

            <!-- Google Sheets URL 입력 -->
            <input type="text" id="management-spreadsheet-id-input"
                   class="w-full bg-gray-600 text-white rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-amber-500 font-mono"
                   placeholder="Google Sheets URL 전체를 입력하세요 (예: https://docs.google.com/spreadsheets/d/...)">

            <!-- 저장 버튼 -->
            <button id="save-spreadsheet-id-btn" class="w-full bg-amber-600 hover:bg-amber-700 py-1.5 rounded text-sm font-medium">
              💾 Google Sheets URL 저장
            </button>

            <!-- 저장 상태 메시지 -->
            <div id="url-save-status" class="hidden text-xs p-2 rounded"></div>
          </div>
        </div>
      </div>

      <!-- 테이블 관리 섹션 (초기에 숨김) -->
      <div id="player-management-content" class="space-y-3 hidden">
          <!-- 선택된 테이블 정보 -->
          <div class="bg-gray-700 p-3 rounded-lg">
            <div class="flex items-center justify-between mb-2">
              <h4 class="text-sm font-bold text-amber-400">선택된 테이블</h4>
              <span id="sync-status" class="text-xs text-gray-400"></span>
            </div>
            <div id="selected-table-info" class="text-sm">
              <span id="selected-table-name" class="text-amber-400 font-bold"></span>
              <button id="change-table-btn" class="ml-2 text-xs bg-gray-600 hover:bg-gray-500 px-2 py-1 rounded">변경</button>
            </div>
          </div>

          <!-- 새 플레이어 추가 섹션 -->
          <div id="player-add-section" class="bg-gray-700 p-3 rounded-lg hidden">
            <h4 class="text-sm font-bold mb-2 text-amber-400">플레이어 추가</h4>
            <div class="grid grid-cols-3 gap-2 mb-2">
              <input type="text" id="new-player-name" class="bg-gray-600 px-2 py-1 rounded text-sm" placeholder="이름">
              <input type="number" id="new-player-seat" class="bg-gray-600 px-2 py-1 rounded text-sm" placeholder="좌석" min="1" max="10">
              <input type="text" id="new-player-chips" class="bg-gray-600 px-2 py-1 rounded text-sm" placeholder="칩">
            </div>
            <button id="add-player-local-btn" class="w-full bg-green-600 hover:bg-green-700 py-1 rounded text-sm">+ 추가</button>
          </div>

          <!-- 현재 플레이어 목록 (10개 시트 고정) -->
          <div id="player-list-section" class="bg-gray-700 p-3 rounded-lg hidden">
            <div class="flex items-center justify-between mb-2">
              <h4 class="text-sm font-bold text-amber-400">플레이어 시트</h4>
              <span id="player-count" class="text-xs text-amber-300"></span>
            </div>
            <div id="current-players-list" class="h-auto">
              <!-- 10개 시트가 고정으로 표시됨 -->
            </div>
          </div>

          <!-- 일괄 등록 버튼 -->
          <div id="batch-actions" class="hidden">
            <div class="flex gap-2 mb-2">
              <button id="reset-changes-btn" class="flex-1 bg-gray-600 hover:bg-gray-700 py-2 rounded text-sm">
                ↩️ 변경 취소
              </button>
              <button id="batch-register-btn" class="flex-1 bg-amber-600 hover:bg-amber-700 py-2 rounded text-sm font-bold">
                ✅ 일괄 등록
              </button>
            </div>
            <div id="changes-summary" class="mt-2 text-xs text-gray-400"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="log-modal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden opacity-0">
    <div class="bg-gray-800 rounded-lg p-4 w-full max-w-lg h-2/3 flex flex-col">
      <div class="flex justify-between items-center mb-2">
        <h2 class="text-xl font-bold text-amber-400">로딩 로그</h2>
        <button id="close-log-modal" class="text-2xl">&times;</button>
      </div>
      <div id="log-display" class="bg-gray-900/50 p-3 rounded-md flex-grow overflow-y-auto text-sm font-mono"></div>
    </div>
  </div>

  <!-- 칩 컬러 선택 모달 (카메라 또는 파일) -->
  <div id="chip-color-modal" class="modal fixed inset-0 bg-black bg-opacity-75 hidden z-50">
    <div class="flex items-center justify-center h-full p-4">
      <div class="bg-gray-800 rounded-lg p-4 max-w-md w-full">
        <h3 class="text-lg font-bold mb-3 text-amber-400">칩 등록</h3>
        
        <!-- 선택 옵션 -->
        <div id="chip-option-select" class="mb-4">
          <p class="text-sm text-gray-300 mb-3">칩 사진을 추가하는 방법을 선택하세요:</p>
          <div class="grid grid-cols-2 gap-2">
            <button id="select-camera-btn" class="bg-blue-600 hover:bg-blue-700 p-3 rounded-lg flex flex-col items-center">
              <span class="text-2xl mb-1">📷</span>
              <span class="text-sm">사진 촬영</span>
            </button>
            <button id="select-file-btn" class="bg-purple-600 hover:bg-purple-700 p-3 rounded-lg flex flex-col items-center">
              <span class="text-2xl mb-1">📁</span>
              <span class="text-sm">파일 선택</span>
            </button>
          </div>
        </div>
        
        <!-- 카메라 뷰 (숨김 상태) -->
        <div id="camera-view" class="hidden">
          <video id="chip-video" class="w-full rounded-lg mb-3" autoplay playsinline></video>
          <canvas id="chip-canvas" class="hidden"></canvas>
        </div>
        
        <!-- 이미지 프리뷰 (숨김 상태) -->
        <div id="image-preview" class="hidden">
          <img id="preview-img" class="w-full rounded-lg mb-3" alt="미리보기">
        </div>
        
        <!-- 파일 입력 (숨김) -->
        <input type="file" id="file-input" class="hidden" accept="image/*">
        
        <!-- 칩 값 입력 -->
        <input type="text" id="chip-value-input" class="w-full bg-gray-700 px-3 py-2 rounded mb-3" placeholder="칩 값 (예: 1000)">
        
        <!-- 액션 버튼들 -->
        <div class="flex gap-2">
          <button id="capture-chip-btn" class="flex-1 bg-green-600 hover:bg-green-700 py-2 rounded-lg font-medium hidden">촬영</button>
          <button id="confirm-chip-btn" class="flex-1 bg-green-600 hover:bg-green-700 py-2 rounded-lg font-medium hidden">확인</button>
          <button id="retry-chip-btn" class="flex-1 bg-yellow-600 hover:bg-yellow-700 py-2 rounded-lg font-medium hidden">다시선택</button>
          <button id="close-chip-modal" class="flex-1 bg-gray-600 hover:bg-gray-700 py-2 rounded-lg font-medium">취소</button>
        </div>
        
        <!-- 안내 메시지 -->
        <div id="chip-info-message" class="mt-3 text-xs text-gray-400 text-center">
          💡 PC에서는 파일 선택, 모바일에서는 카메라 촬영을 권장합니다
        </div>
      </div>
    </div>
  </div>

  <!-- 칩 스택 분석 모달 -->
  <div id="stack-analysis-modal" class="modal fixed inset-0 bg-black bg-opacity-75 hidden z-50">
    <div class="flex items-center justify-center h-full p-4">
      <div class="bg-gray-800 rounded-lg p-4 max-w-lg w-full max-h-[90vh] overflow-y-auto">
        <h3 class="text-lg font-bold mb-3 text-amber-400">
          <span id="analyzing-player-name">플레이어</span> 칩 스택 분석
        </h3>
        <div id="stack-images-container" class="grid grid-cols-2 gap-2 mb-3"></div>
        <video id="stack-video" class="w-full rounded-lg mb-3" autoplay playsinline></video>
        <canvas id="stack-canvas" class="hidden"></canvas>
        <div class="flex gap-2 mb-3">
          <button id="capture-stack-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 py-2 rounded-lg font-medium">사진 추가</button>
          <button id="analyze-stack-btn" class="flex-1 bg-green-600 hover:bg-green-700 py-2 rounded-lg font-medium" disabled>AI 분석</button>
        </div>
        <button id="close-stack-modal" class="w-full bg-gray-600 hover:bg-gray-700 py-2 rounded-lg font-medium">닫기</button>
      </div>
    </div>
  </div>

  <!-- AI 분석 중 오버레이 -->
  <div id="analyzing-overlay" class="fixed inset-0 bg-black bg-opacity-80 hidden z-[60]">
    <div class="flex items-center justify-center h-full">
      <div class="bg-gray-900 rounded-lg p-6 text-center">
        <div class="text-3xl mb-3 pulse-animation">🤖</div>
        <p class="text-lg font-medium mb-2">AI 분석 중...</p>
        <p class="text-sm text-gray-400">칩 스택을 분석하고 있습니다</p>
      </div>
    </div>
  </div>

  <!-- 테이블 선택 모달 -->
  <div id="table-selector-modal" class="modal fixed inset-0 bg-black bg-opacity-75 hidden z-50">
    <div class="flex items-center justify-center h-full p-2">
      <div class="bg-gray-800 rounded-lg w-full max-w-md h-full max-h-screen flex flex-col">
        <!-- 헤더 -->
        <div class="flex items-center justify-between p-4 border-b border-gray-700">
          <h3 class="text-lg font-bold text-amber-400">🎯 테이블 선택</h3>
          <button id="close-table-selector" class="text-gray-400 hover:text-white text-xl">×</button>
        </div>
        
        <!-- 검색 및 필터 -->
        <div class="p-4 border-b border-gray-700">
          <input type="text" id="table-search" placeholder="테이블 번호 또는 플레이어 검색..." 
                 class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-sm mb-3">
          <div class="flex gap-2 flex-wrap">
            <button id="filter-all" class="filter-btn px-3 py-1 rounded-full text-xs bg-blue-600 text-white">전체</button>
            <button id="filter-active" class="filter-btn px-3 py-1 rounded-full text-xs bg-gray-600 hover:bg-gray-500">활성</button>
            <button id="filter-empty" class="filter-btn px-3 py-1 rounded-full text-xs bg-gray-600 hover:bg-gray-500">빈테이블</button>
          </div>
        </div>
        
        <!-- 페이지 토글 -->
        <div class="px-4 py-2 border-b border-gray-700">
          <div class="flex items-center justify-between">
            <button id="prev-page" class="px-3 py-1 bg-gray-600 rounded hover:bg-gray-500 disabled:opacity-50">◀</button>
            <span id="page-info" class="text-sm text-gray-400">1-20 / 100</span>
            <button id="next-page" class="px-3 py-1 bg-gray-600 rounded hover:bg-gray-500 disabled:opacity-50">▶</button>
          </div>
        </div>
        
        <!-- 테이블 그리드 -->
        <div class="flex-1 overflow-y-auto p-4">
          <div id="table-grid" class="grid grid-cols-4 gap-2">
            <!-- 테이블 버튼들이 여기에 동적 생성됩니다 -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 설정 모달 -->
  <div id="settings-modal" class="modal fixed inset-0 bg-black bg-opacity-75 hidden z-50">
    <div class="flex items-center justify-center h-full p-4">
      <div class="bg-gray-800 rounded-lg w-full max-w-lg">
        <!-- 헤더 -->
        <div class="flex items-center justify-between p-4 border-b border-gray-700">
          <h3 class="text-lg font-bold text-amber-400">⚙️ 설정</h3>
          <button id="close-settings" class="text-gray-400 hover:text-white text-xl">×</button>
        </div>
        
        <!-- 설정 내용 -->
        <div class="p-4 space-y-4">
          <!-- Apps Script URL 설정 -->
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-2">
              🔗 Google Spreadsheet ID
              <span class="text-xs text-gray-500 ml-2">(Google Sheets URL에서 추출)</span>
            </label>
            <div class="space-y-2">
              <input type="text" id="google-spreadsheet-id-input"
                     class="w-full bg-gray-700 text-white rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-amber-500 font-mono"
                     placeholder="1ABC...xyz (스프레드시트 ID만 입력)">
              <div class="text-xs text-gray-500">
                현재: <span id="current-spreadsheet-id" class="text-gray-400 break-all font-mono"></span>
              </div>
              <div class="text-xs text-blue-400 bg-blue-900/20 p-2 rounded">
                💡 <strong>사용법:</strong> Google Sheets URL에서 <code>/d/</code> 다음에 나오는 긴 문자열을 복사하세요<br>
                예: <code>docs.google.com/spreadsheets/d/<span class="text-yellow-300">1ABC...xyz</span>/edit</code>
              </div>

              <!-- 클라우드 동기화 상태 -->
              <div class="bg-gray-700 rounded-md p-3 space-y-2">
                <div class="flex items-center justify-between">
                  <span class="text-xs font-medium text-gray-300">☁️ 클라우드 동기화</span>
                  <span id="cloud-sync-status" class="text-xs px-2 py-1 rounded-full bg-gray-600 text-gray-400">확인 중...</span>
                </div>
                <div class="text-xs text-gray-500 space-y-1">
                  <div>기기 ID: <span id="device-id-display" class="text-gray-400 font-mono text-xs"></span></div>
                  <div id="last-sync-display" class="hidden">마지막 동기화: <span class="text-gray-400"></span></div>
                </div>
                <div class="flex space-x-2">
                  <button id="sync-now-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white text-xs py-1.5 px-3 rounded transition-colors">
                    🔄 지금 동기화
                  </button>
                  <button id="reset-cloud-btn" class="bg-gray-600 hover:bg-gray-500 text-white text-xs py-1.5 px-3 rounded transition-colors">
                    🗑️ 초기화
                  </button>
                </div>
              </div>
            </div>
          </div>
          
          <!-- 칩 스택 검증 설정 -->
          <div>
            <label class="flex items-center space-x-2">
              <input type="checkbox" id="chip-validation-toggle" class="rounded text-amber-500 focus:ring-amber-500">
              <span class="text-sm font-medium text-gray-300">칩 스택 검증 활성화</span>
            </label>
            <p class="text-xs text-gray-500 mt-1 ml-6">
              활성화 시 보유 칩보다 큰 금액 입력을 제한합니다
            </p>
          </div>
          
          <!-- 액션 입력 모드 설정 -->
          <div>
            <label class="flex items-center space-x-2">
              <input type="checkbox" id="action-input-mode-toggle" class="rounded text-amber-500 focus:ring-amber-500">
              <span class="text-sm font-medium text-gray-300">자동 액션 매핑 모드</span>
            </label>
            <p class="text-xs text-gray-500 mt-1 ml-6">
              활성화 시 액션이 순서대로 자동 매핑됩니다 (플레이어 선택 불필요)
            </p>
          </div>
          
          <!-- 버전 정보 -->
          <div class="pt-2 border-t border-gray-700">
            <div class="text-xs text-gray-500 space-y-1">
              <div>버전: <span class="text-gray-400">${APP_VERSION}</span></div>
              <div>업데이트: <span class="text-gray-400">${VERSION_DATE}</span></div>
              <div>Sheet ID: <span class="text-gray-400 text-xs">1J-lf8bYTLPbpdhieUNdb8ckW_uwdQ3MtSBLmyRIwH7U</span></div>
            </div>
          </div>
        </div>
        
        <!-- 푸터 -->
        <div class="flex justify-end gap-2 p-4 border-t border-gray-700">
          <button id="cancel-settings" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded-md text-sm font-medium">
            취소
          </button>
          <button id="save-settings" class="px-4 py-2 bg-amber-600 hover:bg-amber-500 rounded-md text-sm font-medium">
            저장
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
  /**
   * ============================================
   * 포커 핸드 로거 - Main JavaScript
   * 버전 관리는 APP_VERSION 상수를 통해 중앙화됨
   * Author: garimto81 with Claude
   * ============================================
   */
  
  // ========================================
  // 중앙 버전 관리 시스템
  // ========================================
  const APP_VERSION = 'v3.5.42';
  const VERSION_DATE = '2025-09-24';
  const VERSION_INFO = `포커 핸드 로거 ${APP_VERSION} (${VERSION_DATE})`;

  // ========================================
  // Phase 1: 전역 상태 관리 시스템 v2.0
  // ========================================

  window.APP_CONFIG = {
    isInitialized: false,
    appsScriptUrl: null,
    autoInit: false,
    version: APP_VERSION,
    data: {},
    settings: {
      debugMode: false,
      autoSave: true,
      offlineMode: false
    },
    state: {
      lastConnection: null,
      connectionAttempts: 0,
      isOnline: navigator.onLine
    }
  };

  // ⚠️ 중요: 앱 시작 시 localStorage에서 Apps Script URL 로드
  (function initializeAppsScriptUrl() {
    const storedUrl = localStorage.getItem('appsScriptUrl');
    if (storedUrl) {
      window.APP_CONFIG.appsScriptUrl = storedUrl;
      console.log('✅ localStorage에서 Apps Script URL 복원:', storedUrl);
    } else {
      console.log('⚠️ localStorage에 Apps Script URL이 없음');
    }
  })();

  // 네트워크 상태 모니터링
  window.addEventListener('online', () => {
    window.APP_CONFIG.state.isOnline = true;
    console.log('🌐 온라인 상태로 변경됨');
  });

  window.addEventListener('offline', () => {
    window.APP_CONFIG.state.isOnline = false;
    console.log('📱 오프라인 상태로 변경됨');
  });

  // ========================================
  // 좌석 파싱 유틸리티 함수들
  // ========================================
  
  /**
   * 좌석 번호 파싱 - "#1", "#2" 형식을 숫자로 변환
   * @param {string|number} seat - 좌석 정보
   * @returns {number} - 파싱된 좌석 번호 (실패시 0)
   */
  function parseSeatNumber(seat) {
    if (!seat && seat !== 0) return 0;
    const seatStr = String(seat).trim();
    if (!seatStr) return 0;
    
    // "#1", "#2" 등의 형식에서 숫자만 추출
    const cleanSeat = seatStr.replace(/[#]/g, '');
    const seatNum = parseInt(cleanSeat, 10);
    return isNaN(seatNum) ? 0 : seatNum;
  }

  /**
   * 좌석 번호 비교 함수
   * @param {object} a - 플레이어 객체 a
   * @param {object} b - 플레이어 객체 b
   * @returns {number} - 비교 결과
   */
  function compareSeatNumbers(a, b) {
    const seatA = parseSeatNumber(a.seat);
    const seatB = parseSeatNumber(b.seat);
    return seatA - seatB;
  }

  /**
   * 플레이어의 좌석 번호 가져오기
   * @param {object} player - 플레이어 객체
   * @returns {number} - 좌석 번호
   */
  function getPlayerSeatNumber(player) {
    return parseSeatNumber(player.seat);
  }

  // ========================================
  // Phase 2: 조건부 초기화 시스템
  // ========================================

  function conditionalInit() {
    if (window.APP_CONFIG.autoInit && window.APP_CONFIG.appsScriptUrl) {
      console.log('🚀 자동 초기화 시작...');
      // 자동 초기화 로직 (필요시 구현)
    } else {
      console.log('⏸️ 수동 초기화 대기 중...');
    }
  }

  // ========================================
  // Phase 3: 보호된 loadInitial 함수 (조건부)
  // ========================================

  // 기존 loadInitial 함수를 보호된 버전으로 래핑
  const originalLoadInitial = window.loadInitial;
  window.loadInitial = function() {
    if (!window.APP_CONFIG.isInitialized && !window.APP_CONFIG.appsScriptUrl) {
      console.warn('⚠️ Apps Script URL이 설정되지 않음 - loadInitial 스킵');
      return Promise.resolve([]);
    }
    return originalLoadInitial.apply(this, arguments);
  };

  // ========================================
  // 스트릿 자동 진행 시스템 v2.0 - 완벽한 보안 구현
  // ========================================

  // Layer 1: 시퀀스 기반 타임스탬프 (로깅 전용)
  class SequentialTimekeeper {
    constructor() {
      this.sequence = 0;
      this.lastTimestamp = Date.now();
    }

    generateTimestamp() {
      const now = Date.now();
      this.sequence++;

      // 로깅만 하고 항상 유효한 타임스탬프 반환
      console.log(`액션 타임스탬프: #${this.sequence} at ${new Date(now).toLocaleTimeString()}`);

      return {
        sequence: this.sequence,
        timestamp: now,
        hash: this.hashTimestamp(this.sequence, now)
      };
    }

    validateAndUpdate(actionTimestamp) {
      // 항상 true 반환 - 모든 액션 허용
      this.lastTimestamp = actionTimestamp.timestamp;
      return true;
    }

    hashTimestamp(sequence, timestamp) {
      return btoa(`${sequence}-${timestamp}-${window.location.hostname}`);
    }
  }

  // Layer 2: 트래픽 모니터링 (로깅 전용)
  class RateLimiter {
    constructor() {
      this.attempts = new Map();
      this.actionCount = 0;
    }

    check(playerId, actionType = 'action') {
      const now = Date.now();
      const window = 1000;

      // 액션 카운트 증가
      this.actionCount++;

      // 통계 로깅만
      const key = `${playerId}-${Math.floor(now / window)}`;
      const attempts = this.attempts.get(key) || 0;
      this.attempts.set(key, attempts + 1);

      if (attempts >= 3) {
        console.log(`빠른 액션 감지: ${playerId} - ${attempts + 1}회/초`);
      }

      // 오래된 기록 정리
      if (this.attempts.size > 100) {
        const oldKeys = Array.from(this.attempts.keys()).slice(0, 50);
        oldKeys.forEach(k => this.attempts.delete(k));
      }

      // 항상 true 반환 - 모든 액션 허용
      return true;
    }
  }

  // Layer 3: 상태 모니터링 (자동 적응)
  class StateValidator {
    constructor() {
      this.knownPlayers = new Set();
      this.stateHash = null;
    }

    initialize(players) {
      // 초기 플레이어 등록
      players.forEach(p => this.knownPlayers.add(p.name));
      this.stateHash = this.calculateHash(players);
    }

    validatePlayer(playerName) {
      // 새 플레이어 자동 추가
      if (!this.knownPlayers.has(playerName)) {
        console.log(`새 플레이어 자동 등록: ${playerName}`);
        this.knownPlayers.add(playerName);

        // playersInHand에도 자동 추가
        if (!window.state.playersInHand.find(p => p.name === playerName)) {
          window.state.playersInHand.push({
            name: playerName,
            chips: '100000', // 기본 칩
            initialChips: '100000',
            hand: [],
            role: null
          });
        }
      }
      return true; // 항상 true 반환
    }

    validateState(state) {
      // 상태 로깅만
      console.log(`현재 플레이어 수: ${state.playersInHand.length}`);
      return true; // 항상 true 반환
    }

    updateState() {
      // 상태 업데이트 (로깅용)
      console.log('상태 업데이트');
      return true;
    }

    calculateHash(data) {
      return JSON.stringify(data).split('').reduce((a, b) => {
        a = ((a << 5) - a) + b.charCodeAt(0);
        return a & a;
      }, 0).toString(16);
    }
  }

  // 메인 액션 관리자 - ActionOrderManagerV2로 대체됨
  // 기존 ActionOrderManager 클래스는 src/js/action-order-manager-v2.js로 이동
  /* Legacy ActionOrderManager removed - using ActionOrderManagerV2 instead
  class ActionOrderManager {
    constructor() {
      this.currentStreet = 'preflop';
      this.currentPlayerIndex = 0;
      this.actionMode = 'auto'; // 'auto' | 'manual'
      this.actionQueue = [];
      this.bettingRoundComplete = false;

      // 보안 레이어 추가
      this.timekeeper = new SequentialTimekeeper();
      this.rateLimiter = new RateLimiter();
      this.stateValidator = new StateValidator();

      // 액션 뮤텍스 (동시 실행 방지)
      this.isProcessing = false;
    }

    // 포지션별 액션 순서 계산
    calculateActionOrder(street) {
      const playersInHand = window.state.playersInHand || [];
      if (playersInHand.length === 0) return [];

      const buttonPosition = parseInt(window.state.buttonPosition) || 1;
      const activePlayers = this.getActivePlayers(playersInHand);

      if (street === 'preflop') {
        return this.getPreflopOrder(activePlayers, buttonPosition);
      } else {
        return this.getPostflopOrder(activePlayers, buttonPosition);
      }
    }

    // 활성 플레이어 필터링 (폴드/올인 제외)
    getActivePlayers(players) {
      return players.filter(p =>
        window.state.playerStatus[p.name] !== 'folded' &&
        window.state.playerStatus[p.name] !== 'allin'
      );
    }

    // 프리플랍 순서 (UTG → BTN → SB → BB)
    getPreflopOrder(players, buttonPosition) {
      if (players.length === 0) return [];

      const seatMap = {};
      players.forEach(p => {
        if (p.seat) seatMap[p.seat] = p;
      });

      const occupiedSeats = Object.keys(seatMap).map(Number).sort((a, b) => a - b);
      const order = [];

      // UTG부터 시작하여 BTN까지
      let utgSeat = this.getNextOccupiedSeat(buttonPosition, occupiedSeats);
      if (occupiedSeats.length > 2) {
        utgSeat = this.getNextOccupiedSeat(utgSeat, occupiedSeats); // SB 스킵
        utgSeat = this.getNextOccupiedSeat(utgSeat, occupiedSeats); // BB 스킵
      }

      let currentSeat = utgSeat;
      const visited = new Set();

      while (!visited.has(currentSeat) && order.length < players.length) {
        visited.add(currentSeat);
        if (seatMap[currentSeat]) {
          order.push(seatMap[currentSeat]);
        }
        currentSeat = this.getNextOccupiedSeat(currentSeat, occupiedSeats);

        // BTN까지 도달했으면 SB, BB 추가
        if (currentSeat === buttonPosition) {
          if (seatMap[currentSeat]) order.push(seatMap[currentSeat]);

          // SB 추가
          const sbSeat = this.getNextOccupiedSeat(buttonPosition, occupiedSeats);
          if (seatMap[sbSeat]) order.push(seatMap[sbSeat]);

          // BB 추가
          const bbSeat = this.getNextOccupiedSeat(sbSeat, occupiedSeats);
          if (seatMap[bbSeat]) order.push(seatMap[bbSeat]);
          break;
        }
      }

      return order;
    }

    // 포스트플랍 순서 (SB → BB → UTG → BTN)
    getPostflopOrder(players, buttonPosition) {
      if (players.length === 0) return [];

      const seatMap = {};
      players.forEach(p => {
        if (p.seat) seatMap[p.seat] = p;
      });

      const occupiedSeats = Object.keys(seatMap).map(Number).sort((a, b) => a - b);
      const order = [];

      // SB부터 시작
      let sbSeat = this.getNextOccupiedSeat(buttonPosition, occupiedSeats);
      let currentSeat = sbSeat;
      const visited = new Set();

      while (!visited.has(currentSeat) && order.length < players.length) {
        visited.add(currentSeat);
        if (seatMap[currentSeat]) {
          order.push(seatMap[currentSeat]);
        }
        currentSeat = this.getNextOccupiedSeat(currentSeat, occupiedSeats);
      }

      return order;
    }

    // 다음 점유된 좌석 찾기
    getNextOccupiedSeat(currentSeat, occupiedSeats) {
      const maxSeat = Math.max(...occupiedSeats);
      let nextSeat = currentSeat + 1;

      while (nextSeat <= maxSeat + occupiedSeats.length) {
        const seat = ((nextSeat - 1) % maxSeat) + 1;
        if (occupiedSeats.includes(seat)) {
          return seat;
        }
        nextSeat++;
      }

      return occupiedSeats[0];
    }

    // 현재 액션할 플레이어 반환
    getCurrentActionPlayer() {
      if (this.actionMode === 'manual') return null;

      const actionOrder = this.calculateActionOrder(this.currentStreet);
      if (actionOrder.length === 0) return null;

      return actionOrder[this.currentPlayerIndex % actionOrder.length];
    }

    // 다음 플레이어로 이동
    moveToNextPlayer() {
      const actionOrder = this.calculateActionOrder(this.currentStreet);
      if (actionOrder.length === 0) return null;

      this.currentPlayerIndex++;

      // 베팅 라운드 완료 체크
      if (this.currentPlayerIndex >= actionOrder.length) {
        if (this.isBettingRoundComplete()) {
          this.advanceToNextStreet();
          return null;
        } else {
          this.currentPlayerIndex = 0; // 다시 처음부터
        }
      }

      return this.getCurrentActionPlayer();
    }

    // 베팅 라운드 완료 여부 체크 (특수 케이스 포함)
    isBettingRoundComplete() {
      const actions = window.state.actionState[this.currentStreet] || [];
      const activePlayers = this.getActivePlayers(window.state.playersInHand || []);
      const allPlayers = window.state.playersInHand || [];

      // 특수 케이스 1: 1명만 남은 경우 (나머지 폴드)
      if (activePlayers.length <= 1) {
        console.log('🏆 1명만 남음 - 라운드 완료');
        return true;
      }

      // 특수 케이스 2: 헤즈업에서 BB 체크 옵션
      if (allPlayers.length === 2 && this.currentStreet === 'preflop') {
        const bbPlayer = this.getBigBlindPlayer();
        const sbPlayer = this.getSmallBlindPlayer();

        if (bbPlayer && sbPlayer) {
          const bbActions = actions.filter(a => a.player === bbPlayer.name);
          const sbActions = actions.filter(a => a.player === sbPlayer.name);

          // SB가 콜했고 BB가 체크한 경우
          if (sbActions.some(a => a.action === 'Calls') &&
              bbActions.some(a => a.action === 'Checks')) {
            console.log('🎯 헤즈업 BB 체크 - 라운드 완료');
            return true;
          }
        }
      }

      // 특수 케이스 3: 모든 활성 플레이어가 올인인 경우
      const allActiveAreAllIn = activePlayers.every(p =>
        window.state.playerStatus[p.name] === 'allin'
      );
      if (allActiveAreAllIn && activePlayers.length > 0) {
        console.log('🚀 모든 플레이어 올인 - 라운드 완료');
        return true;
      }

      // 일반 케이스: 모든 플레이어가 액션했는지 확인
      const playersActed = new Set(actions.map(a => a.player));
      const allActed = activePlayers.every(p => playersActed.has(p.name));

      if (!allActed) return false;

      // 베팅 금액이 맞는지 확인
      return this.areAllBetsEqual(activePlayers, actions);
    }

    // 빅블라인드 플레이어 찾기
    getBigBlindPlayer() {
      const buttonPosition = parseInt(window.state.buttonPosition) || 1;
      const players = window.state.playersInHand || [];
      const occupiedSeats = players.map(p => p.seat).filter(s => s).map(Number).sort((a, b) => a - b);

      if (occupiedSeats.length < 2) return null;

      const sbSeat = this.getNextOccupiedSeat(buttonPosition, occupiedSeats);
      const bbSeat = this.getNextOccupiedSeat(sbSeat, occupiedSeats);

      return players.find(p => p.seat === bbSeat);
    }

    // 스몰블라인드 플레이어 찾기
    getSmallBlindPlayer() {
      const buttonPosition = parseInt(window.state.buttonPosition) || 1;
      const players = window.state.playersInHand || [];
      const occupiedSeats = players.map(p => p.seat).filter(s => s).map(Number).sort((a, b) => a - b);

      if (occupiedSeats.length < 2) return null;

      const sbSeat = this.getNextOccupiedSeat(buttonPosition, occupiedSeats);
      return players.find(p => p.seat === sbSeat);
    }

    // 모든 베팅이 같은지 확인 (사이드팟 고려)
    areAllBetsEqual(players, actions) {
      const playerBets = {};

      // 각 플레이어의 총 베팅 계산
      actions.forEach(action => {
        if (!playerBets[action.player]) playerBets[action.player] = 0;

        if (action.action.includes('Call') || action.action.includes('Raise') || action.action.includes('Bet')) {
          playerBets[action.player] = action.amount || 0;
        } else if (action.action === 'All In') {
          const player = window.state.playersInHand.find(p => p.name === action.player);
          playerBets[action.player] = player ? parseInt(unformatNumber(player.chips), 10) : 0;
        }
      });

      const bets = Object.values(playerBets);
      const maxBet = Math.max(...bets, 0);

      // 사이드팟 케이스: 올인 플레이어가 있는 경우
      const hasAllIn = players.some(p => window.state.playerStatus[p.name] === 'allin');

      if (hasAllIn) {
        // 올인 플레이어들의 베팅 금액
        const allInAmounts = players
          .filter(p => window.state.playerStatus[p.name] === 'allin')
          .map(p => playerBets[p.name] || 0);

        // 액티브 플레이어들이 최소한 올인 금액 이상 베팅했는지 확인
        return players.every(p => {
          const playerBet = playerBets[p.name] || 0;
          const isAllIn = window.state.playerStatus[p.name] === 'allin';

          if (isAllIn) {
            return true; // 올인 플레이어는 항상 OK
          }

          // 액티브 플레이어는 최대 베팅과 같아야 함
          return playerBet === maxBet;
        });
      }

      // 일반 케이스: 모든 액티브 플레이어의 베팅이 같아야 함
      return players.every(p => {
        const playerBet = playerBets[p.name] || 0;
        return playerBet === maxBet;
      });
    }

    // 다음 스트릿으로 진행 (보안 레이어 포함)
    async advanceToNextStreet() {
      const streets = ['preflop', 'flop', 'turn', 'river'];
      const currentIndex = streets.indexOf(this.currentStreet);

      if (currentIndex < streets.length - 1) {
        const nextStreet = streets[currentIndex + 1];

        // Layer 4: 보드 카드 검증
        if (nextStreet !== 'preflop' && !this.checkBoardCards(nextStreet)) {
          // 보드 카드 입력 프롬프트
          this.promptForBoardCards(nextStreet);
          return;
        }

        // Layer 5: 트랜잭션 보호
        const transaction = this.startTransaction();
        try {
          // 타임스탬프 검증
          const timestamp = this.timekeeper.generateTimestamp();

          // 상태 변경
          this.currentStreet = nextStreet;
          this.currentPlayerIndex = 0;
          window.state.currentStreet = this.currentStreet;

          // 상태 해시 업데이트
          this.stateValidator.updateState();

          console.log(`%c🎯 자동 진행: ${this.currentStreet.toUpperCase()}`, 'color: #10b981; font-weight: bold');
          this.showStreetAdvanceNotification();

          // 트랜잭션 커밋
          transaction.commit();
        } catch (error) {
          // 에러가 발생해도 최대한 진행
          console.log('스트릿 진행 중 예외:', error.message);
          transaction.rollback();
          // 그래도 스트릿은 진행
          this.currentStreet = nextStreet;
          this.currentPlayerIndex = 0;
          window.state.currentStreet = this.currentStreet;
          this.showStreetAdvanceNotification();
        }
      }
    }

    // 보드 카드 확인
    checkBoardCards(street) {
      const boardCards = window.state.boardCards || {};

      switch(street) {
        case 'flop':
          return boardCards.flop1 && boardCards.flop2 && boardCards.flop3;
        case 'turn':
          return boardCards.turn;
        case 'river':
          return boardCards.river;
        default:
          return true;
      }
    }

    // 보드 카드 입력 프롬프트 (v3.4.7 - 카드 선택 UI 사용)
    promptForBoardCards(street) {
      // 카드 선택 UI 열기 (openCardSelector 사용)
      window.state.modalState.cardTarget = {
        target: 'board',
        count: street === 'flop' ? 3 : 1,
        street: street,
        player: null,
        index: street === 'turn' ? 3 : street === 'river' ? 4 : 0
      };

      // 기존 카드 선택 모달 사용
      openCardSelector();
    }

    // 보드 카드 저장 (v3.4.7 - 카드 선택 UI와 연동)
    saveBoardCards(street) {
      // 이 함수는 더 이상 직접 호출되지 않음
      // openCardSelector의 assignCard 함수가 처리
      console.log('[v3.4.7] saveBoardCards는 deprecated - assignCard 사용');
    }

    // 보드 카드 건너뛰기 (v3.4.7 - 수정됨)
    skipBoardCards(street) {
      console.log(`보드 카드 입력 건너뛰기: ${street}`);
      // 보드 카드 없이 진행
      this.currentStreet = street;
      this.currentPlayerIndex = 0;
      window.state.currentStreet = this.currentStreet;

      // showFeedback 함수 확인
      if (typeof showFeedback === 'function') {
        showFeedback(`🎯 ${this.currentStreet.toUpperCase()} 스트릿으로 진행`, false);
      } else {
        console.log(`🎯 ${this.currentStreet.toUpperCase()} 스트릿으로 진행`);
      }
    }

    // 트랜잭션 시작 (Layer 5)
    startTransaction() {
      const snapshot = {
        currentStreet: this.currentStreet,
        currentPlayerIndex: this.currentPlayerIndex,
        actionState: JSON.parse(JSON.stringify(window.state.actionState || {})),
        playerStatus: {...window.state.playerStatus}
      };

      return {
        commit: () => {
          console.log('트랜잭션 커밋');
        },
        rollback: () => {
          this.currentStreet = snapshot.currentStreet;
          this.currentPlayerIndex = snapshot.currentPlayerIndex;
          window.state.actionState = snapshot.actionState;
          window.state.playerStatus = snapshot.playerStatus;
          console.error('트랜잭션 롤백');
        }
      };
    }

    // 스트릿 진행 알림 (v3.4.7 - showFeedback 함수 체크 추가)
    showStreetAdvanceNotification() {
      if (typeof showFeedback === 'function') {
        showFeedback(`🎯 ${this.currentStreet.toUpperCase()} 스트릿으로 자동 진행`, false);
      } else {
        console.log(`🎯 ${this.currentStreet.toUpperCase()} 스트릿으로 자동 진행`);
      }
    }

    // 모드 전환
    toggleMode() {
      this.actionMode = this.actionMode === 'auto' ? 'manual' : 'auto';
      console.log(`%c액션 모드 변경: ${this.actionMode}`, 'color: #f59e0b; font-weight: bold');
      return this.actionMode;
    }
  }
  */

  // 전역 액션 관리자 인스턴스 - ActionOrderManagerV2 사용
  // window.actionOrderManager는 action-order-manager-v2.js에서 생성됨

  // 모든 버전 표시를 업데이트하는 함수
  function updateAllVersionDisplays() {
    // 버전 표시 엘리먼트 업데이트
    const versionDisplay = document.getElementById('version-display');
    if (versionDisplay) {
      versionDisplay.textContent = APP_VERSION;
    }
    
    // 타이틀 업데이트
    document.title = `포커 핸드 로거 ${APP_VERSION}`;
    
    // 콘솔에 버전 정보 출력
    console.log(`%c${VERSION_INFO}`, 'color: #10b981; font-weight: bold; font-size: 14px');
  }
  
  // Gemini API 설정
  const GEMINI_API_KEY = 'AIzaSyBB8uqP1ECTe40jknSy5XK71TCs8_KbGV0';
  const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
  
  // 버전 정보를 항상 콘솔에 표시
  console.log(`%c====================================`, 'color: #fbbf24');
  console.log(`%c🎯 ${VERSION_INFO}`, 'color: #fbbf24; font-size: 18px; font-weight: bold');
  console.log(`%c====================================`, 'color: #fbbf24');
  console.log('%c📱 AI 칩 스택 분석 기능 활성화', 'color: #10b981');
  console.log('%c💡 관리 버튼 → 칩 컬러 탭에서 칩 등록', 'color: #60a5fa');
  
  // 모든 에러를 로그로 리다이렉트 (오류 방지)
  const originalError = console.error;
  const originalWarn = console.warn;
  console.error = function(...args) {
    // console.log로 리다이렉트
    console.log.apply(console, [`[${APP_VERSION}] INFO:`, ...args]);
  };
  console.warn = function(...args) {
    // console.log로 리다이렉트
    console.log.apply(console, [`[${APP_VERSION}] NOTICE:`, ...args]);
  };
  
  document.addEventListener('DOMContentLoaded', () => {
    // 버전 표시 업데이트
    updateAllVersionDisplays();
    
    console.log(`%c🚀 앱 초기화 시작 - ${VERSION_INFO}`, 'color: #10b981; font-weight: bold');
    console.log('Initialized at', new Date().toISOString());
    
    // 칩 분석 모듈 초기화는 state 객체 생성 후에 진행
    
    // 화면에 버전 표시 업데이트
    const versionDisplay = document.getElementById('version-display');
    if(versionDisplay) {
      versionDisplay.textContent = `${APP_VERSION} (${VERSION_DATE})`;
    }
    
    // ====== CONFIG (필수: 실제 URL로 교체) ======
    // Google Sheets 설정 (localStorage에서 로드)
    const DEFAULT_APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwEcsF1F_RLLW_qkQIFkrwmut-zN0fHOqsAKs5B8PgHZAz2_O5sA8o2W5zZ3nD-5tjY/exec";
    let APPS_SCRIPT_URL = localStorage.getItem('appsScriptUrl') || DEFAULT_APPS_SCRIPT_URL;

    // Google Sheets API Spreadsheet ID 설정
    let GOOGLE_SHEETS_SPREADSHEET_ID = localStorage.getItem('googleSheetsSpreadsheetId') || null;
    
    // CSV URLs (고정)
    const CSV_HAND_URL  = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSDY_i4330JANAjIz4sMncdJdRHsOkfUCjQusHTGQk2tykrhA4d09LeIp3XRbLd8hkN6SgSB47k_nux/pub?gid=1906746276&single=true&output=csv"; // Hand 탭 CSV
    const CSV_INDEX_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSDY_i4330JANAjIz4sMncdJdRHsOkfUCjQusHTGQk2tykrhA4d09LeIp3XRbLd8hkN6SgSB47k_nux/pub?gid=1354012271&single=true&output=csv"; // Index 탭 CSV (HandIndex 대신 Index 사용)
    const CSV_TYPE_URL  = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSDY_i4330JANAjIz4sMncdJdRHsOkfUCjQusHTGQk2tykrhA4d09LeIp3XRbLd8hkN6SgSB47k_nux/pub?gid=998576925&single=true&output=csv";
    const CSV_CONFIG_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSDY_i4330JANAjIz4sMncdJdRHsOkfUCjQusHTGQk2tykrhA4d09LeIp3XRbLd8hkN6SgSB47k_nux/pub?gid=0&single=true&output=csv"; // Config 탭 CSV
    
    // 전역 변수로도 설정 (테이블 관리 모듈용)
    window.APPS_SCRIPT_URL = APPS_SCRIPT_URL;

    // Config 시트에서 기본 Spreadsheet URL 로드 함수
    async function loadDefaultUrlFromConfig() {
      try {
        console.log('📄 Config 시트에서 기본 URL 로딩 시도...');
        const response = await fetch(CSV_CONFIG_URL);
        const csvText = await response.text();
        const lines = csvText.trim().split('\n');

        if (lines.length > 0) {
          const firstRow = lines[0].split(',');
          const a1Value = firstRow[0]?.trim().replace(/['"]/g, ''); // 따옴표 제거

          if (a1Value && a1Value.includes('docs.google.com/spreadsheets')) {
            console.log('✅ Config 시트에서 기본 URL 로드 성공:', a1Value);
            return a1Value;
          }
        }
      } catch (error) {
        console.log('⚠️ Config 시트 로드 실패:', error.message);
      }
      return null;
    }

    // URL에서 Spreadsheet ID 추출 함수
    function extractSpreadsheetIdFromUrl(url) {
      if (!url) return null;

      // Google Sheets URL 패턴 매칭: /spreadsheets/d/{ID}/
      const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9_-]+)\//);
      return match ? match[1] : null;
    }

    // Google Sheets API 초기화 (Config에서 기본값 로드)
    async function initializeGoogleSheetsAPI() {
      let spreadsheetId = GOOGLE_SHEETS_SPREADSHEET_ID;

      // localStorage에 ID가 없으면 Config 시트에서 로드
      if (!spreadsheetId) {
        console.log('📄 localStorage에 Spreadsheet ID가 없음. Config 시트에서 기본 URL 로딩...');
        const defaultUrl = await loadDefaultUrlFromConfig();
        if (defaultUrl) {
          spreadsheetId = extractSpreadsheetIdFromUrl(defaultUrl);
          if (spreadsheetId) {
            localStorage.setItem('googleSheetsSpreadsheetId', spreadsheetId);
            localStorage.setItem('googleSheetsDefaultUrl', defaultUrl);
            console.log('✅ Config에서 로드한 Spreadsheet ID:', spreadsheetId);
            console.log('✅ Config에서 로드한 URL:', defaultUrl);

            // UI에 즉시 반영 (관리 모달이 열려있을 때)
            const currentUrlSpan = document.getElementById('management-current-url');
            if (currentUrlSpan) {
              currentUrlSpan.textContent = defaultUrl;
              currentUrlSpan.className = 'text-xs text-green-400 break-all font-mono';
            }
          }
        }
      }

      if (spreadsheetId && window.googleSheetsAPI) {
        window.googleSheetsAPI.setSpreadsheetId(spreadsheetId);
        console.log('✅ Google Sheets API 초기화 완료 - Spreadsheet ID:', spreadsheetId);
      } else if (!spreadsheetId) {
        console.log('⚠️ Google Sheets Spreadsheet ID가 설정되지 않았습니다. 설정 메뉴에서 URL을 입력해주세요.');
      }
    }

    // Google Sheets API 초기화 실행
    initializeGoogleSheetsAPI();
    
    // Apps Script URL 클라우드 동기화 시스템
    const CLOUD_SYNC_CONFIG = {
      enabled: true,
      gistApiUrl: 'https://api.github.com/gists',
      configGistId: localStorage.getItem('configGistId') || null,
      deviceId: localStorage.getItem('deviceId') || generateDeviceId()
    };

    // 기기 ID를 localStorage에 저장 (처음 생성시)
    if (!localStorage.getItem('deviceId')) {
      localStorage.setItem('deviceId', CLOUD_SYNC_CONFIG.deviceId);
    }

    // 고유 기기 ID 생성
    function generateDeviceId() {
      const id = 'device_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now().toString(36);
      localStorage.setItem('deviceId', id);
      return id;
    }

    // 클라우드에서 설정 로드
    async function loadConfigFromCloud() {
      if (!CLOUD_SYNC_CONFIG.enabled || !CLOUD_SYNC_CONFIG.configGistId) {
        return null;
      }

      try {
        const response = await fetch(`${CLOUD_SYNC_CONFIG.gistApiUrl}/${CLOUD_SYNC_CONFIG.configGistId}`);
        if (response.ok) {
          const gist = await response.json();
          const configFile = gist.files['poker-config.json'];
          if (configFile) {
            const config = JSON.parse(configFile.content);
            console.log('☁️ 클라우드에서 설정 로드:', config);
            return config;
          }
        }
      } catch (error) {
        console.log('클라우드 설정 로드 실패:', error.message);
      }
      return null;
    }

    // 클라우드에 설정 저장
    async function saveConfigToCloud(appsScriptUrl) {
      if (!CLOUD_SYNC_CONFIG.enabled) return false;

      const config = {
        appsScriptUrl: appsScriptUrl,
        lastUpdated: new Date().toISOString(),
        deviceId: CLOUD_SYNC_CONFIG.deviceId,
        version: APP_VERSION
      };

      const gistContent = {
        description: 'Poker Hand Logger Configuration',
        public: false,
        files: {
          'poker-config.json': {
            content: JSON.stringify(config, null, 2)
          }
        }
      };

      try {
        let response;
        if (CLOUD_SYNC_CONFIG.configGistId) {
          // 기존 Gist 업데이트
          response = await fetch(`${CLOUD_SYNC_CONFIG.gistApiUrl}/${CLOUD_SYNC_CONFIG.configGistId}`, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(gistContent)
          });
        } else {
          // 새 Gist 생성
          response = await fetch(CLOUD_SYNC_CONFIG.gistApiUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(gistContent)
          });
        }

        if (response.ok) {
          const gist = await response.json();
          CLOUD_SYNC_CONFIG.configGistId = gist.id;
          localStorage.setItem('configGistId', gist.id);
          console.log('☁️ 설정이 클라우드에 저장됨:', gist.id);
          return true;
        }
      } catch (error) {
        console.log('클라우드 저장 실패:', error.message);
      }
      return false;
    }

    // Apps Script URL 업데이트 함수 (클라우드 동기화 포함)
    async function updateAppsScriptUrl(newUrl, skipCloudSync = false) {
      if (newUrl && newUrl.trim()) {
        APPS_SCRIPT_URL = newUrl.trim();
        window.APPS_SCRIPT_URL = APPS_SCRIPT_URL;
        
        // ⚠️ 중요: APP_CONFIG도 함께 업데이트
        if (window.APP_CONFIG) {
          window.APP_CONFIG.appsScriptUrl = APPS_SCRIPT_URL;
          console.log('✅ APP_CONFIG.appsScriptUrl 동기화:', window.APP_CONFIG.appsScriptUrl);
        }
        
        localStorage.setItem('appsScriptUrl', APPS_SCRIPT_URL);
        console.log('✅ Apps Script URL 업데이트:', APPS_SCRIPT_URL);

        // 클라우드에 저장 (옵션)
        if (!skipCloudSync && CLOUD_SYNC_CONFIG.enabled) {
          const cloudSaved = await saveConfigToCloud(APPS_SCRIPT_URL);
          if (cloudSaved) {
            showFeedback('✅ Apps Script URL 업데이트 및 클라우드 동기화 완료');
          } else {
            showFeedback('✅ Apps Script URL 업데이트 완료 (로컬 저장)');
          }
        } else {
          showFeedback('✅ Apps Script URL 업데이트 완료');
        }
        return true;
      }
      return false;
    }

    // ====== LOADING & UI LOCK SYSTEM ======
    let isUILocked = false;

    // UI 전체 비활성화
    function lockUI(title = '처리 중...', message = '잠시만 기다려주세요') {
      if (isUILocked) return; // 이미 잠금 상태면 무시

      isUILocked = true;

      // 로딩 오버레이 표시
      if (el.loadingOverlay) {
        if (el.loadingTitle) el.loadingTitle.textContent = title;
        if (el.loadingMessage) el.loadingMessage.textContent = message;
        el.loadingOverlay.classList.remove('hidden');
      }

      // 모든 버튼 비활성화
      document.querySelectorAll('button').forEach(btn => {
        btn.disabled = true;
        btn.classList.add('opacity-50', 'cursor-not-allowed');
      });

      // 모든 입력 필드 비활성화
      document.querySelectorAll('input, select, textarea').forEach(input => {
        input.disabled = true;
        input.classList.add('opacity-50', 'cursor-not-allowed');
      });

      console.log(`🔒 UI 잠금: ${title}`);
    }

    // UI 전체 활성화
    function unlockUI() {
      if (!isUILocked) return; // 이미 해제 상태면 무시

      isUILocked = false;

      // 로딩 오버레이 숨기기
      if (el.loadingOverlay) {
        el.loadingOverlay.classList.add('hidden');
      }

      // 모든 버튼 활성화
      document.querySelectorAll('button').forEach(btn => {
        btn.disabled = false;
        btn.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      // 모든 입력 필드 활성화
      document.querySelectorAll('input, select, textarea').forEach(input => {
        input.disabled = false;
        input.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      console.log('🔓 UI 잠금 해제');
    }

    // 작업 실행 래퍼 (자동 UI 잠금/해제)
    async function executeWithLock(asyncFunction, title = '처리 중...', message = '잠시만 기다려주세요') {
      try {
        lockUI(title, message);
        await asyncFunction();
      } catch (error) {
        console.log('작업 실행 중 오류:', error);
        showFeedback('작업 중 오류가 발생했습니다: ' + error.message, true);
      } finally {
        unlockUI();
      }
    }

    // 클라우드 동기화 UI 업데이트
    function updateCloudSyncUI() {
      if (!el.cloudSyncStatus || !el.deviceIdDisplay) return;

      // 기기 ID 표시
      el.deviceIdDisplay.textContent = CLOUD_SYNC_CONFIG.deviceId.substring(0, 8) + '...';

      // 동기화 상태 표시
      if (CLOUD_SYNC_CONFIG.enabled && CLOUD_SYNC_CONFIG.configGistId) {
        el.cloudSyncStatus.textContent = '연결됨';
        el.cloudSyncStatus.className = 'text-xs px-2 py-1 rounded-full bg-green-600 text-white';

        // 마지막 동기화 시간 표시
        const lastSync = localStorage.getItem('lastCloudSync');
        if (lastSync && el.lastSyncDisplay) {
          const syncDate = new Date(lastSync);
          el.lastSyncDisplay.querySelector('span').textContent = syncDate.toLocaleString('ko-KR');
          el.lastSyncDisplay.classList.remove('hidden');
        }
      } else {
        el.cloudSyncStatus.textContent = '미연결';
        el.cloudSyncStatus.className = 'text-xs px-2 py-1 rounded-full bg-gray-600 text-gray-400';
        if (el.lastSyncDisplay) {
          el.lastSyncDisplay.classList.add('hidden');
        }
      }
    }

    // 수동 클라우드 동기화
    async function syncCloudNow() {
      if (!CLOUD_SYNC_CONFIG.enabled) {
        showFeedback('클라우드 동기화가 비활성화되어 있습니다', true);
        return;
      }

      await executeWithLock(async () => {
        // 현재 설정을 클라우드에 저장
        await saveConfigToCloud(APPS_SCRIPT_URL);
        localStorage.setItem('lastCloudSync', new Date().toISOString());

        // UI 업데이트
        updateCloudSyncUI();
        showFeedback('☁️ 클라우드 동기화 완료');
      }, '클라우드 동기화', 'Apps Script URL을 클라우드에 저장하고 있습니다...');
    }

    // 클라우드 설정 초기화 (Phase 2: 더블탭 적용)
    function resetCloudConfig() {
      // 실제 초기화 로직
      const performReset = () => {
        // 로컬 저장소에서 클라우드 관련 정보 제거
        localStorage.removeItem('configGistId');
        localStorage.removeItem('lastCloudSync');
        CLOUD_SYNC_CONFIG.configGistId = null;

        // UI 업데이트
        updateCloudSyncUI();

        // 스낵바로 피드백
        if (window.actionHistory) {
          window.actionHistory.showSnackbar('☁️ 클라우드 설정이 초기화되었습니다', null, 'success');
        } else {
          showFeedback('클라우드 설정이 초기화되었습니다');
        }
      };

      // 즉시 실행 (더블탭은 나중에 설정 가능)
      performReset();
    }

    // 앱 시작 시 클라우드 설정 확인
    async function initializeAppConfig() {
      const cloudConfig = await loadConfigFromCloud();
      if (cloudConfig && cloudConfig.appsScriptUrl) {
        // 클라우드 설정이 더 최신인 경우 적용
        const localUpdated = localStorage.getItem('appsScriptUrlUpdatedAt');
        const cloudUpdated = cloudConfig.lastUpdated;

        if (!localUpdated || (cloudUpdated && new Date(cloudUpdated) > new Date(localUpdated))) {
          console.log('☁️ 클라우드에서 최신 설정 적용');
          await updateAppsScriptUrl(cloudConfig.appsScriptUrl, true);
          localStorage.setItem('appsScriptUrlUpdatedAt', cloudConfig.lastUpdated);
        }
      }
    }

    // 초기화 실행 (백그라운드에서 수행)
    initializeAppConfig().catch(err => console.log('클라우드 설정 초기화 실패:', err.message));

    // ====== STATE ======
    let timeUpdater;
    window.state = {
      currentStreet: 'preflop',  // 현재 진행 중인 스트리트
      camNumbers: { cam1no:'', cam2no:'' }, // 파일 넘버 입력이 있다면 여기에 저장
      lastCamNo: null,        // 마지막 입력 추적(연속 증가 기본값 제공용)

      playerDataByTable: {},     // { [table]: [{name, chips, notable}] }
      camPreset: { cam1:'', cam2:'' }, // Type!A2/A3
      allTables: [],
      indexRows: [],             // [{handNumber, handUpdatedAt, table, ...}]
      allHandNumbers: [],        // latest numbers (from Index)
      handCsvCache: null,        // raw rows for on-demand hand parsing
      allHandData: {},           // { [handNumber]: parsed hand block (latest) }
      selectedTable: null,
      playersInHand: [],
      board: [],
      playerStatus: {},          // { playerName: 'active' | 'folded' | 'allin' }
      buttonPosition: null,      // 버튼 위치 (seat 번호)
      seatMap: {},              // { seat: playerName } 10개 좌석 매핑
      nextActionSeat: null,      // 다음 액션 플레이어 좌석
      
      // 액션 자동 매핑 시스템
      actionInputMode: localStorage.getItem('actionInputMode') || 'auto', // 'auto' | 'manual'
      currentActionIndex: 0,     // 현재 액션 순서 인덱스
      actionQueue: [],          // 액션 순서 대기열
      nextActionPlayer: null,    // 다음 액션 플레이어
      smartCheckCall: true,      // 스마트 Check/Call 버튼 사용
      actionState: {
        handNumber: '',
        smallBlind: '', bigBlind: '', hasBBAnte: false,
        preflop: [], flop: [], turn: [], river: [],
      },
      modalState: {
        cardTarget: null,
        actionPadStreet: null, actionPadPlayer: null, actionPadCurrentAction: null,
        keypadTarget: null, keypadOptions: {},
      },
      selectedTimezone: 'Asia/Seoul',
      // 칩 분석 관련 상태
      chipColors: [], // [{color: '#fff', value: 1000, image: 'base64...'}]
      maxChips: 5,
      currentChipSlot: null,
      playerStacks: {}, // {playerName: {images: [], estimatedStack: 0, analysis: ''}}
      currentAnalyzingPlayer: null,
      stackImages: [] // 현재 촬영 중인 스택 이미지들
    };

    // 칩 분석 모듈 초기화 (state 객체 생성 후)
    if (typeof initChipAnalyzer === 'function') {
      setTimeout(() => {
        initChipAnalyzer();
        console.log('✅ AI 칩 분석 모듈 활성화');
      }, 100);
    }

    // ====== CONSTS ======
    const SUITS = { s:'♠', h:'♥', d:'♦', c:'♣' };
    const RANKS = ['A','K','Q','J','10','9','8','7','6','5','4','3','2'];

    // ====== EL ======
    const el = {
      refreshDataBtn: document.getElementById('refresh-data'),
      tableSelectorBtn: document.getElementById('table-selector-btn'),
      selectedTableDisplay: document.getElementById('selected-table-display'),
      tableSelectorModal: document.getElementById('table-selector-modal'),
      playerSelectionButtons: document.getElementById('player-selection-buttons'),
      boardCardPlaceholders: document.getElementById('board-card-placeholders'),
      playerDetailsSection: document.getElementById('player-details-section'),
      handNumberDisplay: document.getElementById('hand-number-display'),
      loadHandBtn: document.getElementById('load-hand-btn'),
      smallBlindInput: document.getElementById('small-blind-input'),
      bigBlindInput: document.getElementById('big-blind-input'),
      bbAnteCheckbox: document.getElementById('bb-ante-checkbox'),
      streetLogsContainer: document.getElementById('street-logs-container'),
      winnerButtons: document.getElementById('winner-buttons'),
      sendToSheetBtn: document.getElementById('send-to-sheet-btn'),
      resetBtn: document.getElementById('reset-btn'),
      feedbackMessage: document.getElementById('feedback-message'),
      logDisplay: document.getElementById('log-display'),
      logModal: document.getElementById('log-modal'),
      showLogBtn: document.getElementById('show-log-btn'),
      closeLogModalBtn: document.getElementById('close-log-modal'),
      cardSelectorModal: document.getElementById('card-selector-modal'),
      actionPadModal: document.getElementById('action-pad-modal'),
      keypadModal: document.getElementById('keypad-modal'),
      loadHandModal: document.getElementById('load-hand-modal'),
      timezoneSelector: document.getElementById('timezone-selector'),
      timeDisplay: document.getElementById('time-display'),
      managePlayersBtn: document.getElementById('manage-players-btn'),
      registrationModal: document.getElementById('registration-modal'),
      cam1: document.getElementById('cam-btn-1'),
      cam2: document.getElementById('cam-btn-2'),
      dataStamp: document.getElementById('data-stamp'),
      // 설정 모달 관련
      settingsBtn: document.getElementById('settings-btn'),
      settingsModal: document.getElementById('settings-modal'),
      closeSettingsBtn: document.getElementById('close-settings'),
      cancelSettingsBtn: document.getElementById('cancel-settings'),
      saveSettingsBtn: document.getElementById('save-settings'),
      googleSpreadsheetIdInput: document.getElementById('google-spreadsheet-id-input'),
      currentSpreadsheetId: document.getElementById('current-spreadsheet-id'),
      chipValidationToggle: document.getElementById('chip-validation-toggle'),
      cloudSyncStatus: document.getElementById('cloud-sync-status'),
      deviceIdDisplay: document.getElementById('device-id-display'),
      lastSyncDisplay: document.getElementById('last-sync-display'),
      syncNowBtn: document.getElementById('sync-now-btn'),
      resetCloudBtn: document.getElementById('reset-cloud-btn'),
      loadingOverlay: document.getElementById('loading-overlay'),
      loadingTitle: document.getElementById('loading-title'),
      loadingMessage: document.getElementById('loading-message'),
    };

    // ====== LOG MODAL ======
    function openLogModal(){
      el.logModal.classList.remove('hidden');
      el.logModal.classList.remove('opacity-0');
    }
    function closeLogModal(){ el.logModal.classList.add('opacity-0', 'hidden'); }
    function logMessage(msg,isError=false){
      const d=document.createElement('div');
      d.textContent=`[${new Date().toLocaleTimeString()}] ${msg}`;
      d.className=isError?'text-red-400':'text-green-400';
      el.logDisplay.appendChild(d); el.logDisplay.scrollTop=el.logDisplay.scrollHeight;
    }

    // 전역 함수로 노출 (DuplicateRemover에서 접근 가능하도록)
    window.openLogModal = openLogModal;
    window.closeLogModal = closeLogModal;
    window.logMessage = logMessage;

    // ====== TIME/TZ ======
    function getFormattedTimeInTimezone(date, tz){
      try{
        return new Intl.DateTimeFormat('ko-KR',{timeZone:tz,hour12:false,hour:'2-digit',minute:'2-digit',second:'2-digit'}).format(date);
      }catch(_){
        const pad=n=>String(n).padStart(2,'0');
        return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
      }
    }
    function populateTimezones(){
      const tzs={ "Asia/Seoul":"한국(KST)", "Asia/Nicosia":"키프로스(EET)" };
      const s=el.timezoneSelector; s.innerHTML='';
      for(const [v,t] of Object.entries(tzs)){
        const opt=document.createElement('option'); opt.value=v; opt.textContent=t; s.appendChild(opt);
      }
      s.value=window.state.selectedTimezone;
    }
    function updateTimeDisplay(){ el.timeDisplay.textContent=getFormattedTimeInTimezone(new Date(),window.state.selectedTimezone); }

    // ====== UTILS ======
    const formatNumber = (val) => val ? new Intl.NumberFormat('en-US').format(String(val).replace(/,/g,'')) : '';
    const unformatNumber = (val) => String(val || '').replace(/,/g, '');
    const toCamelCase = (s) => s.replace(/-([a-z])/g, g => g[1].toUpperCase());
    const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
    const pad4 = n => String(Math.max(0, parseInt(String(n||'0').replace(/\D/g,''),10)||0)).padStart(4, '0');

    // Robust CSV parse (handles quotes)
    function parseCSV(text){
      const rows=[]; let i=0, field='', inQ=false, row=[];
      while(i<text.length){
        const c=text[i];
        if(inQ){
          if(c==='"'){
            if(text[i+1]==='"'){ field+='"'; i++; } else inQ=false;
          }else field+=c;
        }else{
          if(c===','){ row.push(field); field=''; }
          else if(c==='\n'){ row.push(field); rows.push(row); row=[]; field=''; }
          else if(c==='"'){ inQ=true; }
          else if(c!=='\r'){ field+=c; }
        }
        i++;
      }
      if(field!==''||row.length) { row.push(field); rows.push(row); }
      return rows;
    }

    function formatCardDisplay(cardId){
      const rank=cardId.slice(0,-1), suitKey=cardId.slice(-1);
      const colorClass=(suitKey==='h'||suitKey==='d')?'text-red-500':'text-black';
      return `<div class="card-display h-full w-full ${colorClass}"><div class="rank">${rank}</div><div>${SUITS[suitKey]}</div></div>`;
    }

    // ====== RENDERERS ======
    function renderTableSelection(){
      // 더이상 필요하지 않지만 호환성을 위해 유지
      updateSelectedTableDisplay();
    }

    // ====== 새로운 테이블 선택 시스템 ======
    let tableModalState = {
      currentPage: 1,
      tablesPerPage: 20,
      currentFilter: 'all',
      searchTerm: ''
    };

    function updateSelectedTableDisplay() {
      const display = el.selectedTableDisplay;
      const managementTableName = document.getElementById('selected-table-name');

      if (window.state.selectedTable) {
        const playerCount = (window.state.playerDataByTable[window.state.selectedTable] || []).length;
        const text = `${window.state.selectedTable} (${playerCount}명)`;
        display.textContent = text;
        if (managementTableName) managementTableName.textContent = window.state.selectedTable;
      } else {
        display.textContent = '테이블 선택';
        if (managementTableName) managementTableName.textContent = '테이블을 선택해주세요';
      }
    }

    function getFilteredTables() {
      let tables = window.state.allTables;
      
      // 검색 필터
      if (tableModalState.searchTerm) {
        const term = tableModalState.searchTerm.toLowerCase();
        tables = tables.filter(table => {
          // 테이블 이름 매치
          if (table.toLowerCase().includes(term)) return true;
          // 플레이어 이름 매치
          const players = window.state.playerDataByTable[table] || [];
          return players.some(p => p.name.toLowerCase().includes(term));
        });
      }
      
      // 상태 필터
      if (tableModalState.currentFilter === 'active') {
        tables = tables.filter(table => {
          const players = window.state.playerDataByTable[table] || [];
          return players.length > 0;
        });
      } else if (tableModalState.currentFilter === 'empty') {
        tables = tables.filter(table => {
          const players = window.state.playerDataByTable[table] || [];
          return players.length === 0;
        });
      }
      
      return tables;
    }

    function renderTableGrid() {
      const filteredTables = getFilteredTables();
      const startIdx = (tableModalState.currentPage - 1) * tableModalState.tablesPerPage;
      const endIdx = startIdx + tableModalState.tablesPerPage;
      const pageTables = filteredTables.slice(startIdx, endIdx);
      
      const grid = document.getElementById('table-grid');
      grid.innerHTML = '';
      
      pageTables.forEach(table => {
        const players = window.state.playerDataByTable[table] || [];
        const playerCount = players.length;
        const isSelected = window.state.selectedTable === table;
        
        // 상태별 색상
        let statusColor = 'bg-gray-600'; // 빈 테이블
        if (playerCount >= 7) statusColor = 'bg-green-600'; // 활성
        else if (playerCount >= 4) statusColor = 'bg-yellow-600'; // 보통
        else if (playerCount >= 1) statusColor = 'bg-blue-600'; // 적음
        
        const button = document.createElement('button');
        button.className = `table-btn ${statusColor} hover:brightness-110 p-3 rounded-lg text-white text-sm font-medium relative ${isSelected ? 'ring-2 ring-amber-400' : ''}`;
        button.innerHTML = `
          <div class="text-xs font-bold">${table}</div>
          <div class="text-xs opacity-75">${playerCount}명</div>
          ${isSelected ? '<div class="absolute top-1 right-1 text-amber-400">●</div>' : ''}
        `;
        
        button.onclick = () => {
          window.state.selectedTable = table;
          window.state.playersInHand = [];
          updateSelectedTableDisplay();
          closeTableSelectorModal();

          // 테이블 관리 모드인지 확인
          if (window.isTableManagementMode) {
            // 테이블 관리 모드: 관리 UI로 전환
            document.getElementById('management-menu').classList.add('hidden');
            document.getElementById('player-management-content').classList.remove('hidden');
            // 순서 변경: onManagementTableSelected를 먼저 호출하여 데이터를 설정한 후 UI를 초기화
            onManagementTableSelected(table);

            // 플래그 리셋
            window.isTableManagementMode = false;
          } else {
            // 일반 모드: 기본 렌더링
            renderAll();
          }
        };
        
        grid.appendChild(button);
      });
      
      // 페이지 정보 업데이트
      const totalPages = Math.ceil(filteredTables.length / tableModalState.tablesPerPage);
      const pageInfo = document.getElementById('page-info');
      const startNum = startIdx + 1;
      const endNum = Math.min(endIdx, filteredTables.length);
      pageInfo.textContent = `${startNum}-${endNum} / ${filteredTables.length}`;
      
      // 페이지 버튼 상태
      document.getElementById('prev-page').disabled = tableModalState.currentPage === 1;
      document.getElementById('next-page').disabled = tableModalState.currentPage >= totalPages;
    }

    function openTableSelectorModal() {
      el.tableSelectorModal.classList.remove('hidden');
      renderTableGrid();
      document.getElementById('table-search').focus();
    }

    function closeTableSelectorModal() {
      el.tableSelectorModal.classList.add('hidden');
      tableModalState.searchTerm = '';
      document.getElementById('table-search').value = '';
    }
    function renderPlayerSelection(){
      const seatButtons = document.getElementById('seat-buttons');
      if(!seatButtons) return;
      
      if(!window.state.selectedTable){
        seatButtons.innerHTML='<p class="text-gray-500 text-xs col-span-11">테이블을 먼저 선택해주세요.</p>';
        return;
      }
      
      const tableData = window.state.playerDataByTable[window.state.selectedTable]||[];
      
      // 10개 좌석 버튼 + 버튼 위치 드롭다운 생성
      let html = '';
      
      // 1-10번 좌석 버튼 (좌석 번호 표시 제거)
      for(let seatNum = 1; seatNum <= 10; seatNum++){
        // Type 시트에서 해당 좌석의 플레이어 찾기 (v3.5.41: #1 형식 좌석 처리)
        const playerData = tableData.find(p => {
          const seatStr = String(p.seat || '');
          const seatNumber = seatStr.replace(/[#]/g, ''); // # 제거
          return parseInt(seatNumber, 10) === seatNum;
        });
        const isInHand = playerData && window.state.playersInHand.some(pp => pp.name === playerData.name);
        
        // 포지션 정보 가져오기
        const positions = getPositionsForSeat(seatNum);
        let positionBadge = '';
        let borderClass = '';
        
        if(positions.includes('BTN')) {
          positionBadge = '🎯';
          borderClass = 'border-2 border-yellow-400';
        } else if(positions.includes('SB')) {
          positionBadge = 'SB';
          borderClass = 'border-2 border-green-400';
        } else if(positions.includes('BB')) {
          positionBadge = 'BB';
          borderClass = 'border-2 border-blue-400';
        }
        
        if(playerData){
          const notable = playerData.notable ? '⭐' : '';
          const btnClass = isInHand ? 'bg-amber-600' : 'bg-gray-600 hover:bg-gray-500';
          // 포지션 배지와 플레이어 이름 표시
          let displayText = '';
          if(positionBadge) {
            displayText = positionBadge; // 포지션이 있으면 포지션만 표시
          } else {
            // 포지션이 없으면 이름 표시 (notable 포함)
            const shortName = playerData.name.length > 8 ? playerData.name.substring(0, 7) + '…' : playerData.name;
            displayText = notable + shortName;
          }
          
          html += `<button class="seat-player-btn btn ${btnClass} ${borderClass} px-1 py-0.5 text-[9px] rounded truncate h-7" 
                    data-seat="${seatNum}" 
                    data-player-name="${playerData.name}"
                    title="Seat ${seatNum}: ${playerData.name}">
                    <div class="truncate">${displayText}</div>
                  </button>`;
        } else {
          // 빈 좌석
          html += `<button class="seat-empty-btn btn bg-gray-800 ${borderClass} px-1 py-0.5 text-[9px] rounded h-7" 
                    data-seat="${seatNum}"
                    title="Seat ${seatNum}: 빈자리">
                    <div class="text-gray-600">${positionBadge || '•'}</div>
                  </button>`;
        }
      }
      
      // 11번째 위치: 버튼 드롭다운 (1x11 그리드) - 전체 플레이어 리스트에서 선택 가능
      const currentBtnPos = window.state.buttonPosition || '';
      
      // 전체 테이블 플레이어 리스트에서 좌석이 있는 플레이어들 가져오기
      const allPlayersWithSeats = tableData.filter(player => player.seat).map(player => ({
        seat: parseSeatNumber(player.seat),
        name: player.name
      })).sort((a, b) => a.seat - b.seat);
      
      html += `
        <select id="button-position-select" class="bg-gray-600 text-[9px] px-1 py-0.5 rounded h-7 cursor-pointer">
          <option value="">BTN</option>
          ${allPlayersWithSeats.map(player => {
            const selected = player.seat.toString() === currentBtnPos.toString() ? 'selected' : '';
            const isInGame = window.state.playersInHand.some(p => p.name === player.name);
            const statusIndicator = isInGame ? '🟢' : '⚫';
            return `<option value="${player.seat}" ${selected} title="${player.seat}번 - ${player.name} ${isInGame ? '(참여중)' : '(대기중)'}">${statusIndicator}${player.seat}</option>`;
          }).join('')}
        </select>
      `;
      
      seatButtons.innerHTML = html;
      
      // 버튼 위치 선택 이벤트 리스너 추가
      const btnSelect = document.getElementById('button-position-select');
      if(btnSelect) {
        // 기존 이벤트 리스너 제거 (중복 방지)
        const newBtnSelect = btnSelect.cloneNode(true);
        btnSelect.parentNode.replaceChild(newBtnSelect, btnSelect);
        
        newBtnSelect.addEventListener('change', (e) => {
          window.state.buttonPosition = e.target.value || null;
          console.log(`🎯 버튼 위치 변경: ${window.state.buttonPosition || '없음'}`);
          updateSeatDisplay();
          // updatePositionIndicators는 renderPlayerSelection 내부에서 이미 호출됨
          saveActionState();
          
          // 시각적 피드백
          showFeedback(window.state.buttonPosition ? 
            `버튼 위치: ${window.state.buttonPosition}번 좌석` : 
            '버튼 위치 해제', false);
        });
      }
    }
    function renderPlayerDetails(){
      const finalPot = calculateFinalPot();
      
      el.playerDetailsSection.innerHTML = window.state.playersInHand.map(p=>{
        const roleClass=(p.role==='winner')?'is-winner':'';
        const winnerBadge = p.role === 'winner' && finalPot > 0 ?
          `<span class="ml-2 text-amber-300 font-bold text-xs animate-pulse">🏆 +${formatNumber(finalPot)}</span>` : '';

        // 칩 표시 스타일 (마이너스일 때 빨간색)
        const chipValue = parseInt(unformatNumber(p.chips) || 0, 10);
        const chipClass = chipValue < 0 ? 'bg-red-900 text-red-300' : 'bg-gray-700';
        const chipWarning = chipValue < 0 ? '⚠️ ' : '';

        return `<div class="player-card flex items-center gap-2 text-sm border-b border-gray-700 pb-1 ${roleClass}" data-player-name="${p.name}">
          <div class="w-1/4 truncate font-bold">${p.name}${winnerBadge}</div>
          <div class="w-1/2"><button class="player-chip-btn btn ${chipClass} w-full p-1 rounded-md text-xs text-left" data-player-name="${p.name}">${chipWarning}${formatNumber(p.chips) || '0'}</button></div>
          <div class="w-1/4 card-placeholder h-10 flex justify-center items-center gap-1" data-player-name="${p.name}" data-count="2">
            ${p.hand?.length? p.hand.map(formatCardDisplay).join('') : '<span class="text-gray-400 text-lg">+</span>'}
          </div>
        </div>`;
      }).join('');
      
      // 플레이어 칩 버튼 이벤트 핸들러 추가
      document.querySelectorAll('.player-chip-btn').forEach(btn => {
        btn.onclick = () => {
          const playerName = btn.dataset.playerName;
          const player = window.state.playersInHand.find(p => p.name === playerName);
          if(player) {
            openChipInput(player, false);
          }
        };
      });
    }
    function renderBoard(){
      const flop=`<div class="card-placeholder h-10 w-24" data-target="board" data-index="0" data-count="3">${[0,1,2].map(i=>window.state.board[i]?formatCardDisplay(window.state.board[i]):'').join('') || '<span class="text-gray-400 text-lg">+</span>'}</div>`;
      const turn=`<div class="card-placeholder h-10 w-8" data-target="board" data-index="3" data-count="1">${window.state.board[3]?formatCardDisplay(window.state.board[3]):'<span class="text-gray-400 text-lg">+</span>'}</div>`;
      const river=`<div class="card-placeholder h-10 w-8" data-target="board" data-index="4" data-count="1">${window.state.board[4]?formatCardDisplay(window.state.board[4]):'<span class="text-gray-400 text-lg">+</span>'}</div>`;
      el.boardCardPlaceholders.innerHTML = flop+turn+river;
    }
    // 최종 팟 계산 함수
    function calculateFinalPot(){
      // 실제 팟 계산 사용 (폴드한 플레이어의 베팅 포함, 언콜 베팅 제외)
      return calculateActualPot();
    }
    
    function renderWinnerSelection(){
      const finalPot = calculateFinalPot();
      
      el.winnerButtons.innerHTML = window.state.playersInHand.map(p=>{
        const sel=(p.role==='winner');
        const potDisplay = sel && finalPot > 0 ? ` <span class="text-amber-300 font-bold">+${formatNumber(finalPot)}</span>` : '';
        return `<button class="btn ${sel?'btn-selected bg-amber-600':'bg-gray-600 hover:bg-gray-500'} px-2 py-1 text-xs rounded-md set-winner-btn" data-player-name="${p.name}">${p.name}${potDisplay}</button>`;
      }).join('');
    }
    function renderActionStreets(){
      const streets=['preflop','flop','turn','river']; 
      let displayPot=0;  // UI 표시용 팟
      
      el.streetLogsContainer.innerHTML = streets.map(street=>{
        const logs=window.state.actionState[street]||[]; 
        let streetPot=0;
        
        if(street==='preflop'){
          streetPot += parseInt(unformatNumber(window.state.actionState.smallBlind)||0,10);
          streetPot += parseInt(unformatNumber(window.state.actionState.bigBlind)||0,10);
          if(window.state.actionState.hasBBAnte) streetPot += parseInt(unformatNumber(window.state.actionState.bigBlind)||0,10);
        }
        
        // Pot Correction이 있는지 확인
        const potCorrection = logs.find(a => a.action === 'Pot Correction');
        if(potCorrection) {
          // Pot Correction이 있으면 그 값을 직접 사용
          displayPot = parseInt(unformatNumber(potCorrection.amount),10);
        } else {
          // 일반 액션들만 더함
          logs.forEach(a=>{ 
            if(a.amount && a.action !== 'Pot Correction') {
              streetPot += parseInt(unformatNumber(a.amount),10); 
            }
          });
          displayPot += streetPot;
        }
        
        // 실제 팟 계산 (폴드한 플레이어의 베팅 포함)
        const actualPot = calculateActualPot();
        const uncalledBet = calculateUncalledBet();
        
        // 실제 팟과 표시 팟이 다른 경우를 위한 표시
        let potDisplay = formatNumber(displayPot);
        if(displayPot !== actualPot && logs.length > 0) {
          potDisplay = `${formatNumber(displayPot)} <span class="text-xs text-amber-400">(실제: ${formatNumber(actualPot)})</span>`;
        }
        const logHTML = logs.map(log=>{
          // Pot Correction은 시스템 액션이므로 player가 없음
          if(log.action === 'Pot Correction'){
            const amt = log.amount ? ` <span class="font-mono text-white">${formatNumber(log.amount)}</span>` : '';
            return `<span class="action-log-entry mr-2"><span class="text-blue-400">Pot</span>${amt}</span>`;
          }
          // 일반 플레이어 액션
          const player=window.state.playersInHand.find(p=>p.name===log.player);
          const cls=(player?.role==='winner')?'text-amber-400':'text-gray-300';
          const amt=log.amount?` <span class="font-mono text-white">${formatNumber(log.amount)}</span>`:'';
          return `<span class="action-log-entry mr-2"><span class="${cls}">${log.player || 'Unknown'}</span> ${log.action}${amt}</span>`;
        }).join('');
        const isActive = window.state.currentStreet === street;
        const streetBtnClass = isActive 
          ? 'bg-amber-500 text-black border-2 border-amber-300 shadow-lg' 
          : 'bg-gray-700 text-gray-300 border-2 border-gray-600 hover:bg-gray-600 hover:text-white';
        const containerClass = isActive 
          ? 'bg-gradient-to-r from-amber-900/40 to-yellow-900/30 border-2 border-amber-400 shadow-xl ring-2 ring-amber-500/30' 
          : 'bg-gray-900/50 border border-gray-700';
        
        return `<div class="street-container ${containerClass} p-2 rounded-md">
          <div class="flex justify-between items-center text-xs mb-1">
            <button class="street-select-btn ${streetBtnClass} px-3 py-1 rounded-md font-bold min-w-[70px] text-center cursor-pointer" 
                    data-street="${street}" style="${isActive ? 'box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);' : ''}">${street.toUpperCase()}</button>
            <div class="flex items-center gap-1">
              <span class="font-mono">Pot: ${potDisplay}</span>
              <button class="pot-keypad-btn btn bg-gray-600 px-1 py-0 rounded" data-street="${street}" data-current-pot="${displayPot}">⌨️</button>
            </div>
            <div class="flex gap-1">
              <button class="add-action-btn btn bg-indigo-600 text-white font-bold py-1 px-2 rounded" data-street="${street}">액션+</button>
              <button class="undo-action-btn btn bg-gray-600 py-1 px-2 rounded" data-street="${street}">↩</button>
            </div>
          </div>
          <div id="${street}-log" class="action-log-display text-xs whitespace-nowrap overflow-x-auto">${logHTML || '<span class="text-gray-500">No actions</span>'}</div>
        </div>`;
      }).join('');
    }
    function renderAll(){ 
      renderPlayerSelection(); 
      renderPlayerDetails(); 
      renderBoard(); 
      renderActionStreets(); 
      renderWinnerSelection();
      updateButtonPositionDisplay();
    }
    // ====== MODALS ======
    function openModal(node, html){ node.innerHTML=html; node.classList.remove('hidden', 'opacity-0'); }
    function closeModal(node){ node.classList.add('hidden', 'opacity-0'); }

    // 보드 카드 입력 규칙 정의
    function getBoardCardRules(currentStreet) {
      switch(currentStreet) {
        case 'flop':
          return {
            selectable: [0, 1, 2, 3, 4],    // 플랍~리버 모두 선택 가능
            editable: [0, 1, 2, 3, 4],      // 플랍~리버 모두 수정 가능
            minCards: 3,                     // 최소 3장 (플랍)
            maxCards: 5,                     // 최대 5장 (플랍+턴+리버)
            title: '플랍 카드 선택 (3-5장)',
            guide: '💡 플랍(3장) + 턴/리버(선택사항) 입력 가능'
          };
        case 'turn':
          return {
            selectable: [3],                 // 턴만 선택 가능
            editable: [3],                   // 턴만 수정 가능
            minCards: 0,                     // 턴 카드 삭제 가능
            maxCards: 1,                     // 최대 1장
            title: '턴 카드 선택 (0-1장)',
            guide: '💡 턴 카드만 수정 가능 (플랍 카드는 잠금)'
          };
        case 'river':
          return {
            selectable: [4],                 // 리버만 선택 가능
            editable: [4],                   // 리버만 수정 가능
            minCards: 0,                     // 리버 카드 삭제 가능
            maxCards: 1,                     // 최대 1장
            title: '리버 카드 선택 (0-1장)',
            guide: '💡 리버 카드만 수정 가능 (플랍/턴 카드는 잠금)'
          };
        default:
          return {
            selectable: [0, 1, 2, 3, 4],
            editable: [0, 1, 2, 3, 4],
            minCards: 0,
            maxCards: 5,
            title: '카드 선택',
            guide: ''
          };
      }
    }

    // 카드 상태 분류 함수
    function getBoardCardStatus(cardId, currentStreet) {
      const rules = getBoardCardRules(currentStreet);
      const currentBoard = window.state.board;

      // 현재 편집 가능한 위치의 카드들만 selected로 처리
      let editableCards = [];
      rules.editable.forEach(index => {
        if (currentBoard[index]) {
          editableCards.push(currentBoard[index]);
        }
      });

      // 1. 현재 수정 가능한 카드
      if (editableCards.includes(cardId)) {
        return {
          status: 'editable',
          class: 'bg-amber-300 border-2 border-amber-500',
          disabled: false
        };
      }

      // 2. 이전 스트리트 카드 (보기만 가능)
      if (currentBoard.includes(cardId)) {
        return {
          status: 'locked',
          class: 'bg-gray-500 text-gray-300 border-2 border-gray-400 cursor-not-allowed',
          disabled: true,
          tooltip: '이전 스트리트에서만 수정 가능'
        };
      }

      // 3. 플레이어가 사용 중인 카드
      const usedByPlayers = window.state.playersInHand.some(p =>
        (p.hand || []).includes(cardId)
      );
      if (usedByPlayers) {
        return {
          status: 'used',
          class: 'bg-gray-600 text-gray-400 cursor-not-allowed',
          disabled: true,
          tooltip: '다른 플레이어가 사용 중'
        };
      }

      // 4. 선택 가능한 카드
      return {
        status: 'available',
        class: 'bg-white hover:bg-amber-200',
        disabled: false
      };
    }

    function openCardSelector(){
      const { target, player, index, count } = window.state.modalState.cardTarget;

      // 보드 카드 백업 (취소 시 복원용)
      window.state.boardBackup = [...window.state.board];

      if (target === 'playerHand' && player) {
        // 플레이어 핸드 선택 (기존 로직 유지)
        openPlayerHandSelector(player, count);
        return;
      }

      if (target !== 'board') {
        // 기타 카드 선택 (기존 로직 유지)
        openGenericCardSelector(target, count);
        return;
      }

      // === 보드 카드 선택 새 로직 ===
      let currentStreet = 'flop';
      if (index === 3) currentStreet = 'turn';
      else if (index === 4) currentStreet = 'river';
      else if (count === 3) currentStreet = 'flop';

      const rules = getBoardCardRules(currentStreet);

      // 백업 시스템 - 취소 시 복원용
      const backupState = {
        board: [...window.state.board],
        timestamp: new Date().toISOString()
      };
      console.log(`보드 카드 선택 시작 - ${currentStreet} 모드, 백업 생성:`, backupState);

      // 현재 편집 가능한 카드들을 selected로 설정
      let selected = [];
      rules.editable.forEach(boardIndex => {
        if (window.state.board[boardIndex]) {
          selected.push(window.state.board[boardIndex]);
        }
      });

      // 현재 보드 상태 표시
      const renderCurrentBoard = () => {
        return window.state.board.map((card, idx) => {
          if (!card) return `<div class="w-9 h-11 bg-gray-700 rounded border border-gray-600 text-xs flex items-center justify-center text-gray-500">${idx < 3 ? 'F' : idx === 3 ? 'T' : 'R'}</div>`;

          const isEditable = rules.editable.includes(idx);
          const borderClass = isEditable ? 'border-amber-500' : 'border-gray-400';
          const bgClass = isEditable ? 'bg-amber-100' : 'bg-gray-200';

          return `<div class="w-9 h-11 ${bgClass} rounded ${borderClass} border-2 text-xs flex items-center justify-center font-bold">${card}</div>`;
        }).join('');
      };

      // 카드 덱 HTML 생성
      let deckHTML = '';
      Object.keys(SUITS).forEach(suitKey => {
        deckHTML += '<div class="flex justify-center gap-1 mb-1">';
        RANKS.forEach(rank => {
          const id = `${rank}${suitKey}`;
          const cardStatus = getBoardCardStatus(id, currentStreet);
          const color = (suitKey === 'h' || suitKey === 'd') ? 'card-red' : 'card-black';

          const tooltip = cardStatus.tooltip ? `title="${cardStatus.tooltip}"` : '';
          deckHTML += `<button class="btn card-selector-btn rounded-md w-9 h-11 ${cardStatus.class} ${color}"
                       data-card-id="${id}"
                       data-status="${cardStatus.status}"
                       ${cardStatus.disabled ? 'disabled' : ''}
                       ${tooltip}>${rank}${SUITS[suitKey]}</button>`;
        });
        deckHTML += '</div>';
      });

      const html = `<div class="bg-gray-800 rounded-lg p-4 w-full max-w-md">
        <h2 class="text-lg font-bold text-amber-400 mb-2 text-center">${rules.title}</h2>

        <!-- 현재 보드 상태 표시 -->
        <div class="bg-gray-900 p-2 rounded mb-3">
          <div class="text-xs text-gray-400 mb-1">현재 보드:</div>
          <div class="flex gap-1 justify-center">
            ${renderCurrentBoard()}
          </div>
        </div>

        <!-- 편집 가능 영역 안내 -->
        <div class="text-xs text-blue-400 mb-2 text-center">
          ${rules.guide}
        </div>

        <div id="selected-cards" class="text-center mb-2 text-sm text-gray-300">
          선택된 카드: <span id="selected-count">${selected.length}</span>/${rules.maxCards}
        </div>

        <div id="card-deck">${deckHTML}</div>

        <div class="flex gap-2 mt-3">
          <button id="cancel-board" class="btn flex-1 bg-red-600 py-2 rounded-md">취소</button>
          <button id="confirm-board" class="btn flex-1 bg-green-600 py-2 rounded-md">확인</button>
        </div>
      </div>`;
      openModal(el.cardSelectorModal, html);

      // 카드 수 업데이트 함수
      const updateSelectedCount = () => {
        const counter = el.cardSelectorModal.querySelector('#selected-count');
        if(counter) counter.textContent = selected.length;
      };

      // 카드 클릭 이벤트 (새 로직)
      el.cardSelectorModal.querySelector('#card-deck').onclick = e => {
        const btn = e.target.closest('.card-selector-btn');
        if (!btn) return;

        const cardId = btn.dataset.cardId;
        const cardStatus = btn.dataset.status;

        // 비활성화된 카드 클릭 시 피드백
        if (btn.disabled || cardStatus === 'locked' || cardStatus === 'used') {
          const tooltip = btn.getAttribute('title');
          if (tooltip) {
            showFeedback(tooltip, true);
          }
          return;
        }

        const idx = selected.indexOf(cardId);

        if (idx > -1) {
          // 이미 선택된 카드 → 선택 해제
          selected.splice(idx, 1);
          btn.classList.remove('bg-amber-300', 'border-2', 'border-amber-500');
          btn.classList.add('bg-white', 'hover:bg-amber-200');
          btn.dataset.status = 'available';
        } else {
          // 새 카드 선택
          if (selected.length < rules.maxCards) {
            selected.push(cardId);
            btn.classList.remove('bg-white', 'hover:bg-amber-200');
            btn.classList.add('bg-amber-300', 'border-2', 'border-amber-500');
            btn.dataset.status = 'editable';
          } else {
            showFeedback(`${rules.title}에서는 최대 ${rules.maxCards}장까지 선택 가능합니다.`, true);
          }
        }

        updateSelectedCount();
      };

      // 확인 버튼 이벤트 (새 로직)
      el.cardSelectorModal.querySelector('#confirm-board').onclick = () => {
        // 카드 수 범위 검증
        if (selected.length < rules.minCards) {
          showFeedback(`${currentStreet}는 최소 ${rules.minCards}장을 선택해야 합니다.`, true);
          return;
        }
        if (selected.length > rules.maxCards) {
          showFeedback(`${currentStreet}는 최대 ${rules.maxCards}장까지 선택 가능합니다.`, true);
          return;
        }

        // 중복 카드 검증
        const uniqueCards = [...new Set(selected)];
        if (uniqueCards.length !== selected.length) {
          showFeedback('중복된 카드가 선택되었습니다. 다시 선택해주세요.', true);
          return;
        }

        // 다른 위치의 카드와 중복 검증
        const allUsedCards = [
          ...Object.values(window.state.player1 || {}),
          ...Object.values(window.state.player2 || {}),
          ...Object.values(window.state.player3 || {}),
          ...Object.values(window.state.player4 || {}),
          ...window.state.board.filter((card, idx) => card && !rules.editable.includes(idx))
        ].filter(Boolean);

        const duplicateCards = selected.filter(card => allUsedCards.includes(card));
        if (duplicateCards.length > 0) {
          showFeedback(`이미 사용중인 카드입니다: ${duplicateCards.join(', ')}`, true);
          return;
        }

        // 편집 가능 범위의 기존 카드 지우기
        rules.editable.forEach(boardIndex => {
          window.state.board[boardIndex] = null;
        });

        // 선택된 카드들을 순서대로 배치
        let boardIndex = rules.editable[0];
        selected.forEach(cardId => {
          if (boardIndex <= rules.editable[rules.editable.length - 1]) {
            window.state.board[boardIndex] = cardId;
            boardIndex++;
          }
        });

        // 백업 삭제
        delete window.state.boardBackup;

        closeModal(el.cardSelectorModal);
        renderAll();
        saveActionState();
        showFeedback(`${rules.title.split(' ')[0]} 카드가 설정되었습니다.`);
      };

      // 취소 버튼 이벤트 (새 로직) - 백업 상태 복원
      el.cardSelectorModal.querySelector('#cancel-board').onclick = () => {
        console.log('보드 카드 선택 취소 - 백업 상태 복원');

        // 백업 상태로 복원
        window.state.board = [...backupState.board];

        // 화면 업데이트
        renderBoard();

        console.log('복원 완료:', window.state.board);
        closeModal(el.cardSelectorModal);
      };
    }

    // 플레이어 핸드 선택 함수 (기존 로직 유지)
    function openPlayerHandSelector(player, count) {
      let selected = [];
      const p = window.state.playersInHand.find(p => p.name === player);
      if (p && p.hand) selected = [...p.hand];

      const usedCards = [...window.state.playersInHand.flatMap(p => {
        if (p.name === player) return []; // 현재 플레이어 제외
        return p.hand || [];
      }), ...window.state.board.filter(Boolean)];

      let deckHTML = '';
      Object.keys(SUITS).forEach(suitKey => {
        deckHTML += '<div class="flex justify-center gap-1 mb-1">';
        RANKS.forEach(rank => {
          const id = `${rank}${suitKey}`;
          const usedByOthers = usedCards.includes(id) && !selected.includes(id);
          const isSelected = selected.includes(id);
          const color = (suitKey === 'h' || suitKey === 'd') ? 'card-red' : 'card-black';
          const bgClass = isSelected ? 'bg-amber-300' : (usedByOthers ? 'bg-gray-600 text-gray-500' : 'bg-white hover:bg-amber-300');

          deckHTML += `<button class="btn card-selector-btn rounded-md w-9 h-11 ${bgClass} ${color}" data-card-id="${id}" ${usedByOthers ? 'disabled' : ''}>${rank}${SUITS[suitKey]}</button>`;
        });
        deckHTML += '</div>';
      });

      const html = `<div class="bg-gray-800 rounded-lg p-2 w-full max-w-md">
        <h2 class="text-lg font-bold text-amber-400 mb-2 text-center">${player} 핸드 (${count}장)</h2>
        <div id="selected-cards" class="text-center mb-2 text-sm text-gray-300">선택된 카드: <span id="selected-count">${selected.length}</span>/${count}</div>
        <div id="card-deck">${deckHTML}</div>
        <div class="flex gap-2 mt-2">
          <button id="close-card-modal" class="btn flex-1 bg-red-600 py-2 rounded-md">닫기</button>
          <button id="confirm-cards" class="btn flex-1 bg-green-600 py-2 rounded-md">확인</button>
        </div>
      </div>`;

      openModal(el.cardSelectorModal, html);

      const updateSelectedCount = () => {
        const counter = el.cardSelectorModal.querySelector('#selected-count');
        if (counter) counter.textContent = selected.length;
      };

      el.cardSelectorModal.querySelector('#card-deck').onclick = e => {
        const btn = e.target.closest('.card-selector-btn');
        if (!btn) return;
        const id = btn.dataset.cardId;
        const idx = selected.indexOf(id);

        if (idx > -1) {
          selected.splice(idx, 1);
          btn.classList.remove('bg-amber-300');
          btn.classList.add('bg-white', 'hover:bg-amber-300');
        } else if (selected.length < count) {
          selected.push(id);
          btn.classList.remove('bg-white', 'hover:bg-amber-300');
          btn.classList.add('bg-amber-300');
        }
        updateSelectedCount();
      };

      el.cardSelectorModal.querySelector('#confirm-cards').onclick = () => {
        assignCard(selected.length > 0 ? selected : null);
      };

      el.cardSelectorModal.querySelector('#close-card-modal').onclick = () => {
        closeModal(el.cardSelectorModal);
      };
    }

    // 기타 카드 선택 함수 (기존 로직 유지)
    function openGenericCardSelector(target, count) {
      const html = `<div class="bg-gray-800 rounded-lg p-2 w-full max-w-md">
        <h2 class="text-lg font-bold text-amber-400 mb-2 text-center">카드 선택 (${count}장)</h2>
        <p class="text-center text-gray-400">구현 필요: ${target}</p>
        <div class="flex gap-2 mt-2">
          <button id="close-card-modal" class="btn flex-1 bg-red-600 py-2 rounded-md">닫기</button>
        </div>
      </div>`;

      openModal(el.cardSelectorModal, html);

      el.cardSelectorModal.querySelector('#close-card-modal').onclick = () => {
        closeModal(el.cardSelectorModal);
      };
    }

    // 새로운 스트릿 기반 액션 시스템
    function openActionPad(street){
      if(window.state.playersInHand.length<1){ showFeedback('먼저 플레이어를 선택해주세요.', true); return; }

      // 액션 관리자 동기화
      if (window.actionOrderManager) {
        window.actionOrderManager.currentStreet = street;
      }
      window.state.currentStreet = street;
      window.state.modalState.actionPadStreet = street;

      // ActionOrderManagerV2 사용
      const actionOrder = window.actionOrderManager ?
        window.actionOrderManager.getActionOrder(street) : [];

      const activePlayers = actionOrder.filter(p => p.canAct);

      if(activePlayers.length === 0) {
        // ActionOrderManager가 초기화되지 않은 경우 자동 초기화 시도
        if (!window.actionOrderManager?.handNumber && window.state.playersInHand.length > 0) {
          console.warn('ActionOrderManager가 초기화되지 않음 - 자동 초기화 시도');

          const handNumber = window.state.actionState.handNumber || '1';
          const buttonPosition = parseSeatNumber(window.state.playersInHand[0]?.seat) || 1;

          window.actionOrderManager.initializeHand(
            window.state.playersInHand,
            buttonPosition,
            String(handNumber)
          );

          console.log('✅ openActionPad에서 자동 초기화 완료');

          // 재시도
          const retryActionOrder = window.actionOrderManager.getActionOrder(street);
          const retryActivePlayers = retryActionOrder.filter(p => p.canAct);

          if (retryActivePlayers.length > 0) {
            // 성공적으로 초기화됨 - 계속 진행
            console.log('재시도 성공:', retryActivePlayers);
            // actionOrder와 activePlayers 업데이트
            actionOrder.length = 0;
            actionOrder.push(...retryActionOrder);
            activePlayers.length = 0;
            activePlayers.push(...retryActivePlayers);
          }
        }

        // 여전히 활성 플레이어가 없는 경우
        if (activePlayers.length === 0) {
          console.error('베팅 가능한 플레이어 없음:', {
            handNumber: window.actionOrderManager?.handNumber,
            playersCount: window.state.playersInHand.length,
            buttonPosition: window.actionOrderManager?.buttonPosition
          });

          showFeedback('베팅 가능한 플레이어가 없습니다. 플레이어를 먼저 선택해주세요.', true);
          return;
        }
      }

      // 현재 액션할 플레이어
      const currentPlayer = window.actionOrderManager ?
        window.actionOrderManager.getCurrentPlayer(street) : null;

      // 액션 모드 토글 버튼
      const actionMode = window.actionOrderManager?.actionMode || 'auto';
      const modeIcon = actionMode === 'auto' ? '🤖' : '👆';
      const modeText = actionMode === 'auto' ? '자동 순서' : '수동 선택';

      // 액션 큐 표시
      const queueDisplay = actionOrder.map((p, index) => {
        const playerName = p.name || p.player; // ActionOrder 객체는 player 속성 사용
        const currentPlayerName = currentPlayer ? (currentPlayer.name || currentPlayer.player) : null;

        const isCurrent = currentPlayer && playerName === currentPlayerName;
        const hasActed = (window.state.actionState[street] || []).some(a => a.player === playerName);

        let statusIcon = '⏳';
        let statusClass = 'text-gray-400';

        if (hasActed) {
          statusIcon = '✅';
          statusClass = 'text-green-400';
        } else if (isCurrent) {
          statusIcon = '🎯';
          statusClass = 'text-amber-400 animate-pulse';
        }

        return `<span class="${statusClass}">${statusIcon} ${playerName}</span>`;
      }).join(' → ');

      // Check/Call 액션 결정 (현재 플레이어용)
      let checkCallButtonHTML = '';
      if(currentPlayer) {
        console.log('🎯 currentPlayer 객체 확인:', currentPlayer);
        console.log('🎯 currentPlayer.name:', currentPlayer.name);
        console.log('🎯 currentPlayer.player:', currentPlayer.player);

        const playerName = currentPlayer.name || currentPlayer.player;
        if (!playerName) {
          console.error('❌ 플레이어 이름을 찾을 수 없음:', currentPlayer);
          return;
        }

        const smartAction = getSmartCheckCallAction(playerName, street);
        const btnColor = smartAction.action === 'Checks' ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700';
        const btnIcon = smartAction.action === 'Checks' ? '✅' : '📞';
        const btnText = smartAction.action === 'Checks' ? 'Check' : `Call ${formatNumber(smartAction.amount)}`;

        checkCallButtonHTML = `
          <button id="smart-check-call-btn" class="btn ${btnColor} p-3 rounded-md" data-action="SmartCheckCall" data-player="${playerName}">
            ${btnIcon} ${btnText}
          </button>`;
      }

      const html=`<div class="bg-gray-800 rounded-lg p-4 w-full max-w-lg">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold text-amber-400">${street.toUpperCase()} 액션</h2>
          <button id="toggle-action-mode" class="text-sm bg-gray-700 px-3 py-1 rounded">
            ${modeIcon} ${modeText}
          </button>
        </div>

        <!-- 액션 큐 표시 -->
        <div class="bg-gray-900 p-3 rounded mb-4">
          <div class="text-xs text-gray-400 mb-1">액션 순서:</div>
          <div class="text-sm">${queueDisplay}</div>
          ${currentPlayer ? `<div class="text-xs text-amber-400 mt-2">현재 차례: ${currentPlayer.name || currentPlayer.player}</div>` : ''}
        </div>

        <!-- 현재 플레이어 액션 버튼 -->
        ${currentPlayer && actionMode === 'auto' ? `
          <div class="mb-4">
            <div class="text-center text-lg font-bold text-amber-400 mb-3">${currentPlayer.name || currentPlayer.player}의 액션</div>
            <div id="current-player-actions" class="grid grid-cols-2 gap-2">
              <button class="btn bg-red-600 hover:bg-red-700 p-3 rounded-md" data-action="Folds" data-player="${currentPlayer.name || currentPlayer.player}">
                ❌ Fold
              </button>
              ${checkCallButtonHTML}
              <button class="btn bg-blue-600 hover:bg-blue-700 p-3 rounded-md" data-action="Bet/Raises" data-player="${currentPlayer.name || currentPlayer.player}">
                💰 Bet/Raise
              </button>
              <button class="btn bg-red-800 hover:bg-red-900 font-bold p-3 rounded-md" data-action="All In" data-player="${currentPlayer.name || currentPlayer.player}">
                🚀 ALL IN
              </button>
            </div>
          </div>
        ` : ''}

        <!-- 수동 모드 또는 모든 플레이어 선택 -->
        ${actionMode === 'manual' || !currentPlayer ? `
          <div class="mb-4">
            <div class="text-sm text-gray-400 mb-2">플레이어 선택:</div>
            <div id="action-pad-players" class="grid grid-cols-3 gap-2 mb-3">
              ${activePlayers.map(p => {
                const hasActed = (window.state.actionState[street] || []).some(a => a.player === p.name);
                const btnClass = hasActed ? 'bg-gray-600' : 'bg-gray-700 hover:bg-gray-600';
                const indicator = hasActed ? ' ✅' : '';
                return `<button class="btn ${btnClass} p-2 rounded-md" data-player-name="${p.name}">${p.name}${indicator}</button>`;
              }).join('')}
            </div>
            <div id="action-pad-actions" class="grid grid-cols-2 gap-2 hidden">
              <button class="btn bg-red-600 p-3 rounded-md" data-action="Folds">❌ Fold</button>
              <button id="manual-smart-check-call-btn" class="btn bg-green-600 p-3 rounded-md" data-action="SmartCheckCall">
                <span class="action-label">✅ Check</span>
                <span class="amount-label"></span>
              </button>
              <button class="btn bg-blue-600 p-3 rounded-md" data-action="Bet/Raises">💰 Bet/Raise</button>
              <button class="btn bg-red-800 font-bold p-3 rounded-md" data-action="All In">🚀 ALL IN</button>
            </div>
          </div>
        ` : ''}

        <!-- 컨트롤 버튼 -->
        <div class="flex gap-2">
          ${actionMode === 'auto' && currentPlayer ? `
            <button id="skip-current-player" class="btn bg-yellow-600 hover:bg-yellow-700 px-3 py-2 rounded text-sm">
              ⏭️ 스킵
            </button>
          ` : ''}
          <button id="close-action-pad" class="btn flex-1 bg-gray-600 hover:bg-gray-700 py-2 rounded-md">닫기</button>
        </div>
      </div>`;

      openModal(el.actionPadModal, html);
    }

    // 플레이어 액션 실행 함수 (보안 레이어 포함)
    async function executePlayerAction(playerName, action, btn) {
      const modal = el.actionPadModal;
      const manager = window.actionOrderManager;

      try {
        // 현재 플레이어 확인 (자동 모드)
        if (manager?.actionMode === 'auto') {
          const currentPlayer = manager.getCurrentPlayer();
          if (currentPlayer && (currentPlayer.name || currentPlayer.player) !== playerName) {
            console.log(`순서 밖 액션: ${playerName} (현재: ${currentPlayer.name || currentPlayer.player})`);
            // 그래도 허용
          }
        }

        // 현재 플레이어를 actionPadPlayer로 설정
        window.state.modalState.actionPadPlayer = playerName;

          // 액션 처리
          if(action === 'SmartCheckCall') {
            const smartAction = getSmartCheckCallAction(playerName, manager.currentStreet);
            addActionToLog(smartAction.label, smartAction.amount, playerName);
          } else if(action === 'Folds') {
            addActionToLog('Folds', null, playerName);
            // 플레이어 상태 업데이트
            window.state.playerStatus[playerName] = 'folded';
          } else if(action === 'All In') {
            const player = window.state.playersInHand.find(p => p.name === playerName);
            if(player) {
              addActionToLog('All In', player.chips, playerName);
              window.state.playerStatus[playerName] = 'allin';
            }
          } else if(action === 'Bet/Raises') {
            closeModal(modal);
            window.state.modalState.actionPadPlayer = playerName;

            const st = manager.currentStreet;
            const hasBet = window.state.actionState[st]?.some(a => /BET|RAISE/i.test(a.action || ''));
            window.state.modalState.actionPadCurrentAction = hasBet ? 'Raises' : 'Bets';

            openKeypad(null, { purpose: 'bet', playerName: playerName });
            return;
          }

          // 자동 모드에서 다음 플레이어로 이동
          if(manager?.actionMode === 'auto') {
            const nextPlayer = manager.moveToNextPlayer();

            showFeedback(`✅ ${playerName} ${action}`, false);

            if(nextPlayer) {
              // 잠시 대기 후 다음 플레이어 액션 팝업
              setTimeout(() => {
                openActionPad(manager.currentStreet);
              }, 300);
            } else {
              closeModal(modal);
              showFeedback(`🎯 ${manager.currentStreet?.toUpperCase() || 'STREET'} 완료!`, false);
            }
          } else {
            closeModal(modal);
            showFeedback(`✅ ${playerName} ${action}`, false);
          }

      } catch (error) {
        // 에러 로그만 출력하고 계속 진행
        console.log('액션 처리 중 예외:', error.message);
        showFeedback('⚠️ 액션 처리 중 오류가 발생했습니다', true);
      }
    }

    // 칩 입력 개선 함수
    function openChipInput(player, isInitial = false) {
      const currentChips = player.chips || '0';
      const placeholder = isInitial ? '시작 칩 입력' : `현재: ${formatNumber(currentChips)}`;
      
      // 키패드 옵션 설정
      window.state.modalState.keypadOptions = {
        purpose: 'chip',
        playerName: player.name
      };
      
      // 팝업 모달 생성
      const html = `<div class="bg-gray-800 rounded-lg p-4 w-full max-w-xs">
        <h3 class="text-center text-amber-400 font-bold mb-3">${player.name} 칩 수정</h3>
        <div class="text-xs text-gray-400 text-center mb-2">현재: ${formatNumber(currentChips)}</div>
        <input type="text" id="chip-text-input" class="w-full bg-gray-900 text-white p-2 rounded mb-3 text-center" placeholder="0" value="0">
        <div id="keypad-display" class="bg-gray-900 text-right text-2xl font-mono p-2 rounded mb-2 h-12">0</div>
        <div class="grid grid-cols-3 gap-2 text-xl font-bold">
          ${['7','8','9','4','5','6','1','2','3','0','00','000'].map(k=>`<button class="keypad-btn btn bg-gray-700 p-3 rounded-md">${k}</button>`).join('')}
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2">
          <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">C</button>
          <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">←</button>
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2">
          <button id="keypad-cancel" class="btn bg-red-600 p-3 rounded-md">취소</button>
          <button id="keypad-confirm" class="btn bg-green-600 p-3 rounded-md">확인</button>
        </div>
      </div>`;
      
      openModal(el.keypadModal, html);
      
      // 텍스트 입력과 키패드 디스플레이 동기화
      setTimeout(() => {
        const textInput = document.getElementById('chip-text-input');
        const display = document.getElementById('keypad-display');
        let currentInput = '0';
        
        if(textInput && display) {
          // 텍스트 입력 이벤트
          textInput.addEventListener('input', () => {
            currentInput = unformatNumber(textInput.value) || '0';
            display.textContent = formatNumber(currentInput);
          });
          
          // 키패드 버튼 이벤트는 전역 키패드 모달 이벤트에서 처리
          // (중복 이벤트 리스너 제거)
          
          // 취소/확인 버튼은 전역 키패드 모달 이벤트에서 처리
          // (중복 이벤트 리스너 제거)
          
          // 확인 버튼은 전역 키패드 모달 이벤트에서 처리
          // (중복 이벤트 리스너 제거)
        }
      }, 10);
    }
    
    function openKeypad(targetInput, options={}){
      window.state.modalState.keypadTarget=targetInput;
      window.state.modalState.keypadOptions=options;
      const initial = options.prefill !== undefined ? options.prefill : (targetInput?targetInput.value:'');

      // 베팅 키패드인 경우 플레이어 칩 확인
      let playerChips = 0;
      let chipWarning = '';
      if(options.purpose === 'bet' && options.playerName) {
        const player = window.state.playersInHand.find(p => p.name === options.playerName);
        if(player) {
          playerChips = parseInt(unformatNumber(player.chips), 10);
          chipWarning = `<div class="text-xs text-gray-400 text-center mb-1">보유 칩: ${formatNumber(playerChips)}</div>`;
        }
      } else if(options.purpose === 'bet' && window.state.modalState.actionPadPlayer) {
        const player = window.state.playersInHand.find(p => p.name === window.state.modalState.actionPadPlayer);
        if(player) {
          playerChips = parseInt(unformatNumber(player.chips), 10);
          chipWarning = `<div class="text-xs text-gray-400 text-center mb-1">보유 칩: ${formatNumber(playerChips)}</div>`;
        }
      }

      const html=`<div class="bg-gray-800 rounded-lg p-2 w-full max-w-xs">
        ${chipWarning}
        <div id="keypad-display" class="bg-gray-900 text-right text-2xl font-mono p-2 rounded mb-2 h-12">${initial}</div>
        <div id="keypad-warning" class="text-xs text-amber-400 text-center mb-2 hidden">⚠️ 칩 부족 - 올인으로 처리됩니다</div>
        <div class="grid grid-cols-3 gap-2 text-xl font-bold">
          ${['7','8','9','4','5','6','1','2','3','0','00','000'].map(k=>`<button class="keypad-btn btn bg-gray-700 p-3 rounded-md">${k}</button>`).join('')}
        </div>
        <div class="grid grid-cols-${options.purpose === 'bet' ? '3' : '2'} gap-2 mt-2">
          <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">C</button>
          <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">←</button>
          ${options.purpose === 'bet' && playerChips > 0 ?
            `<button class="keypad-btn btn bg-purple-600 text-white p-3 rounded-md font-bold" data-action="max">MAX</button>` : ''
          }
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2">
          <button id="keypad-cancel" class="btn bg-red-600 p-3 rounded-md">취소</button>
          <button id="keypad-confirm" class="btn bg-green-600 p-3 rounded-md">확인</button>
        </div>
      </div>`;
      openModal(el.keypadModal, html);

      // 실시간 칩 체크 기능 추가
      if(options.purpose === 'bet' && playerChips > 0) {
        const display = el.keypadModal.querySelector('#keypad-display');
        const warning = el.keypadModal.querySelector('#keypad-warning');

        // 디스플레이 값 변경 감지
        const observer = new MutationObserver(() => {
          const value = parseInt(unformatNumber(display.textContent) || 0, 10);
          if(value > playerChips) {
            warning.classList.remove('hidden');
            warning.textContent = `⚠️ 칩 부족! 최대 베팅 가능: ${formatNumber(playerChips)}`;
            warning.className = 'text-xs text-red-400 text-center mb-2';
          } else if(value === playerChips && value > 0) {
            warning.classList.remove('hidden');
            warning.textContent = `💰 최대 베팅 - 보유 칩 전체`;
            warning.className = 'text-xs text-blue-400 text-center mb-2';
          } else {
            warning.classList.add('hidden');
          }
        });

        observer.observe(display, { childList: true, characterData: true, subtree: true });
      }
    }

    // ====== SELECTORS & INPUTS ======
    function togglePlayerInHand(name){
      const i=window.state.playersInHand.findIndex(p=>p.name===name);
      if(i>-1) {
        // 플레이어 제거 (게임에서 제외)
        const player = window.state.playersInHand[i];
        window.state.playersInHand.splice(i,1);
        // seatMap에서도 제거
        if(player.seat) {
          delete window.state.seatMap[player.seat];
        }
        console.log(`➖ ${name} 게임에서 제외 (Seat ${player.seat})`);

        // 플레이어 제거 후 ActionOrderManager 재초기화
        if (window.actionOrderManager && window.state.playersInHand.length > 0) {
          const handNumber = window.state.actionState.handNumber || '1';
          const buttonPosition = parseSeatNumber(window.state.playersInHand[0]?.seat) || 1;

          console.log('플레이어 제거 시 ActionOrderManager 초기화:', {
            playersCount: window.state.playersInHand.length,
            buttonPosition,
            handNumber,
            removedPlayer: name
          });

          window.actionOrderManager.initializeHand(
            window.state.playersInHand,
            buttonPosition,
            String(handNumber)
          );

          console.log('✅ 플레이어 제거 후 ActionOrderManager 초기화 완료');
        } else if (window.state.playersInHand.length === 0) {
          // 모든 플레이어가 제거된 경우 ActionOrderManager 종료
          if (window.actionOrderManager) {
            window.actionOrderManager.endHand();
            console.log('✅ 모든 플레이어 제거 - ActionOrderManager 종료');
          }
        }
      } else {
        // 플레이어 추가 (게임에 참여)
        const pool=window.state.playerDataByTable[window.state.selectedTable]||[];
        const pd=pool.find(p=>p.name===name);
        if(!pd) return;
        
        const chips=pd.chips||'';
        const notable=pd.notable||false;
        const seat=pd.seat||''; // Type 시트의 seat 정보
        
        // seatMap에 추가
        if(seat) {
          window.state.seatMap[seat] = name;
        }
        
        // 새 플레이어 추가 시 initialChips를 현재 칩으로 설정
        console.log(`➕ ${name} 게임 참여: 시작칩 = ${chips}, 좌석 = ${seat}`);
        window.state.playersInHand.push({
          name,
          hand:[],
          chips,
          initialChips:chips,  // 시작칩은 현재 칩 값으로 설정
          role:null,
          notable:notable,  // Notable 정보 추가
          seat:seat,  // Seat 정보 유지
          chipsSetAt: new Date().toISOString()  // 칩 설정 시간 기록
        });

        // 플레이어가 추가될 때마다 ActionOrderManager 재초기화
        if (window.actionOrderManager && window.state.playersInHand.length > 0) {
          const handNumber = window.state.actionState.handNumber || '1';
          const buttonPosition = parseInt(seat) || 1;

          console.log('플레이어 추가 시 ActionOrderManager 초기화:', {
            playersCount: window.state.playersInHand.length,
            buttonPosition,
            handNumber,
            newPlayer: name
          });

          window.actionOrderManager.initializeHand(
            window.state.playersInHand,
            buttonPosition,
            String(handNumber)
          );

          console.log('✅ 플레이어 추가 후 ActionOrderManager 초기화 완료');
        }
      }
      renderPlayerSelection(); 
      renderPlayerDetails(); 
      renderWinnerSelection();
    }
    function setPlayerRole(name){
      const finalPot = calculateFinalPot();
      
      // 기존 승자 찾기
      const prevWinner = window.state.playersInHand.find(p => p.role === 'winner');
      
      // 기존 승자가 있으면 팟 금액 차감
      if(prevWinner && prevWinner.name !== name) {
        const prevChips = parseInt(unformatNumber(prevWinner.chips) || 0, 10);
        prevWinner.chips = (prevChips - finalPot).toString();
        prevWinner.role = null;
      }
      
      // 새 승자 설정
      const p = window.state.playersInHand.find(pp => pp.name === name);
      if(!p) return;
      
      if(p.role === 'winner') {
        // 승자 해제
        const currentChips = parseInt(unformatNumber(p.chips) || 0, 10);
        p.chips = (currentChips - finalPot).toString();
        p.role = null;
      } else {
        // 승자 설정
        const currentChips = parseInt(unformatNumber(p.chips) || 0, 10);
        p.chips = (currentChips + finalPot).toString();
        p.role = 'winner';
        
        // 다른 모든 플레이어의 role 해제
        window.state.playersInHand.forEach(player => {
          if(player.name !== name) player.role = null;
        });
      }
      
      // 칩 변경 타임스탬프 기록
      p.chipsUpdatedAt = new Date().toISOString();
      
      renderPlayerDetails(); 
      renderWinnerSelection();
      renderActionStreets(); // 액션 로그에도 승자 하이라이트 업데이트
    }
    function assignCard(cards){
      const {target,player,index,count} = window.state.modalState.cardTarget;
      if(target==='board'){
        if(!cards || cards.length === 0) {
          // 카드 제거
          if(count === 3) { // flop
            window.state.board[0] = null;
            window.state.board[1] = null;
            window.state.board[2] = null;
            window.state.board[3] = null; // 턴도 제거
            window.state.board[4] = null; // 리버도 제거
          } else if(index === 3) { // turn
            window.state.board[3] = null;
          } else if(index === 4) { // river
            window.state.board[4] = null;
          }
        } else {
          // 보드 배열이 충분한 크기인지 확인
          while(window.state.board.length <= 4) {
            window.state.board.push(null);
          }
          
          // 카드 할당
          if(count === 3) { // flop에서 선택
            // 플랍 3장
            window.state.board[0] = cards[0] || null;
            window.state.board[1] = cards[1] || null;
            window.state.board[2] = cards[2] || null;
            
            // 4장 이상 선택했으면 턴에 할당
            if(cards.length >= 4) {
              window.state.board[3] = cards[3];
            }
            
            // 5장 선택했으면 리버에도 할당
            if(cards.length >= 5) {
              window.state.board[4] = cards[4];
            }
          } else {
            // turn(index=3) 또는 river(index=4): 해당 인덱스만 업데이트
            window.state.board[index] = cards[0] || null;
          }
        }
        renderBoard();
      }
      else{
        const p=window.state.playersInHand.find(pp=>pp.name===player);
        if(p){ 
          p.hand = cards || []; // null이면 빈 배열로
          renderPlayerDetails();
        }
      }
      closeModal(el.cardSelectorModal);
    }
    function addActionToLog(action, amount=null, player=null){
      const { actionPadStreet, actionPadPlayer } = window.state.modalState;
      const playerName = player || actionPadPlayer;

      // 플레이어 상태 업데이트 (null 체크 추가)
      if (!action) {
        console.warn('addActionToLog: action이 null 또는 undefined입니다');
        return;
      }

      // 로컬 상태 업데이트
      if (action === 'Folds') {
        window.state.playerStatus[playerName] = 'folded';
      } else if (action === 'All In') {
        window.state.playerStatus[playerName] = 'allin';
      } else if (action.includes('Call')) {
        window.state.playerStatus[playerName] = 'called';
      } else if (action.includes('Bet') || action.includes('Raise')) {
        window.state.playerStatus[playerName] = 'bet';
      }

      // ActionOrderManagerV2와 동기화
      if (window.actionOrderManager) {
        if (action === 'Folds') {
          window.actionOrderManager.updatePlayerStatus(playerName, 'folded');
        } else if (action === 'All In') {
          window.actionOrderManager.updatePlayerStatus(playerName, 'allin');
        }

        // 다음 플레이어로 이동
        const nextPlayer = window.actionOrderManager.moveToNextPlayer(actionPadStreet);
        if (nextPlayer && window.actionOrderManager.actionMode === 'auto') {
          // 자동 모드인 경우 다음 플레이어 액션 패드 열기 준비
          window.state.nextPlayerToAct = nextPlayer;
        }
      }
      
      if (amount){
        const p = window.state.playersInHand.find(pp => pp.name === actionPadPlayer);
        if (p){
          const cur = parseInt(unformatNumber(p.chips) || 0, 10);
          const amountToDeduct = parseInt(unformatNumber(amount), 10);

          // 칩 초과 경고 (차단하지 않음)
          // 음수 칩도 허용하여 유연하게 처리
          if(amountToDeduct > cur && action !== 'All In') {
            console.log(`[v3.3.3] 칩 초과 경고: ${playerName} - 요청: ${amountToDeduct}, 보유: ${cur}`);

            // 경고만 표시하고 진행은 허용
            showFeedback(`⚠️ 주의: 칩이 부족합니다 (보유: ${formatNumber(cur)}, 베팅: ${formatNumber(amountToDeduct)})`, true);
            showFeedback(`💰 칩이 마이너스가 됩니다: ${formatNumber(cur - amountToDeduct)}`, false);
          }

          // 칩 차감 처리 (마이너스 허용)
          if(action === 'All In') {
            p.chips = '0';
          } else {
            // 칩 차감 - 마이너스도 허용
            const newChips = cur - amountToDeduct;
            p.chips = newChips.toString();

            // 마이너스 칩인 경우 시각적 표시를 위한 플래그
            if(newChips < 0) {
              p.hasNegativeChips = true;
              console.log(`[v3.3.3] 마이너스 칩 발생: ${playerName} = ${newChips}`);
            } else {
              p.hasNegativeChips = false;
            }
          }
          p.chipsUpdatedAt = new Date().toISOString();
        }
      }
      window.state.actionState[actionPadStreet].push({
        player: actionPadPlayer,
        action,
        amount,
        timestamp: new Date().toISOString()
      });
      saveActionState();
      renderAll();
      closeModal(el.actionPadModal);
      
      // 스트리트 완료 체크
      checkStreetComplete(actionPadStreet);
    }

    function undoLastAction(street){
      const last=window.state.actionState[street].pop();
      if(last) {
        // 플레이어 상태 복원
        if(last.action === 'Folds' || last.action === 'All In') {
          delete window.state.playerStatus[last.player];
        }
        
        // 칩 복원
        if(last.amount){
          const p=window.state.playersInHand.find(pp=>pp.name===last.player);
          if(p){ 
            const cur=parseInt(unformatNumber(p.chips)||0,10); 
            p.chips=(cur+parseInt(unformatNumber(last.amount),10)).toString(); 
          }
        }
      }
      saveActionState(); renderAll();
    }

    // ====== SEAT ARRANGEMENT & ACTION ORDER ======
    function initializeSeatGrid() {
      const buttonSelect = document.getElementById('button-position-select');
      
      // 버튼 위치 옵션 생성 (10개)
      if(buttonSelect) {
        buttonSelect.innerHTML = '<option value="">선택</option>';
        for(let i = 1; i <= 10; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = `${i}번`;
          buttonSelect.appendChild(option);
        }
      }
      
      // 초기 렌더링
      renderPlayerSelection();
    }
    
    function updateSeatDisplay() {
      // 새로운 구조에서는 renderPlayerSelection이 모든 것을 처리
      // renderPlayerSelection 내부에서 updatePositionIndicators를 호출함
      renderPlayerSelection();
    }
    
    function getPositionsForSeat(seatNum) {
      const positions = [];
      if(!window.state.buttonPosition) return positions;
      
      const btnPos = parseInt(window.state.buttonPosition);
      const allPlayerSeats = getAllPlayerSeats();
      
      if(seatNum === btnPos) positions.push('BTN');
      
      // SB, BB 계산 (전체 플레이어 중 버튼 다음 플레이어들)
      const sbSeat = getNextPlayerSeat(btnPos, allPlayerSeats);
      const bbSeat = getNextPlayerSeat(sbSeat, allPlayerSeats);
      
      if(seatNum === sbSeat) positions.push('SB');
      if(seatNum === bbSeat) positions.push('BB');
      
      return positions;
    }
    
    function getOccupiedSeats() {
      return Object.keys(window.state.seatMap)
        .map(s => parseInt(s))
        .filter(s => window.state.seatMap[s])
        .sort((a, b) => a - b);
    }
    
    // 전체 플레이어 좌석 리스트 가져오기 (게임 참여 여부와 관계없이)
    function getAllPlayerSeats() {
      if(!window.state.selectedTable) return [];
      const tableData = window.state.playerDataByTable[window.state.selectedTable] || [];
      return tableData
        .filter(player => player.seat)
        .map(player => parseSeatNumber(player.seat))
        .sort((a, b) => a - b);
    }
    
    // 전체 플레이어 중에서 다음 좌석 찾기 (SB/BB 계산용)
    function getNextPlayerSeat(currentSeat, allSeats) {
      if(!allSeats.length) return null;
      
      // 현재 좌석 다음의 첫 번째 플레이어 좌석 찾기
      for(let i = 1; i <= 10; i++) {
        const nextSeat = ((currentSeat + i - 1) % 10) + 1;
        if(allSeats.includes(nextSeat)) {
          return nextSeat;
        }
      }
      return allSeats[0];
    }
    
    function getNextOccupiedSeat(currentSeat, occupiedSeats) {
      if(!occupiedSeats.length) return null;
      
      // 현재 좌석 다음의 첫 번째 점유 좌석 찾기
      for(let i = 1; i <= 10; i++) {
        const nextSeat = ((currentSeat + i - 1) % 10) + 1;
        if(occupiedSeats.includes(nextSeat)) {
          return nextSeat;
        }
      }
      return occupiedSeats[0];
    }
    
    function updateButtonPositionDisplay() {
      const display = document.getElementById('position-display');
      if(!display) return;
      
      if(!window.state.buttonPosition) {
        display.innerHTML = '<span class="text-gray-400">버튼을 선택하면 SB/BB가 자동으로 설정됩니다</span>';
        return;
      }
      
      // 전체 플레이어 좌석 리스트에서 SB/BB 계산
      const allPlayerSeats = getAllPlayerSeats();
      const btnPos = parseInt(window.state.buttonPosition);
      const sbSeat = getNextPlayerSeat(btnPos, allPlayerSeats);
      const bbSeat = getNextPlayerSeat(sbSeat, allPlayerSeats);
      
      // 플레이어 이름 가져오기 (전체 테이블 데이터에서)
      const tableData = window.state.playerDataByTable[window.state.selectedTable] || [];
      const btnPlayer = tableData.find(p => parseSeatNumber(p.seat) === btnPos)?.name || '빈자리';
      const sbPlayer = tableData.find(p => parseSeatNumber(p.seat) === sbSeat)?.name || '빈자리';
      const bbPlayer = tableData.find(p => parseSeatNumber(p.seat) === bbSeat)?.name || '빈자리';
      
      display.innerHTML = `
        <div class="grid grid-cols-3 gap-2 text-center">
          <div class="bg-yellow-900/30 rounded p-1">
            <span class="text-yellow-400 font-bold">🎯 BTN</span>
            <div class="text-white text-xs">${btnPlayer}</div>
          </div>
          <div class="bg-green-900/30 rounded p-1">
            <span class="text-green-400 font-bold">SB</span>
            <div class="text-white text-xs">${sbPlayer}</div>
          </div>
          <div class="bg-blue-900/30 rounded p-1">
            <span class="text-blue-400 font-bold">BB</span>
            <div class="text-white text-xs">${bbPlayer}</div>
          </div>
        </div>
      `;
    }
    
    function updatePositionIndicators() {
      const indicators = document.getElementById('position-indicators');
      if(!window.state.buttonPosition) {
        indicators.textContent = '';
        return;
      }
      
      // 전체 플레이어 좌석 리스트에서 SB/BB 계산
      const allPlayerSeats = getAllPlayerSeats();
      const btnPos = parseInt(window.state.buttonPosition);
      const sbSeat = getNextPlayerSeat(btnPos, allPlayerSeats);
      const bbSeat = getNextPlayerSeat(sbSeat, allPlayerSeats);
      
      // 플레이어 이름 가져오기 (전체 테이블 데이터에서)
      const tableData = window.state.playerDataByTable[window.state.selectedTable] || [];
      const btnPlayer = tableData.find(p => parseSeatNumber(p.seat) === btnPos)?.name || '빈자리';
      const sbPlayer = tableData.find(p => parseSeatNumber(p.seat) === sbSeat)?.name || '빈자리';
      const bbPlayer = tableData.find(p => parseSeatNumber(p.seat) === bbSeat)?.name || '빈자리';
      
      indicators.innerHTML = `
        <span class="text-yellow-400">BTN: ${btnPlayer}</span>
        <span class="text-green-400">SB: ${sbPlayer}</span>
        <span class="text-blue-400">BB: ${bbPlayer}</span>
      `;
    }
    
    function getActionOrder(street) {
      const occupiedSeats = getOccupiedSeats();
      if(!occupiedSeats.length || !window.state.buttonPosition) {
        // 버튼 위치가 없으면 배열 순서대로
        return window.state.playersInHand.map(p => p.name);
      }
      
      const btnPos = parseInt(window.state.buttonPosition);
      const sbSeat = getNextOccupiedSeat(btnPos, occupiedSeats);
      const bbSeat = getNextOccupiedSeat(sbSeat, occupiedSeats);
      
      let actionOrder = [];
      
      if(street === 'preflop') {
        // 프리플랍: UTG(BB 다음) → ... → BTN → SB → BB
        let startSeat = getNextOccupiedSeat(bbSeat, occupiedSeats);
        let currentSeat = startSeat;
        
        // BB 전까지 순회
        while(currentSeat !== bbSeat) {
          if(window.state.seatMap[currentSeat]) {
            actionOrder.push(window.state.seatMap[currentSeat]);
          }
          currentSeat = getNextOccupiedSeat(currentSeat, occupiedSeats);
        }
        // 마지막에 BB 추가
        if(window.state.seatMap[bbSeat]) {
          actionOrder.push(window.state.seatMap[bbSeat]);
        }
      } else {
        // 포스트플랍: SB → BB → ... → BTN
        let currentSeat = sbSeat;
        let count = 0;
        
        while(count < occupiedSeats.length) {
          if(window.state.seatMap[currentSeat]) {
            actionOrder.push(window.state.seatMap[currentSeat]);
          }
          currentSeat = getNextOccupiedSeat(currentSeat, occupiedSeats);
          count++;
        }
      }
      
      return actionOrder;
    }
    
    function getNextActionPlayer(street) {
      const actionOrder = getActionOrder(street);
      const actions = window.state.actionState[street] || [];
      
      // 폴드/올인 플레이어 제외
      const activePlayers = actionOrder.filter(name => 
        window.state.playerStatus[name] !== 'folded' && 
        window.state.playerStatus[name] !== 'allin'
      );
      
      if(activePlayers.length === 0) return null;
      
      // 마지막 액션한 플레이어 찾기
      for(let i = actions.length - 1; i >= 0; i--) {
        const lastPlayer = actions[i].player;
        const idx = activePlayers.indexOf(lastPlayer);
        if(idx !== -1) {
          // 다음 플레이어 반환
          return activePlayers[(idx + 1) % activePlayers.length];
        }
      }
      
      // 액션이 없으면 첫 번째 활성 플레이어
      return activePlayers[0];
    }

    // ====== 액션 자동 매핑 시스템 ======
    
    // 다음 액션 플레이어 계산
    function calculateNextActionPlayer(street) {
      const actionOrder = getActionOrder(street);
      const actions = window.state.actionState[street] || [];
      
      // 폴드/올인 플레이어 제외한 활성 플레이어만
      const activePlayers = actionOrder.filter(name => {
        const status = window.state.playerStatus[name];
        return status !== 'folded' && status !== 'allin';
      });
      
      if(activePlayers.length === 0) {
        return null; // 모든 플레이어가 폴드/올인
      }
      
      // 이번 스트리트에서 액션한 횟수 계산
      const actionCounts = {};
      activePlayers.forEach(name => actionCounts[name] = 0);
      
      actions.forEach(action => {
        if(actionCounts.hasOwnProperty(action.player)) {
          actionCounts[action.player]++;
        }
      });
      
      // 가장 적게 액션한 플레이어 찾기 (순서대로)
      for(const player of activePlayers) {
        const minActionCount = Math.min(...Object.values(actionCounts));
        if(actionCounts[player] === minActionCount) {
          return player;
        }
      }
      
      return activePlayers[0];
    }
    
    // 다음 액션 플레이어 표시 업데이트
    function updateNextActionDisplay() {
      const street = window.state.currentStreet;
      const nextPlayer = calculateNextActionPlayer(street);
      
      window.state.nextActionPlayer = nextPlayer;
      
      // 헤더에 현재 차례 표시
      const turnIndicator = document.getElementById('current-turn-indicator');
      if(turnIndicator && nextPlayer) {
        const playerData = window.state.playersInHand.find(p => p.name === nextPlayer);
        const positions = playerData ? getPositionsForSeat(parseSeatNumber(playerData.seat) || 0) : [];
        const positionStr = positions.length > 0 ? `(${positions.join(',')})` : '';
        
        turnIndicator.innerHTML = `
          <span class="text-amber-400">현재 차례:</span>
          <span class="font-bold text-white">${nextPlayer} ${positionStr}</span>
        `;
        turnIndicator.classList.remove('hidden');
      } else if(turnIndicator) {
        turnIndicator.classList.add('hidden');
      }
      
      // 플레이어 카드 하이라이트
      document.querySelectorAll('.player-card').forEach(card => {
        const playerName = card.dataset.playerName;
        if(playerName === nextPlayer) {
          card.classList.add('border-2', 'border-amber-400', 'animate-pulse');
        } else {
          card.classList.remove('border-2', 'border-amber-400', 'animate-pulse');
        }
      });
    }
    
    // 액션 자동 추가 (자동 모드)
    function addAutoAction(actionType, amount = '') {
      if(window.state.actionInputMode !== 'auto') {
        return false;
      }
      
      const street = window.state.currentStreet;
      const nextPlayer = window.state.nextActionPlayer || calculateNextActionPlayer(street);
      
      if(!nextPlayer) {
        showFeedback('모든 플레이어가 액션을 완료했습니다', true);
        return false;
      }
      
      // 액션 추가
      addActionToState(nextPlayer, actionType, amount, street);
      
      // 플레이어 상태 업데이트
      if(actionType === 'Folds') {
        window.state.playerStatus[nextPlayer] = 'folded';
      } else if(actionType === 'All-in' || actionType === 'All In') {
        window.state.playerStatus[nextPlayer] = 'allin';
      }
      
      // UI 업데이트
      renderActionStreets();
      updateNextActionDisplay();
      saveActionState();
      
      return true;
    }
    
    // 스마트 콜 처리
    function handleSmartCall() {
      const street = window.state.currentStreet;
      const nextPlayer = window.state.nextActionPlayer || calculateNextActionPlayer(street);
      
      if(!nextPlayer) {
        showFeedback('모든 플레이어가 액션을 완료했습니다', true);
        return;
      }
      
      const smartAction = getSmartCheckCallAction(nextPlayer, street);
      if(smartAction.action === 'Checks') {
        addAutoAction('Checks');
      } else {
        addAutoAction(smartAction.action, smartAction.amount);
      }
    }
    
    // 올인 처리
    function handleAllIn() {
      const nextPlayer = window.state.nextActionPlayer || calculateNextActionPlayer(window.state.currentStreet);
      
      if(!nextPlayer) {
        showFeedback('모든 플레이어가 액션을 완료했습니다', true);
        return;
      }
      
      const playerData = window.state.playersInHand.find(p => p.name === nextPlayer);
      if(playerData) {
        addAutoAction('All-in', playerData.chips);
      }
    }
    
    // 빠른 벳/레이즈 입력
    function openQuickBetRaise() {
      const street = window.state.currentStreet;
      const nextPlayer = window.state.nextActionPlayer || calculateNextActionPlayer(street);
      
      if(!nextPlayer) {
        showFeedback('모든 플레이어가 액션을 완료했습니다', true);
        return;
      }
      
      // 키패드 열기
      openKeypad(null, { 
        purpose: 'quickBet',
        player: nextPlayer,
        street: street
      });
    }
    
    // 전역 함수로 등록
    window.addAutoAction = addAutoAction;
    window.handleSmartCall = handleSmartCall;
    window.handleAllIn = handleAllIn;
    window.openQuickBetRaise = openQuickBetRaise;
    
    // ====== PERSIST (localStorage) ======
    function saveActionState(){ localStorage.setItem('phl_v46_state', JSON.stringify(window.state.actionState)); }
    function loadActionState(){
      const s=localStorage.getItem('phl_v46_state');
      if(s) window.state.actionState={...window.state.actionState, ...JSON.parse(s)};
      updateBlindButtons();
      // Ante 체크박스 상태도 복원 (v3.4.23)
      if(el.bbAnteCheckbox) {
        el.bbAnteCheckbox.checked = window.state.actionState.hasBBAnte || false;
      }
    }

    function updateBlindButtons() {
      const smallBlindBtn = document.getElementById('small-blind-btn');
      const bigBlindBtn = document.getElementById('big-blind-btn');

      if(smallBlindBtn) {
        smallBlindBtn.textContent = formatNumber(window.state.actionState.smallBlind || '0');
      }
      if(bigBlindBtn) {
        bigBlindBtn.textContent = formatNumber(window.state.actionState.bigBlind || '0');
      }
    }

    // Ante 체크박스 상태 동기화 함수 (v3.4.23)
    function syncAnteCheckbox() {
      if(el.bbAnteCheckbox) {
        const shouldBeChecked = window.state.actionState.hasBBAnte || false;
        if(el.bbAnteCheckbox.checked !== shouldBeChecked) {
          el.bbAnteCheckbox.checked = shouldBeChecked;
          console.log(`Ante 체크박스 동기화: ${shouldBeChecked}`);
        }
      }
    }

    // ====== SMART CHECK/CALL ======
    function getSmartCheckCallAction(player, street) {
      const actions = window.state.actionState[street];
      let lastBet = null;
      let requiredAmt = 0;

      // 현재 스트리트에서만 마지막 베팅 찾기 (각 스트리트는 독립적)
      for(let i = actions.length - 1; i >= 0; i--) {
        const action = actions[i];
        if(['Bets', 'Raises', 'All In'].includes(action.action) && action.amount) {
          lastBet = action;
          break;
        }
      }

      const p = window.state.playersInHand.find(pp => pp.name === player);
      if (!p) {
        console.error(`플레이어를 찾을 수 없음: ${player}`, {
          playersInHand: window.state.playersInHand,
          playerName: player
        });
        return { action: 'Checks', amount: null, label: 'Check' };
      }

      const playerChips = parseInt(unformatNumber(p.chips), 10) || 0;

      if(!lastBet) {
        // 현재 스트리트에 베팅 없음 → CHECK
        if(street === 'preflop') {
          // 프리플랍에서 베팅 없으면 빅블라인드 콜
          requiredAmt = unformatNumber(window.state.actionState.bigBlind);
          if(playerChips <= parseInt(requiredAmt, 10)) {
            return { action: 'All In', amount: p.chips, label: `All-in ${formatNumber(p.chips)}` };
          }
          return { action: 'Calls', amount: requiredAmt, label: `Call ${formatNumber(requiredAmt)}` };
        }
        // 플랍, 턴, 리버에서는 각 스트리트가 새로 시작되므로 체크 가능
        return { action: 'Checks', amount: null, label: 'Check' };
      } else {
        // 현재 스트리트에 베팅 있음 → CALL
        requiredAmt = lastBet.amount;
        if(playerChips <= parseInt(unformatNumber(requiredAmt), 10)) {
          // 칩 부족 → ALL-IN
          return { action: 'All In', amount: p.chips, label: `All-in ${formatNumber(p.chips)}` };
        } else {
          // 일반 CALL
          return { action: 'Calls', amount: requiredAmt, label: `Call ${formatNumber(requiredAmt)}` };
        }
      }
    }
    
    // ====== STREET COMPLETE CHECK ======
    function checkStreetComplete(street) {
      const actions = window.state.actionState[street];
      const activePlayers = window.state.playersInHand.filter(p => 
        window.state.playerStatus[p.name] !== 'folded'
      );
      const bettingPlayers = activePlayers.filter(p =>
        window.state.playerStatus[p.name] !== 'allin'
      );
      
      // 1. 핸드 종료 체크
      if(activePlayers.length === 1) {
        showFeedback(`${activePlayers[0].name} 승리!`);
        return { status: 'HAND_END', winner: activePlayers[0].name };
      }
      
      // 2. 올인 쇼다운 체크
      if(bettingPlayers.length <= 1) {
        showFeedback('올인 쇼다운! 나머지 카드를 오픈하세요.');
        return { status: 'SHOWDOWN' };
      }
      
      // 3. 스트리트 완료 체크
      if(actions.length === 0) return { status: 'WAITING' };
      
      const lastAction = actions[actions.length - 1];
      if(!['Checks', 'Calls', 'Folds'].includes(lastAction.action)) {
        return { status: 'WAITING' };
      }
      
      // 각 플레이어의 총 베팅액 계산
      const playerBets = {};
      actions.forEach(a => {
        if(a.amount && a.player) {
          playerBets[a.player] = (playerBets[a.player] || 0) + parseInt(unformatNumber(a.amount), 10);
        }
      });
      
      // 베팅 가능한 플레이어들의 베팅액 확인
      const betAmounts = bettingPlayers.map(p => playerBets[p.name] || 0);
      const maxBet = Math.max(...betAmounts, 0);
      const allEqual = betAmounts.every(amt => amt === maxBet);
      
      if(allEqual) {
        const nextStreet = getNextStreet(street);
        if(nextStreet) {
          showFeedback(`${street} 완료! ${nextStreet}로 진행`);
          // 자동 진행 옵션이 있다면 여기서 처리
          return { status: 'STREET_COMPLETE', nextStreet };
        }
      }
      
      return { status: 'WAITING' };
    }
    
    function getNextStreet(current) {
      const streets = ['preflop', 'flop', 'turn', 'river'];
      const idx = streets.indexOf(current);
      return idx >= 0 && idx < 3 ? streets[idx + 1] : null;
    }
    
    // ====== POT ======
    // 플레이어별 총 기여액 계산 (폴드한 플레이어 포함)
    function calculatePlayerContributions() {
      const contributions = {};
      const playersInHand = window.state.playersInHand || [];
      
      // 1. 모든 플레이어 초기화
      playersInHand.forEach(player => {
        contributions[player.name] = 0;
      });
      
      // 2. 블라인드와 안티 먼저 추가
      playersInHand.forEach(player => {
        const playerName = player.name;
        
        // 스몰 블라인드 (첫 번째 플레이어)
        if (player.role === 'SB' || playersInHand.indexOf(player) === 0) {
          const sbAmount = parseInt(unformatNumber(window.state.actionState.smallBlind) || 0, 10);
          contributions[playerName] += sbAmount;
        }
        
        // 빅 블라인드 (두 번째 플레이어)  
        if (player.role === 'BB' || playersInHand.indexOf(player) === 1) {
          const bbAmount = parseInt(unformatNumber(window.state.actionState.bigBlind) || 0, 10);
          contributions[playerName] += bbAmount;
        }
        
        // BB 안티 (모든 플레이어)
        if (window.state.actionState.hasBBAnte) {
          const bbAmount = parseInt(unformatNumber(window.state.actionState.bigBlind) || 0, 10);
          contributions[playerName] += bbAmount;
        }
      });
      
      // 3. 각 스트리트별로 최종 베팅 금액 계산 (올바른 포커 로직)
      ['preflop', 'flop', 'turn', 'river'].forEach(street => {
        const actions = window.state.actionState[street] || [];
        const streetBets = {}; // 이 스트리트에서 각 플레이어의 베팅 금액
        
        // 해당 스트리트의 모든 액션을 순회하며 최종 베팅 금액 계산
        actions.forEach(action => {
          if(action.amount && action.player && action.action !== 'Pot Correction') {
            const player = action.player;
            const amount = parseInt(unformatNumber(action.amount), 10);
            
            // 이 플레이어의 이 스트리트 베팅 금액을 action.amount로 설정
            // (콜/레이즈는 누적이 아니라 최종 베팅 금액)
            streetBets[player] = amount;
          }
        });
        
        // 이 스트리트의 최종 베팅 금액을 전체 기여액에 추가
        Object.entries(streetBets).forEach(([player, amount]) => {
          const playerData = playersInHand.find(p => p.name === player);
          const maxChips = playerData ? parseInt(unformatNumber(playerData.initialChips) || 0, 10) : Infinity;
          
          // 현재 총 기여액 + 이 스트리트 베팅이 최대 칩을 초과하지 않도록 제한
          const currentContribution = contributions[player] || 0;
          const allowedAmount = Math.min(amount, Math.max(0, maxChips - currentContribution));
          
          contributions[player] = currentContribution + allowedAmount;
          
          if (allowedAmount < amount) {
            console.log(`⚠️ ${player} (${street}): ${amount} 요청 → ${allowedAmount} 제한 (최대: ${maxChips}, 현재: ${currentContribution})`);
          }
        });
      });
      
      console.log('📊 플레이어별 기여액 (올인 제한 적용):', contributions);
      return contributions;
    }
    
    // 실제 팟 계산 (올인 제한과 사이드팟을 고려한 정확한 계산)
    function calculateActualPot() {
      console.log(`%c🎲 === 새로운 팟 계산 시작 [${APP_VERSION}] ===`, 'color: #10b981; font-weight: bold');
      
      // Pot Correction이 있으면 기존 로직 사용
      let potCorrectionFound = false;
      ['preflop', 'flop', 'turn', 'river'].forEach(street => {
        const actions = window.state.actionState[street] || [];
        if(actions.find(a => a.action === 'Pot Correction')) {
          potCorrectionFound = true;
        }
      });
      
      if(potCorrectionFound) {
        return calculatePotWithCorrection();
      }
      
      // 새로운 정확한 팟 계산
      const result = calculateAccuratePot();
      console.log(`%c🎲 === 팟 계산 종료 [${APP_VERSION}] ===`, 'color: #10b981; font-weight: bold');
      return result.totalPot;
    }
    
    // 정확한 팟 계산 (올인 제한 고려)
    function calculateAccuratePot() {
      const playersInHand = window.state.playersInHand || [];
      if (playersInHand.length === 0) {
        return { totalPot: 0, mainPot: 0, sidePots: [] };
      }
      
      // 1. 각 플레이어의 총 베팅 가능 금액 계산 (초기 칩)
      const playerMaxBets = {};
      playersInHand.forEach(player => {
        playerMaxBets[player.name] = parseInt(unformatNumber(player.initialChips) || 0, 10);
      });
      
      console.log('💰 플레이어별 최대 베팅 가능:', playerMaxBets);
      
      // 2. 실제 베팅 금액 계산 (블라인드 + 안티 + 액션)
      const playerBets = calculatePlayerContributions();
      console.log('📊 플레이어별 실제 베팅:', playerBets);
      
      // 3. 올인 플레이어들의 금액대별로 팟 분리
      const allInAmounts = [];
      playersInHand.forEach(player => {
        const playerName = player.name;
        const maxBet = playerMaxBets[playerName];
        const actualBet = Math.min(playerBets[playerName] || 0, maxBet);
        
        if (actualBet > 0 && !allInAmounts.includes(actualBet)) {
          allInAmounts.push(actualBet);
        }
      });
      
      allInAmounts.sort((a, b) => a - b);
      console.log('🎯 올인 금액대:', allInAmounts);
      
      // 4. 가장 작은 올인 금액이 메인팟 기준
      const mainPotCap = Math.min(...allInAmounts);
      let totalPot = 0;
      
      // 메인팟: 모든 플레이어가 mainPotCap만큼 기여
      const eligiblePlayers = playersInHand.filter(p => 
        window.state.playerStatus[p.name] !== 'folded'
      );
      
      const mainPot = mainPotCap * eligiblePlayers.length;
      totalPot = mainPot;
      
      console.log(`🎲 메인팟: ${mainPot} (${eligiblePlayers.length}명 × ${mainPotCap})`);
      
      // 사이드팟은 현재 구현하지 않고 메인팟만 반환
      // (대부분의 경우 2명이므로 사이드팟이 불필요)
      
      return { 
        totalPot: totalPot,
        mainPot: mainPot,
        sidePots: []
      };
    }
    
    // 기존 Pot Correction 로직
    function calculatePotWithCorrection() {
      let totalPot = 0;
      let potCorrectionValue = 0;
      let additionalBets = 0;
      
      ['preflop', 'flop', 'turn', 'river'].forEach(street => {
        const actions = window.state.actionState[street] || [];
        
        const potCorrectionIdx = actions.findIndex(a => a.action === 'Pot Correction');
        if(potCorrectionIdx !== -1) {
          const potCorrection = actions[potCorrectionIdx];
          potCorrectionValue = parseInt(unformatNumber(potCorrection.amount), 10);
          
          for(let i = potCorrectionIdx + 1; i < actions.length; i++) {
            if(actions[i].amount && actions[i].action !== 'Pot Correction') {
              additionalBets += parseInt(unformatNumber(actions[i].amount), 10);
            }
          }
          return;
        }
        
        actions.forEach(action => {
          if(action.amount && action.action !== 'Pot Correction') {
            totalPot += parseInt(unformatNumber(action.amount), 10);
          }
        });
      });
      
      if(potCorrectionValue > 0) {
        totalPot = potCorrectionValue + additionalBets;
      } else {
        totalPot += parseInt(unformatNumber(window.state.actionState.smallBlind) || 0, 10);
        totalPot += parseInt(unformatNumber(window.state.actionState.bigBlind) || 0, 10);
        if(window.state.actionState.hasBBAnte) {
          const bbAmount = parseInt(unformatNumber(window.state.actionState.bigBlind) || 0, 10);
          totalPot += bbAmount * (window.state.playersInHand || []).length;
        }
      }
      
      return totalPot;
    }
    
    // 언콜 베팅 계산
    function calculateUncalledBet() {
      const contributions = calculatePlayerContributions();
      const activePlayers = window.state.playersInHand.filter(p => 
        window.state.playerStatus[p.name] !== 'folded'
      );
      
      // 활성 플레이어가 1명일 때만 언콜 베팅 계산
      if(activePlayers.length === 1) {
        const winner = activePlayers[0];
        const winnerContribution = contributions[winner.name] || 0;
        
        // 다른 플레이어들의 최대 기여액
        const otherMaxContribution = Math.max(
          ...Object.entries(contributions)
            .filter(([player]) => player !== winner.name)
            .map(([_, amount]) => amount),
          0
        );
        
        // 언콜 베팅 = 승자 기여액 - 타 플레이어 최대 기여액
        const uncalledAmount = Math.max(0, winnerContribution - otherMaxContribution);
        
        return {
          amount: uncalledAmount,
          player: winner.name
        };
      }
      
      return { amount: 0, player: null };
    }
    
    // 기존 calculatePotSize 함수는 UI 표시용으로 유지
    function calculatePotSize(){
      let pot=0;
      let potCorrectionFound = false;
      let potCorrectionValue = 0;
      
      // 모든 스트리트 순회
      ['preflop','flop','turn','river'].forEach(st=> {
        const actions = window.state.actionState[st];
        
        // Pot Correction 찾기
        const correctionIdx = actions.findIndex(a => a.action === 'Pot Correction');
        if(correctionIdx !== -1) {
          potCorrectionFound = true;
          potCorrectionValue = parseInt(unformatNumber(actions[correctionIdx].amount), 10);
          
          // Pot Correction 이후의 액션들만 추가
          for(let i = correctionIdx + 1; i < actions.length; i++) {
            if(actions[i].amount && actions[i].action !== 'Pot Correction') {
              pot += parseInt(unformatNumber(actions[i].amount), 10);
            }
          }
        } else if(potCorrectionFound) {
          // Pot Correction 이후의 스트리트
          actions.forEach(a => {
            if(a.amount && a.action !== 'Pot Correction') {
              pot += parseInt(unformatNumber(a.amount), 10);
            }
          });
        } else {
          // Pot Correction 이전의 액션들
          actions.forEach(a => {
            if(a.amount && a.action !== 'Pot Correction') {
              pot += parseInt(unformatNumber(a.amount), 10);
            }
          });
        }
      });
      
      // Pot Correction이 없으면 블라인드/앤티 추가
      if(!potCorrectionFound) {
        pot += parseInt(unformatNumber(window.state.actionState.smallBlind)||0,10);
        pot += parseInt(unformatNumber(window.state.actionState.bigBlind)||0,10);
        if(window.state.actionState.hasBBAnte) {
          pot += parseInt(unformatNumber(window.state.actionState.bigBlind)||0,10);
        }
      } else {
        // Pot Correction 값이 기준
        pot = potCorrectionValue + pot;
      }
      
      return pot;
    }

    // ====== CSV LOADERS ======
    async function fetchCsv(url){
      const res=await fetch(url);
      if(!res.ok) {
        console.log(`CSV fetch status: ${res.status}`);
        return []; // 빈 배열 반환
      }
      const txt=await res.text();
      return parseCSV(txt);
    }

    function buildTypeFromCsv(rows){
      // Type 시트 구조 (v3.5.41 - 2025년 새 구조):
      // A:Poker Room, B:Table Name, C:Table No., D:Seat No., E:Players, F:Nationality, G:Chips, H:Keyplayer
      if(!rows||rows.length<1) return;

      // 컬럼 인덱스 상수 정의 (유지보수성 개선)
      const COLUMNS = {
        POKER_ROOM: 0,    // A열 (이전: Player였던 자리)
        TABLE_NAME: 1,    // B열 (이전: Table이었던 자리)
        TABLE_NO: 2,      // C열 (이전: Notable이었던 자리)
        SEAT_NO: 3,       // D열 (이전: Chips였던 자리)
        PLAYERS: 4,       // E열 (Player 새 위치)
        NATIONALITY: 5,   // F열 (이전: Seat였던 자리)
        CHIPS: 6,         // G열 (이전: Status였던 자리)
        KEYPLAYER: 7      // H열 (Notable/Keyplayer 새 위치)
      };

      const header = rows[0] || [];

      // 호환성 체크 함수 - 데이터 구조 자동 감지
      function detectSheetStructure(headerRow, dataRows) {
        if (!headerRow || headerRow.length === 0) return 'unknown';

        // 새 구조 감지 키워드 (대소문자 무시)
        const newStructureKeywords = ['poker room', 'table name', 'players', 'nationality', 'keyplayer'];
        const headerStr = headerRow.join('|').toLowerCase();

        const newStructureMatches = newStructureKeywords.filter(keyword =>
          headerStr.includes(keyword)
        ).length;

        // 이전 구조 감지 키워드
        const oldStructureKeywords = ['player', 'table', 'notable', 'status'];
        const oldStructureMatches = oldStructureKeywords.filter(keyword =>
          headerStr.includes(keyword)
        ).length;

        // 데이터 샘플로 추가 검증
        if (dataRows && dataRows.length > 0) {
          const sampleRow = dataRows[0];
          // 새 구조라면 Players 필드(E열)에 이름이 있어야 함
          const hasPlayerInE = sampleRow && sampleRow[COLUMNS.PLAYERS] &&
                               String(sampleRow[COLUMNS.PLAYERS]).trim().length > 0;

          if (newStructureMatches >= 3 && hasPlayerInE) return 'new';
          if (oldStructureMatches >= 3 && !hasPlayerInE) return 'old';
        }

        // 헤더만으로 판단
        if (newStructureMatches >= 3) return 'new';
        if (oldStructureMatches >= 2) return 'old';

        return 'unknown';
      }

      const structureType = detectSheetStructure(header, rows.slice(1, 3));
      console.log(`[v3.5.41] 시트 구조 감지: ${structureType} (헤더: ${header.join(', ')})`);

      if (structureType === 'old') {
        console.warn(`[v3.5.41] ⚠️ 이전 구조 감지됨! 새 구조로 업데이트 필요`);
        console.warn(`[v3.5.41] 예상 구조: Player,Table,Notable,Chips,UpdatedAt,Seat,Status`);
        console.warn(`[v3.5.41] 새 구조: Poker Room,Table Name,Table No.,Seat No.,Players,Nationality,Chips,Keyplayer`);
      } else if (structureType === 'unknown') {
        console.warn(`[v3.5.41] ⚠️ 알 수 없는 시트 구조. 새 구조로 가정하여 처리`);
      }

      // 카메라 프리셋 기본값 설정 (Type 시트에서 제거됨)
      window.state.camPreset.cam1 = 'Cam1';
      window.state.camPreset.cam2 = 'Cam2';

      // localStorage에서 마지막 카메라 번호 읽어서 표시
      const lastCam1No = localStorage.getItem('pokerHandLogger_lastCam1');
      const lastCam2No = localStorage.getItem('pokerHandLogger_lastCam2');

      console.log(`🎞️ 카메라 버튼 초기화 (기본값):`);
      console.log(`  Cam1 저장된 번호: ${lastCam1No || '없음'}`);
      console.log(`  Cam2 저장된 번호: ${lastCam2No || '없음'}`);

      if(lastCam1No) {
        const nextNo = parseInt(lastCam1No, 10) + 1;
        el.cam1.textContent = `Cam1${pad4(nextNo)}`;
        console.log(`  → Cam1 표시: ${pad4(nextNo)}`);
      } else {
        el.cam1.textContent = `Cam10001`;
        console.log(`  → Cam1 표시: 0001 (초기값)`);
      }

      if(lastCam2No) {
        const nextNo = parseInt(lastCam2No, 10) + 1;
        el.cam2.textContent = `Cam2${pad4(nextNo)}`;
        console.log(`  → Cam2 표시: ${pad4(nextNo)}`);
      } else {
        el.cam2.textContent = `Cam20001`;
        console.log(`  → Cam2 표시: 0001 (초기값)`);
      }

      const byTable={};
      // 데이터 검증 함수
      function validateRowData(r, rowIndex) {
        const errors = [];

        // 필수 필드 체크 (사용자 지시: Players, Table No.만 체크)
        if (!String(r[COLUMNS.PLAYERS]||'').trim()) {
          errors.push(`행 ${rowIndex}: Players 필드가 비어있음`);
        }
        if (!String(r[COLUMNS.TABLE_NO]||'').trim()) {
          errors.push(`행 ${rowIndex}: Table No. 필드가 비어있음`);
        }

        // 칩 데이터 검증 (경고만, 필수 아님)
        const chipsStr = String(r[COLUMNS.CHIPS]||'0').trim();
        const chips = parseInt(chipsStr.replace(/,/g, ''), 10);
        if (isNaN(chips) && chipsStr !== '') {
          // 칩이 잘못되어도 에러로 처리하지 않음 (경고만)
          console.warn(`[v3.5.41] 행 ${rowIndex}: Chips 필드 파싱 실패 (${chipsStr}) - 0으로 처리`);
        }

        return { errors, isValid: errors.length === 0 };
      }

      for(let i=1;i<rows.length;i++){
        const r=rows[i]||[];

        // 데이터 검증
        const validation = validateRowData(r, i+1);
        if (!validation.isValid) {
          console.warn(`[v3.5.41] 데이터 검증 실패:`, validation.errors);
          continue; // 잘못된 데이터는 건너뛰기
        }

        // 상수를 사용한 데이터 파싱 (유지보수성 개선)
        const pokerRoom = String(r[COLUMNS.POKER_ROOM]||'').trim();
        const tableName = String(r[COLUMNS.TABLE_NAME]||'').trim();
        const tableNo = String(r[COLUMNS.TABLE_NO]||'').trim();   // ← 이것이 새로운 table 식별자
        const seat = String(r[COLUMNS.SEAT_NO]||'').trim();
        const player = String(r[COLUMNS.PLAYERS]||'').trim();
        const nationality = String(r[COLUMNS.NATIONALITY]||'').trim();
        const chipsStr = String(r[COLUMNS.CHIPS]!=null?r[COLUMNS.CHIPS]:'0').trim();
        const chips = parseInt(chipsStr.replace(/,/g, ''), 10) || 0;
        const keyplayer = String(r[COLUMNS.KEYPLAYER]||'').toUpperCase()==='TRUE';

        // 사용자 지시 따름: 이전 r[1] table → 현재 r[2] tableNo
        const table = tableNo;  // C열 Table No.를 테이블 식별자로 사용

        console.log(`[v3.5.41] 플레이어 처리: ${player} (${table}, 칩: ${chips})`);

        // 사용자 지시: Status 삭제, 데이터만 있으면 처리 (칩 금액 상관없이)
        if(player && table){
          if(!byTable[table]) byTable[table]=[];

          // v3.5.41: 새로운 데이터 구조로 저장
          const playerData = {
            name: player,
            chips: chipsStr, // 원본 문자열 그대로 저장
            notable: keyplayer, // Keyplayer를 notable로 매핑
            updatedAt: new Date().toISOString(), // 현재 시간 사용
            seat,
            status: 'IN', // chips > 0이면 IN으로 간주
            nationality, // 새로운 필드 추가
            tableNo, // 테이블 번호 추가
            pokerRoom, // 포커룸 정보 추가 (필요시 사용)
            originalIndex: i // 디버깅용 원본 행 번호
          };

          byTable[table].push(playerData);
          console.log(`[v3.5.41] ✅ ${player} 추가됨 (테이블: ${table}, 좌석: ${seat}, 칩: ${chips}, 키: ${keyplayer})`);
        } else {
          const reason = !player ? '플레이어명 없음' :
                        !table ? 'Table No. 없음' : '기타';
          console.log(`[v3.5.41] ❌ ${player||'[없음]'} 제외됨 - 이유: ${reason}`);
        }
      }

      // 처리 결과 요약 로그
      console.log(`[v3.5.41] === buildTypeFromCsv 완료 ===`);
      console.log(`[v3.5.41] 총 테이블 수: ${Object.keys(byTable).length}`);

      let totalPlayers = 0;
      let keyplayerCount = 0;

      Object.keys(byTable).forEach(table => {
        const players = byTable[table];
        const keyplayers = players.filter(p => p.notable).length;
        totalPlayers += players.length;
        keyplayerCount += keyplayers;

        console.log(`[v3.5.41] ${table}: ${players.length}명 (키플레이어: ${keyplayers}명)`);
      });

      console.log(`[v3.5.41] 전체 통계 - 총 플레이어: ${totalPlayers}명, 키플레이어: ${keyplayerCount}명`);

      window.state.playerDataByTable=byTable;
      window.state.allTables=Object.keys(byTable).sort();
    }

    function buildIndexFromCsv(rows){
      // Index CSV columns:
      // A handNumber | B startRow | C endRow | D handUpdatedAt | E handEdit | F handEditTime | G label | H table | I tableUpdatedAt | J Cam | K CamFile01name | L CamFile01number | M CamFile02name | N CamFile02number
      // O lastStreet | P lastAction | Q workStatus (새로운 열들)
      const out=[]; for(let i=1;i<rows.length;i++){
        const r=rows[i]||[];
        const item={
          handNumber:String(r[0]||''), startRow:+(r[1]||0), endRow:+(r[2]||0),
          handUpdatedAt:String(r[3]||''), handEdit:r[4], handEditTime:r[5], label:r[6],
          table:String(r[7]||''), tableUpdatedAt:r[8], cam:r[9], cam1:r[10], cam1no:r[11], cam2:r[12], cam2no:r[13],
          lastStreet:String(r[14]||''), lastAction:String(r[15]||''), workStatus:String(r[16]||'')  // 새로운 열들
        };
        if(item.handNumber) out.push(item);
      }
      window.state.indexRows=out;
      // 최신 우선 정렬
      out.sort((a,b)=> a.handUpdatedAt<b.handUpdatedAt?1:-1);
      window.state.allHandNumbers = [...new Set(out.map(x=>x.handNumber))];
    }

    // 파싱: Hand CSV → 특정 handNumber의 "가장 최근 updatedAt" 블록
    function parseHandBlock(rows, handNumber, preferDate){
      // HAND 시작 위치 수집
      const starts=[];
      for(let r=0;r<rows.length;r++){
        const row=rows[r]||[];
        if(row[1]==='HAND'){
          const no=String(row[2]||'');
          if(no===String(handNumber)){
            starts.push({r});
          }
        }
      }
      if(!starts.length) return null;
    
      // Index에서 최신 updatedAt 기준 블록 범위 찾기
      let updatedAt=preferDate||null;
      if(!updatedAt){
        const candidates=window.state.indexRows.filter(x=>x.handNumber===String(handNumber));
        candidates.sort((a,b)=> a.handUpdatedAt<b.handUpdatedAt?1:-1);
        updatedAt=candidates[0]?.handUpdatedAt||null;
      }
      let startRowIdx=-1, endRowIdx=-1;
      const idxRow=window.state.indexRows.find(x=>x.handNumber===String(handNumber) && x.handUpdatedAt===updatedAt);
      if(idxRow){ startRowIdx=idxRow.startRow-1; endRowIdx=idxRow.endRow-1; }
      else{
        const last=starts[starts.length-1].r;
        startRowIdx=last;
        let r=last+1; while(r<rows.length && rows[r][1]!=='HAND') r++;
        endRowIdx=r-1;
      }
      if(startRowIdx<0 || endRowIdx<startRowIdx) return null;
    
      const block=rows.slice(startRowIdx,endRowIdx+1);
    
      // 파싱
      let handInfo=null, players=[], board=[], smallBlind='', bigBlind='', ante=0, table='';
      // 스트리트 분할: 블록을 **순서대로** 돌면서 BOARD를 만날 때마다 전환한다
      const streets={preflop:[],flop:[],turn:[],river:[]};
      let street='preflop';
      let seenBoard=0;
    
      for(const row of block){
        if(row[1]==='HAND'){
          handInfo=row;
          ante=parseInt(row[6]||0,10)||0;
          smallBlind=row[8]||'';
          bigBlind=row[9]||'';
          table=row[17]||'';
        }else if(row[1]==='PLAYER'){
          const name=row[2];
          const seat=row[3];
          // PLAYER 파싱: row[4]는 0, row[5]는 시작칩, row[6]은 종료칩, row[7]은 핸드
          const init=row[5], final=row[6];
          const cards=(row[7]||'').trim()? String(row[7]).trim().split(' ') : [];
          players.push({name, seat, initialChips:init, finalChips:final, hand:cards});
        }else if(row[1]==='EVENT'){
          const etype=String(row[2]||'').toUpperCase();
          if(etype==='BOARD'){
            // 보드 전환 지점
            const card=row[4];
            if(card) board.push(card);
            seenBoard++;
            if(seenBoard===3) street='flop';
            else if(seenBoard===4) street='turn';
            else if(seenBoard===5) street='river';
          }else{
            // 좌석 → 이름
            const seat=row[3];
            const amount=row[4];
            const time=row[5];
            const p=players.find(pp=>String(pp.seat)===String(seat));
            const name=p?p.name:'';
            streets[street].push({
              player:name,
              action:etype,
              amount:amount||null,
              timestamp:time||null
            });
          }
        }
      }

  // 승자 판단 로직 개선: 가장 많은 칩 증가량을 가진 플레이어 한 명만 승자로 지정
  let winnerName = null;
  let maxGain = 0;
  
  players.forEach(p => {
    const initial = parseInt(p.initialChips || 0, 10);
    const final = parseInt(p.finalChips || 0, 10);
    const gain = final - initial;
    
    if(gain > maxGain) {
      maxGain = gain;
      winnerName = p.name;
    }
  });

  return {
    handInfo,
    table,
    ante,
    smallBlind,
    bigBlind,
    hasBBAnte: ante>0,
    board,
    actions: streets,
    players: players.map(p=>({
      name:p.name,
      initialChips:p.initialChips,
      finalChips:p.finalChips,
      hand:p.hand,
      role: (p.name === winnerName && maxGain > 0) ? 'winner' : null
    }))
  };
}



    // ====== LOADERS (initial) ======
    async function loadInitial(){
      openLogModal(); el.logDisplay.innerHTML='';
      logMessage(`🚀 ${APP_VERSION} 초기 데이터 로딩 시작 (Type/Index) ...`);
      try{
        const [typeRows, idxRows] = await Promise.all([
          CSV_TYPE_URL.includes('http')? fetchCsv(CSV_TYPE_URL) : Promise.resolve([]),
          CSV_INDEX_URL.includes('http')? fetchCsv(CSV_INDEX_URL) : Promise.resolve([])
        ]);
        if(typeRows.length) buildTypeFromCsv(typeRows);
        if(idxRows.length) buildIndexFromCsv(idxRows);
        window.state.actionState.handNumber = (window.state.allHandNumbers.length>0? Math.max(...window.state.allHandNumbers.map(n=>parseInt(n,10)||0)) + 1 : 1).toString();
        el.handNumberDisplay.textContent = `#${window.state.actionState.handNumber}`;
        el.dataStamp.textContent = `IDX rows: ${window.state.indexRows.length}`;
        
        // Index에서 마지막 카메라 번호 찾기 및 localStorage 동기화
        logMessage('📷 카메라 번호 데이터 분석 시작...');
        
        if(window.state.indexRows.length > 0) {
          logMessage(`📊 총 ${window.state.indexRows.length}개의 핸드 데이터 검색 중...`);
          
          // 가장 최근 핸드 찾기 (핸드 번호 기준 내림차순)
          const sortedRows = window.state.indexRows.slice().sort((a,b) => {
            const numA = parseInt(a.handNumber, 10) || 0;
            const numB = parseInt(b.handNumber, 10) || 0;
            return numB - numA;
          });
          
          // 카메라 번호가 있는 가장 최근 핸드 찾기
          let maxCam1 = 0, maxCam2 = 0;
          let foundInHand = null;
          
          for(const row of sortedRows) {
            const cam1Num = parseInt(row.cam1no, 10) || 0;
            const cam2Num = parseInt(row.cam2no, 10) || 0;
            
            if(cam1Num > maxCam1) {
              maxCam1 = cam1Num;
              if(!foundInHand) foundInHand = row.handNumber;
            }
            if(cam2Num > maxCam2) {
              maxCam2 = cam2Num;
              if(!foundInHand) foundInHand = row.handNumber;
            }
          }
          
          if(foundInHand) {
            logMessage(`📍 핸드 #${foundInHand}에서 카메라 번호 발견`);
          }
          
          if(maxCam1 > 0) {
            localStorage.setItem('pokerHandLogger_lastCam1', String(maxCam1));
            logMessage(`✅ ${window.state.camPreset.cam1} 마지막 번호: ${maxCam1} → 다음 번호: ${pad4(maxCam1 + 1)}`);
          } else {
            logMessage(`⚠️ ${window.state.camPreset.cam1} 번호 데이터 없음 → 0001부터 시작`);
          }
          
          if(maxCam2 > 0) {
            localStorage.setItem('pokerHandLogger_lastCam2', String(maxCam2));
            logMessage(`✅ ${window.state.camPreset.cam2} 마지막 번호: ${maxCam2} → 다음 번호: ${pad4(maxCam2 + 1)}`);
          } else {
            logMessage(`⚠️ ${window.state.camPreset.cam2} 번호 데이터 없음 → 0001부터 시작`);
          }
        } else {
          logMessage('⚠️ Index 데이터가 비어있음 → 카메라 번호 0001부터 시작');
        }
        
        renderAll();
        logMessage(`✅ ${APP_VERSION} 초기 데이터 로딩 완료`);
      }catch(err){
        console.error(err); logMessage(`초기 로딩 실패: ${err.message}`, true);
      }finally{
        setTimeout(closeLogModal, 800);
      }
    }

    // ====== LOAD HAND MODAL ======
    function openLoadHandModal(){
      console.log('📂 Load Hand 모달 열기 시도...');
      console.log('📋 Index 행 개수:', window.state.indexRows.length);
      
      if(!window.state.indexRows.length){
        console.error('❌ Index 데이터 없음');
        showFeedback('Index 데이터가 없습니다. CSV 게시와 URL을 확인하세요.', true);
        return;
      }
      
      // 핸드 번호 기준 내림차순 정렬 (최신 핸드가 위로)
      const items = window.state.indexRows.slice().sort((a,b)=> {
        const numA = parseInt(a.handNumber, 10) || 0;
        const numB = parseInt(b.handNumber, 10) || 0;
        return numB - numA; // 내림차순
      });
      
      const htmlItems = items.map(it=>{
        // 상태 아이콘 결정
        const statusIcon = {
          '완료': '✅',
          '진행중': '🔄',
          '검토필요': '⚠️'
        }[it.workStatus] || '📝';
        
        // 스트리트 배지 색상과 스타일
        const streetColors = {
          'preflop': 'bg-green-500 text-white',
          'flop': 'bg-blue-500 text-white',
          'turn': 'bg-orange-500 text-white',
          'river': 'bg-red-500 text-white'
        };
        const streetBadge = it.lastStreet ? 
          `<span class="${streetColors[it.lastStreet] || 'bg-gray-500 text-white'} px-2 py-0.5 rounded text-xs font-bold">${it.lastStreet?.toUpperCase() || ''}</span>` : '';
        
        // 버튼 배경색 (상태별)
        const btnBgClass = it.workStatus === '완료' ? 'bg-gray-800' : 
                          it.workStatus === '검토필요' ? 'bg-yellow-900/30' : 'bg-gray-700';
        
        return `<button class="btn ${btnBgClass} p-2 rounded-md w-full text-left load-hand-item-btn mb-2 hover:bg-gray-600" 
                data-no="${it.handNumber}" data-date="${it.handUpdatedAt}">
          <div class="flex justify-between items-center mb-1">
            <span class="font-bold text-white flex items-center gap-1">
              ${statusIcon} #${it.handNumber}
            </span>
            ${streetBadge}
            <span class="text-xs text-amber-400 truncate max-w-[100px]">${it.table||''}</span>
          </div>
          <div class="flex justify-between items-center">
            <span class="text-xs text-gray-400">${it.lastAction || '액션 없음'}</span>
            <span class="text-xs text-gray-500">${it.handUpdatedAt||''}</span>
          </div>
        </button>`;
      }).join('');
      
      const html = `<div class="bg-gray-800 rounded-lg p-4 w-full max-w-md flex flex-col h-2/3">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold text-amber-400">핸드 불러오기</h2>
          <button id="close-load-hand-modal" class="text-2xl">&times;</button>
        </div>
        <div class="overflow-y-auto space-y-2 flex-grow pr-2">${htmlItems}</div>
      </div>`;
      openModal(el.loadHandModal, html);
      
      // 모달 밖 클릭 시 닫기 (기존 이벤트 리스너와 충돌 방지)
      // onclick 대신 별도의 이벤트 리스너 사용
    }
    async function ensureHandCsv(){
      if(window.state.handCsvCache) return window.state.handCsvCache;
      logMessage('Hand CSV 다운로드 중...');
      const rows = await fetchCsv(CSV_HAND_URL + `&cb=${Date.now()}`);
      window.state.handCsvCache = rows;
      logMessage(`Hand CSV 로드 완료 (rows=${rows.length})`);
      return rows;
    }

    async function loadHandData(handNumber, preferDate){
      console.log(`📥 핸드 #${handNumber} 불러오기 시작...`);
      try{
        const rows = await ensureHandCsv();
        console.log(`📊 Hand CSV 로드 완료: ${rows.length} 행`);
        
        const data = parseHandBlock(rows, handNumber, preferDate);
        console.log('📝 파싱된 데이터:', data);
        
        if(!data){ 
          console.error(`❌ Hand #${handNumber} 데이터를 찾을 수 없음`);
          showFeedback(`Hand #${handNumber} 블록을 찾을 수 없습니다.`, true); 
          return; 
        }

        // 상태 초기화
        window.state.playersInHand=[];
        window.state.board = data.board||[];
        window.state.playerStatus = {}; // 플레이어 상태 초기화 추가
        
        window.state.actionState = {
          ...window.state.actionState,
          handNumber: String(handNumber),
          smallBlind: data.smallBlind || '',
          bigBlind: data.bigBlind || '',
          hasBBAnte: data.ante>0,
          preflop: data.actions?.preflop||[],
          flop: data.actions?.flop||[],
          turn: data.actions?.turn||[],
          river: data.actions?.river||[],
        };
        window.state.selectedTable = data.table || '';
        updateSelectedTableDisplay();

        window.state.playersInHand = (data.players||[]).map(p=>({
          name:p.name, hand:p.hand||[], chips:p.finalChips, initialChips:p.initialChips, role:p.role||null
        }));
        
        // 플레이어 상태 복원 (액션에서 폴드/올인 확인)
        ['preflop', 'flop', 'turn', 'river'].forEach(street => {
          (data.actions?.[street] || []).forEach(action => {
            if(action.player && action.action === 'Folds') {
              window.state.playerStatus[action.player] = 'folded';
            } else if(action.player && action.action === 'All In') {
              window.state.playerStatus[action.player] = 'allin';
            }
          });
        });

        el.handNumberDisplay.textContent = `#${handNumber}`;
        el.smallBlindInput.value = formatNumber(window.state.actionState.smallBlind);
        el.bigBlindInput.value = formatNumber(window.state.actionState.bigBlind);

        // Ante 체크박스 동기화 사용 (v3.4.23)
        syncAnteCheckbox();

        // currentStreet 결정: Index에서 저장된 값 우선, 없으면 액션으로 판단
        const indexRow = window.state.indexRows.find(r => r.handNumber === String(handNumber));
        console.log(`🔍 핸드 #${handNumber} 로드 중...`);
        console.log('📋 Index 행 데이터:', indexRow);
        
        if(indexRow) {
          // 카메라 정보 로드 및 로깅
          if(indexRow.cam1 || indexRow.cam1no) {
            console.log(`📷 카메라1 정보 발견:`);
            console.log(`   - 이름: ${indexRow.cam1 || '없음'}`);
            console.log(`   - 번호: ${indexRow.cam1no || '없음'}`);
            
            // 카메라1 정보 업데이트
            if(indexRow.cam1) {
              window.state.camPreset.cam1 = indexRow.cam1;
              console.log(`📷 카메라1 프리셋 업데이트: ${indexRow.cam1}`);
            }
            if(indexRow.cam1no) {
              window.state.camNumbers.cam1no = indexRow.cam1no;
              el.cam1.textContent = window.state.camPreset.cam1 + pad4(indexRow.cam1no);
            }
          }
          
          if(indexRow.cam2 || indexRow.cam2no) {
            console.log(`📷 카메라2 정보 발견:`);
            console.log(`   - 이름: ${indexRow.cam2 || '없음'}`);
            console.log(`   - 번호: ${indexRow.cam2no || '없음'}`);
            
            // 카메라2 정보 업데이트
            if(indexRow.cam2) {
              window.state.camPreset.cam2 = indexRow.cam2;
              console.log(`📷 카메라2 프리셋 업데이트: ${indexRow.cam2}`);
            }
            if(indexRow.cam2no) {
              window.state.camNumbers.cam2no = indexRow.cam2no;
              el.cam2.textContent = window.state.camPreset.cam2 + pad4(indexRow.cam2no);
            }
          }
          
          console.log('📊 로드 후 카메라 상태:');
          console.log(`   - cam1: ${window.state.camPreset.cam1}${pad4(window.state.camNumbers.cam1no || '0')}`);
          console.log(`   - cam2: ${window.state.camPreset.cam2}${pad4(window.state.camNumbers.cam2no || '0')}`);
          
          if(indexRow.lastStreet) {
            window.state.currentStreet = indexRow.lastStreet;
          }
          
          // 작업 상태 표시
          if(indexRow.workStatus) {
            const statusText = {
              '완료': '✅ 완료된 핸드',
              '진행중': '🔄 작업 진행 중',
              '검토필요': '⚠️ 검토 필요'
            }[indexRow.workStatus] || indexRow.workStatus;
            showFeedback(`#${handNumber} ${statusText}`);
          }
        } else {
          // 기존 로직: 액션으로 판단
          if(window.state.actionState.river.length > 0) {
            window.state.currentStreet = 'river';
          } else if(window.state.actionState.turn.length > 0) {
            window.state.currentStreet = 'turn';
          } else if(window.state.actionState.flop.length > 0) {
            window.state.currentStreet = 'flop';
          } else {
            window.state.currentStreet = 'preflop';
          }
        }

        // ActionOrderManagerV2 초기화
        if (window.actionOrderManager && window.state.playersInHand.length > 0) {
          // 버튼 위치 찾기 (실제 시트 번호 사용)
          const buttonPlayer = window.state.playersInHand.find(p => p.role === 'BTN');
          const buttonPosition = buttonPlayer ?
            parseSeatNumber(buttonPlayer.seat) || 1 :
            parseSeatNumber(window.state.playersInHand[0]?.seat) || 1;

          console.log('ActionOrderManager 초기화 시작:', {
            playersCount: window.state.playersInHand.length,
            buttonPosition,
            buttonPlayer: buttonPlayer?.name,
            handNumber: String(handNumber)
          });

          window.actionOrderManager.initializeHand(
            window.state.playersInHand,
            buttonPosition,
            String(handNumber)
          );

          console.log('✅ ActionOrderManagerV2 초기화 완료');

          // 디버그 출력
          if (window.actionOrderManager.debug) {
            window.actionOrderManager.debug();
          }
        }

        renderAll(); saveActionState();

        closeModal(el.loadHandModal);
        showFeedback(`#${handNumber} 핸드를 불러왔습니다.`);
      }catch(err){
        console.error('핸드 불러오기 오류:', err);
        console.error('오류 스택:', err.stack);
        showFeedback(`불러오기 실패: ${err.message}`, true);
      }
    }

    // ====== GENERATE & SEND ======
    function formatISODateInTZ(date, tz){
      // yyyy-MM-dd
      const y = new Intl.DateTimeFormat('en-CA', { timeZone: tz, year:'numeric' }).format(date);
      const m = new Intl.DateTimeFormat('en-CA', { timeZone: tz, month:'2-digit' }).format(date);
      const d = new Intl.DateTimeFormat('en-CA', { timeZone: tz, day:'2-digit' }).format(date);
      return `${y}-${m}-${d}`;
    }

    function generateRows_v46(){
      const out=[]; let no=1;
      const push=(arr)=>{ const a=[no, ...arr]; while(a.length<18) a.push(''); out.push(a); no++; };

      const epochSec = Math.floor(Date.now()/1000);
      const sb = unformatNumber(window.state.actionState.smallBlind)||'0';
      const bb = unformatNumber(window.state.actionState.bigBlind)||'0';
      const ante = window.state.actionState.hasBBAnte ? bb : '0';
      const table = window.state.selectedTable || '';
      const currentDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD 형식

      // GAME / PAYOUTS - E열(인덱스 4)에 날짜 추가
      const gameRow = ['GAME','GGProd Hand Logger','Virtual Table', currentDate];
      push(gameRow);
      push(['PAYOUTS']);

      // HAND: C no, D code, G ante, I SB, J BB, R table
      const handDate = formatISODateInTZ(new Date(), window.state.selectedTimezone); // yyyy-MM-dd
      
      // HAND: C no, D code, G ante, I SB, J BB, R table
      push(['HAND',
        String(window.state.actionState.handNumber),
        epochSec,
        'HOLDEM',
        window.state.actionState.hasBBAnte ? 'BB_ANTE':'NO_ANTE',
        ante,
        handDate, // ★ 여기(H) 칸에 날짜를 넣도록 약속 (Apps Script도 이 칸은 날짜로 쓰게)
        sb,       // I
        bb,       // J
        0,1,2,3,0,0,1,
        table     // R
      ]);

      // PLAYERS
      const players = window.state.playersInHand.map((p,i)=>({
        ...p, 
        seat: p.seat || (i+1)  // Type에서 가져온 seat 정보가 있으면 사용, 없으면 인덱스+1
      }));
      
      console.log(`%c=== PLAYER 행 생성 [${APP_VERSION}] ===`, 'color: #3b82f6; font-weight: bold');
      console.log(`현재 행번호(no): ${no}`);
      console.log(`플레이어 수: ${players.length}`);
      console.log('%c형식: A=행번호, B=PLAYER, C=이름, D=좌석, E=0(고정), F=시작칩, G=종료칩, H=핸드, I=포지션', 'color: #9ca3af');
      
      players.forEach(p=>{
        console.log(`\n--- ${p.name} 처리 시작 ---`);
        console.log(`  원본 데이터:`, p);
        
        // 칩 값 확인 - initialChips가 없으면 chips 값을 사용
        let initialChips;
        let finalChips = parseInt(unformatNumber(p.chips)||0,10);
        
        // initialChips가 undefined이거나 빈 문자열인 경우 처리
        if(p.initialChips === undefined || p.initialChips === '' || p.initialChips === null) {
          console.warn(`  ⚠️ initialChips가 없음. chips 값 사용: ${p.chips}`);
          initialChips = finalChips; // 시작칩이 없으면 현재 칩을 시작칩으로 사용
        } else {
          const unformattedInitial = unformatNumber(p.initialChips);
          console.log(`  unformatNumber(p.initialChips) = "${unformattedInitial}"`);
          initialChips = parseInt(unformattedInitial || '0', 10);
          if(isNaN(initialChips)) {
            console.error(`  ❌ parseInt가 NaN 반환! 원본: "${p.initialChips}"`);
            initialChips = 0;
          }
        }
        
        // 디버깅: 실제 값 확인
        console.log(`  초기칩(raw): "${p.initialChips}" → ${initialChips}`);
        console.log(`  최종칩(raw): "${p.chips}" → ${finalChips}`);
        console.log(`  핸드: ${p.hand?.join(' ') || '(없음)'}`);
        
        // 배열 생성 전 값 타입 확인
        console.log(`  initialChips 타입: ${typeof initialChips}, 값: ${initialChips}`);
        console.log(`  finalChips 타입: ${typeof finalChips}, 값: ${finalChips}`);
        
        // 포지션 정보 계산 (BTN/SB/BB)
        const positions = getPositionsForSeat(parseSeatNumber(p.seat) || 1);
        const positionStr = positions.length > 0 ? positions.join(',') : '';
        
        // PLAYER 형식: B=PLAYER, C=name, D=seat, E=0, F=시작칩, G=종료칩, H=핸드, I=포지션
        // push 함수가 자동으로 행번호를 A열에 추가하므로 8개 요소 필요
        const playerRow = ['PLAYER', p.name, parseSeatNumber(p.seat) || 1, 0, initialChips, finalChips, p.hand?.length? p.hand.join(' ') : '', positionStr];
        
        console.log(`  ===== PLAYER 행 생성 =====`);
        console.log(`  playerRow 배열:`, playerRow);
        console.log(`  playerRow.length: ${playerRow.length}`);
        
        // 각 요소 검증
        console.log(`  [0] = '${playerRow[0]}' (PLAYER 문자열)`);
        console.log(`  [1] = '${playerRow[1]}' (이름: ${p.name})`);
        console.log(`  [2] = ${playerRow[2]} (좌석: ${p.seat})`);
        console.log(`  [3] = ${playerRow[3]} (0 고정값)`);
        console.log(`  [4] = ${playerRow[4]} (시작칩: ${initialChips})`);
        console.log(`  [5] = ${playerRow[5]} (종료칩: ${finalChips})`);
        console.log(`  [6] = '${playerRow[6]}' (핸드)`);
        console.log(`  [7] = '${playerRow[7]}' (포지션: ${positionStr})`);
        
        // push 전 현재 행번호
        const currentNo = no;
        console.log(`  push 전 행번호: ${currentNo}`);
        
        push(playerRow);
        
        // push 후 실제 저장된 데이터 확인
        const pushedRow = out[out.length - 1];
        console.log(`  push 후 저장된 행:`, pushedRow);
        console.log(`  최종 CSV 형식:`);
        console.log(`    A=${pushedRow[0]} (행번호), B=${pushedRow[1]} (PLAYER), C=${pushedRow[2]} (이름), D=${pushedRow[3]} (좌석),`);
        console.log(`    E=${pushedRow[4]} (0 고정값), F=${pushedRow[5]} (시작칩), G=${pushedRow[6]} (종료칩), H=${pushedRow[7]} (핸드), I=${pushedRow[8]} (포지션)`);
        console.log(`--- ${p.name} 처리 완료 ---\n`);
      });

      // EVENTS
      const addEv=(log)=>{
        const p=players.find(x=>x.name===log.player);
        const seat=p?p.seat:'';
        const amt=log.amount? unformatNumber(log.amount):'';
        let t=(log.action||'').toUpperCase().replace(/S$/,'');
        if(t==='BET/RAISES') t='RAISE TO';
        push(['EVENT', t, seat, amt, '' ]);
      };
      window.state.actionState.preflop.forEach(addEv);
      if(window.state.board.length>=3){ push(['EVENT','BOARD',1,window.state.board[0],'' ]); push(['EVENT','BOARD',1,window.state.board[1],'' ]); push(['EVENT','BOARD',1,window.state.board[2],'' ]); }
      window.state.actionState.flop.forEach(addEv);
      if(window.state.board.length>=4){ push(['EVENT','BOARD',1,window.state.board[3],'' ]); }
      window.state.actionState.turn.forEach(addEv);
      if(window.state.board.length>=5){ push(['EVENT','BOARD',1,window.state.board[4],'' ]); }
      window.state.actionState.river.forEach(addEv);

      // 마지막 번호행(선택)
      out.push([no]); 
      return { rows: out, epochSec, currentDate };
    }
    
let isSending = false;

// Phase 4: 원본 함수를 내부 함수로 변경
async function _sendDataToGoogleSheet_internal(){
  if (isSending) return;     // 중복 전송 가드
  isSending = true;

  // 승자 체크 제거 - 승자 없어도 전송 가능
  const winners = window.state.playersInHand.filter(p=>p.role==='winner');

  await executeWithLock(async () => {
    openLogModal();
    logMessage('시트 전송 시작...');

  try{
    const { rows, epochSec } = generateRows_v46();
    const indexMeta   = buildIndexMeta();
    // 승자 정보 추가 (없으면 빈 문자열)
    indexMeta.winners = winners.map(w => w.name).join(', ') || '';
    const typeUpdates = buildTypeUpdates();
    // 노트 기능 제거
    const payload = { rows, indexMeta, typeUpdates };

    // x-www-form-urlencoded로 전송 → 프리플라이트 없음 (CORS 우회)
    const form = new URLSearchParams();
    form.append('payload', JSON.stringify(payload));

    const res = await fetch(APPS_SCRIPT_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' },
      body: form.toString(),
      // mode: 'cors'  // 생략 가능 (기본)
    });

    if(!res.ok){
      const text = await res.text().catch(()=> '');
      console.log(`서버 응답: ${res.status} ${text || ''}`);
      showFeedback('서버 응답 오류', true);
      return;
    }

    const json = await res.json().catch(()=> ({}));

    if(json.status === 'duplicate'){
      logMessage(`⚠️ 핸드 #${json.handNumber}는 이미 기록되어 있습니다.`);
      showFeedback('⚠️ 중복된 핸드입니다', true);
      // 중복인 경우에도 핸드 번호를 증가시켜야 함
      const currentNo = parseInt(window.state.actionState.handNumber, 10) || 0;
      window.state.actionState.handNumber = String(currentNo + 1);
      el.handNumberDisplay.textContent = `#${window.state.actionState.handNumber}`;
      
      // 중복이어도 시트에는 기록됐으므로 새 핸드로 재설정
      await resetApp();
      logMessage('✅ 새 핸드 준비 완료');
      
    } else if(json.status !== 'success'){
      logMessage('⚠️ Apps Script가 success를 반환하지 않았습니다.');
      logMessage('⚠️ 시트 확인 후 수동으로 재설정 버튼을 눌러주세요.');
      showFeedback('⚠️ 시트 전송 확인 필요', true);
      // 성공 여부가 불확실하므로 자동 재설정하지 않음
      
    } else {
      logMessage(`✅ 저장 완료: #${json.handNumber || indexMeta.handNumber} (rows=${json.rowsAdded})`);
      showFeedback('✅ 시트 기록 완료');
      
      // 시트가 업데이트되도록 충분한 시간을 기다림
      logMessage('시트 동기화 중...');
      await sleep(3000); // 3초 대기
      
      // Index CSV 리프레시
      try{
        if(CSV_INDEX_URL.includes('http')){
          const idxRows = await fetchCsv(CSV_INDEX_URL + `&cb=${Date.now()}`);
          buildIndexFromCsv(idxRows);
          el.dataStamp.textContent = `IDX rows: ${window.state.indexRows.length}`;
        }
      }catch(_){ /* noop */ }
      
      // 성공적으로 저장된 경우에만 새 핸드로 재설정
      // 시트 전송 직후에는 Index 재로드 없이 바로 다음 번호로 이동
      await resetApp(false, true);
      logMessage(`✅ ${APP_VERSION} 새 핸드 준비 완료`);
    }

  }catch(err){
    console.error(err);
    logMessage(`❌ 전송 실패: ${err.message}`, true);
    showFeedback(`❌ 전송 실패: ${err.message}`, true);
    // 전송 실패 시에는 재설정하지 않음
    logMessage('⚠️ 다시 시도하거나 수동으로 재설정해주세요.');
  }finally{
    closeLogModal(); // 로그를 좀 더 오래 보여줌
  }
  }, '시트 전송', '데이터를 Google 시트에 저장하고 있습니다...');

  isSending = false;
}

// Phase 4: 보호된 시트 전송 함수
async function sendDataToGoogleSheet() {
  console.log('📊 Google Sheets API: 시트 전송 시작');

  try {
    // Google Sheets API 준비 상태 확인
    if (!window.googleSheetsAPI) {
      throw new Error('Google Sheets API가 초기화되지 않았습니다');
    }

    // 연결 테스트
    const isConnected = await window.googleSheetsAPI.testConnection();
    if (!isConnected) {
      throw new Error('Google Sheets API 연결에 실패했습니다');
    }

    showFeedback('📊 데이터 준비 중...', false);

    // 핸드 데이터 생성 (기존 로직 재사용)
    const { rows: handData } = generateRows_v46();
    const indexData = buildIndexMeta();

    console.log('📊 전송할 데이터:', { handData, indexData });

    // Hand 시트에 데이터 전송
    showFeedback('📊 Hand 시트 전송 중...', false);
    const handResult = await window.googleSheetsAPI.appendData('Hand', handData);
    console.log('✅ Hand 시트 전송 완료:', handResult);

    // Index 시트에 메타데이터 전송
    showFeedback('📊 Index 시트 전송 중...', false);
    const indexResult = await window.googleSheetsAPI.appendData('Index', [Object.values(indexData)]);
    console.log('✅ Index 시트 전송 완료:', indexResult);

    // 성공 메시지
    showFeedback('✅ Google Sheets 전송 완료!', false);
    logMessage('✅ 핸드 데이터가 Google Sheets에 성공적으로 전송되었습니다');

    // UI 초기화
    resetHandState();

  } catch (error) {
    console.error('❌ Google Sheets API 전송 실패:', error);
    showFeedback(`❌ 전송 실패: ${error.message}`, true);
    logMessage(`❌ Google Sheets 전송 실패: ${error.message}`, true);
  }
}


    function nowIso() {
      // 서버에서 timezone 변환하므로 UTC ISO로 보냄
      return new Date().toISOString();
    }
    function buildIndexMeta(){
      const handNumber = String(window.state.actionState.handNumber);
      const handUpdatedAt = new Date().toISOString().split('T')[0]; // YYYY-MM-DD 형식
      const table = window.state.selectedTable || '';
      
      // 카메라 정보 로깅
      console.log('📦 Index 메타데이터 빌드:');
      console.log(`  cam1: ${window.state.camPreset.cam1} / 번호: ${window.state.camNumbers.cam1no}`);
      console.log(`  cam2: ${window.state.camPreset.cam2} / 번호: ${window.state.camNumbers.cam2no}`);
      
      // 마지막 액션 찾기
      let lastActionDesc = '';
      const streets = ['river', 'turn', 'flop', 'preflop'];
      for(const st of streets) {
        const actions = window.state.actionState[st];
        if(actions.length > 0) {
          const last = actions[actions.length - 1];
          lastActionDesc = `${last.player} ${last.action} ${last.amount || ''}`.trim();
          break;
        }
      }
      
      // 작업 상태 판단
      function determineWorkStatus() {
        // 승자가 선택되었으면 '완료'
        if(window.state.playersInHand.some(p => p.role === 'winner')) {
          return '완료';
        }
        // 리버까지 갔으면 '검토필요'
        if(window.state.currentStreet === 'river' && window.state.actionState.river.length > 0) {
          return '검토필요';
        }
        return '진행중';
      }
      
      // Index 시트의 전체 열 구조에 맞게 데이터 준비
      return {
        handNumber,                                           // A열
        // startRow, endRow는 서버에서 계산                    // B,C열
        handUpdatedAt,                                        // D열 (YYYY-MM-DD)
        // handEdit는 비워둠                                  // E열
        // handEditTime은 서버에서 처리                        // F열
        label: 'HOLDEM',                                      // G열
        table,                                                 // H열
        tableUpdatedAt: handUpdatedAt,                        // I열 (YYYY-MM-DD)
        cam: `${window.state.camPreset.cam1 || ''}+${window.state.camPreset.cam2 || ''}`, // J열
        camFile01name: window.state.camPreset.cam1 || '',            // K열
        camFile01number: getCamNumber('cam1'), // L열 - 자동 계산된 번호
        camFile02name: window.state.camPreset.cam2 || '',            // M열
        camFile02number: getCamNumber('cam2'), // N열 - 자동 계산된 번호
        lastStreet: window.state.currentStreet,                      // O열
        lastAction: lastActionDesc,                           // P열
        workStatus: determineWorkStatus()                     // Q열
      };
    }

    function buildTypeUpdates(){
      // 이번 핸드 동안 칩이 수정된 플레이어만 추려서 Type에 updatedAt 기록
      const table = window.state.selectedTable || '';
      return window.state.playersInHand
        .filter(p => p.chipsUpdatedAt) // 수정된 케이스만
        .map((p, index) => ({
          player: p.name,
          table,
          notable: p.notable || false, // Notable 정보 추가
          chips: String(p.chips || ''),
          updatedAt: p.chipsUpdatedAt, // ISO. 앱 스크립트에서 Date로 set
          seat: String(p.seat || index + 1) // Seat 정보 추가 (좌석 번호 또는 인덱스+1)
        }));
    }



    // ====== CAM PREFILL ======
    function computeCamPrefill(which){
      // 1. 자신의 값 있으면 그걸 표시
      if (which==='cam1' && window.state.camNumbers.cam1no) return pad4(window.state.camNumbers.cam1no);
      if (which==='cam2' && window.state.camNumbers.cam2no) return pad4(window.state.camNumbers.cam2no);

      // 2. 짝의 값 기반 자동 증가
      if (which==='cam2' && window.state.camNumbers.cam1no){
        const cam1Num = parseInt(String(window.state.camNumbers.cam1no).replace(/\D/g, ''), 10) || 0;
        const nextNum = cam1Num + 1;
        console.log(`💡 computeCamPrefill cam2: cam1=${window.state.camNumbers.cam1no} → ${cam1Num} → ${nextNum}`);
        return pad4(nextNum);
      }
      if (which==='cam1' && window.state.camNumbers.cam2no){
        const cam2Num = parseInt(String(window.state.camNumbers.cam2no).replace(/\D/g, ''), 10) || 0;
        const prevNum = Math.max(0, cam2Num - 1);
        console.log(`💡 computeCamPrefill cam1: cam2=${window.state.camNumbers.cam2no} → ${cam2Num} → ${prevNum}`);
        return pad4(prevNum);
      }

      // 3. 마지막 입력(세션 기준) +1
      if (window.state.lastCamNo!=null){
        const lastNum = parseInt(String(window.state.lastCamNo).replace(/\D/g, ''), 10) || 0;
        const nextNum = lastNum + 1;
        console.log(`💡 computeCamPrefill ${which}: lastCamNo=${window.state.lastCamNo} → ${lastNum} → ${nextNum}`);
        return pad4(nextNum);
      }

      // 4. 기본값
      console.log(`💡 computeCamPrefill ${which}: 기본값 0001 반환`);
      return '0001';
    }

    // 카메라 번호만 반환하는 함수 (패딩 없이)
    function getCamNumber(which) {
      // 1. 자신의 값 있으면 그걸 반환
      if (which === 'cam1' && window.state.camNumbers.cam1no) return window.state.camNumbers.cam1no;
      if (which === 'cam2' && window.state.camNumbers.cam2no) return window.state.camNumbers.cam2no;

      // 2. 짝의 값 기반 자동 증가
      if (which === 'cam2' && window.state.camNumbers.cam1no) {
        const cam1Num = parseInt(String(window.state.camNumbers.cam1no).replace(/\D/g, ''), 10) || 0;
        const nextNum = cam1Num + 1;
        return String(nextNum);
      }
      if (which === 'cam1' && window.state.camNumbers.cam2no) {
        const cam2Num = parseInt(String(window.state.camNumbers.cam2no).replace(/\D/g, ''), 10) || 0;
        const prevNum = Math.max(0, cam2Num - 1);
        return String(prevNum);
      }

      // 3. 마지막 입력(세션 기준) +1
      if (window.state.lastCamNo != null) {
        const lastNum = parseInt(String(window.state.lastCamNo).replace(/\D/g, ''), 10) || 0;
        const nextNum = lastNum + 1;
        return String(nextNum);
      }

      // 4. 현재 표시된 카메라 값에서 패딩을 제거한 숫자값 반환
      // computeCamPrefill과 같은 로직이지만 순환참조를 피하기 위해 직접 구현
      if (which === 'cam1' && el.cam1) {
        const displayText = el.cam1.textContent || '';
        const match = displayText.match(/(\d+)$/); // 마지막 숫자들 추출
        if (match) {
          return String(parseInt(match[1], 10) || 0);
        }
      }
      if (which === 'cam2' && el.cam2) {
        const displayText = el.cam2.textContent || '';
        const match = displayText.match(/(\d+)$/); // 마지막 숫자들 추출
        if (match) {
          return String(parseInt(match[1], 10) || 0);
        }
      }

      // 5. 최종 기본값
      return '0';
    }


    // ====== SIDEPOT CALCULATION ======
    function calculateSidePots() {
      const contributions = {};
      
      // 각 스트리트별 플레이어 기여액 계산
      ['preflop', 'flop', 'turn', 'river'].forEach(street => {
        window.state.actionState[street].forEach(action => {
          if(action.amount && action.player) {
            contributions[action.player] = (contributions[action.player] || 0) + 
                                          parseInt(unformatNumber(action.amount), 10);
          }
        });
      });
      
      // 올인 플레이어 정렬 (금액 오름차순)
      const allInPlayers = window.state.playersInHand
        .filter(p => window.state.playerStatus[p.name] === 'allin')
        .map(p => ({ name: p.name, amount: contributions[p.name] || 0 }))
        .sort((a, b) => a.amount - b.amount);
      
      const activePlayers = window.state.playersInHand
        .filter(p => window.state.playerStatus[p.name] !== 'folded')
        .map(p => p.name);
      
      const pots = [];
      let remainingPlayers = [...activePlayers];
      let previousCap = 0;
      
      // 각 올인 레벨별 팟 생성
      allInPlayers.forEach(allinPlayer => {
        const cap = allinPlayer.amount;
        const potPlayers = remainingPlayers.filter(p => contributions[p] >= cap);
        const potAmount = (cap - previousCap) * potPlayers.length;
        
        if(potAmount > 0) {
          pots.push({
            amount: potAmount,
            players: [...potPlayers],
            cap: cap,
            type: pots.length === 0 ? 'main' : `side${pots.length}`
          });
        }
        
        remainingPlayers = remainingPlayers.filter(p => p !== allinPlayer.name);
        previousCap = cap;
      });
      
      // 남은 베팅 (최고 베팅자들끼리)
      if(remainingPlayers.length > 0) {
        const maxBet = Math.max(...remainingPlayers.map(p => contributions[p] || 0));
        const finalPot = (maxBet - previousCap) * remainingPlayers.length;
        
        if(finalPot > 0) {
          pots.push({
            amount: finalPot,
            players: remainingPlayers,
            cap: maxBet,
            type: pots.length === 0 ? 'main' : `side${pots.length}`
          });
        }
      }
      
      return { pots, contributions };
    }
    
    // ====== RESET & FEEDBACK ======
    async function resetApp(reloadIndex = true, autoIncrement = false){
      let lastNo;
      
      if(autoIncrement) {
        // 시트 전송 직후: 현재 핸드 번호를 그대로 사용 (이미 전송된 번호)
        lastNo = parseInt(window.state.actionState.handNumber, 10) || 0;
        console.log('🔄 시트 전송 완료 - 다음 핸드로 자동 증가:', lastNo, '→', lastNo + 1);
      } else if(reloadIndex) {
        // 새로고침이나 수동 재설정: Index를 다시 로드하여 최신 핸드 번호 가져오기
        try {
          if(CSV_INDEX_URL.includes('http')){
            const idxRows = await fetchCsv(CSV_INDEX_URL + `&cb=${Date.now()}`);
            buildIndexFromCsv(idxRows);
          }
        } catch(err) {
          console.error('Index 재로드 실패:', err);
        }
        
        lastNo = window.state.indexRows.length
          ? Math.max(...window.state.indexRows.map(r=>parseInt(r.handNumber,10)||0))
          : 0;
        console.log('🔄 Index 재로드 - 마지막 핸드:', lastNo, '→ 다음:', lastNo + 1);
      } else {
        // Index 재로드 없이 현재 상태 유지
        lastNo = window.state.indexRows.length
          ? Math.max(...window.state.indexRows.map(r=>parseInt(r.handNumber,10)||0))
          : 0;
      }
      
      // 마지막 카메라 번호 저장 및 다음 번호 준비
      const lastCam1 = window.state.camNumbers.cam1no;
      const lastCam2 = window.state.camNumbers.cam2no;
      
      // 플레이어 유지하면서 새 핸드 시작
      console.log('🔄 새 핸드 시작 - 플레이어 초기화');
      
      // 기존 플레이어들의 현재 칩을 다음 핸드의 시작칩으로 설정
      window.state.playersInHand.forEach(p => {
        // 현재 칩을 시작칩으로 재설정
        p.initialChips = p.chips;
        p.hand = [];  // 핸드 카드 초기화
        p.role = null;  // 역할 초기화
        console.log(`  ${p.name}: 시작칩 = ${p.initialChips} (현재칩 유지)`);
      });
      
      window.state.board = [];
      window.state.playerStatus = {}; // 플레이어 상태 초기화
      window.state.currentStreet = 'preflop'; // 스트리트 초기화
      window.state.actionState = {
        handNumber: String(lastNo + 1),
        smallBlind: window.state.actionState.smallBlind,
        bigBlind: window.state.actionState.bigBlind,
        hasBBAnte: window.state.actionState.hasBBAnte,
        preflop: [], flop: [], turn: [], river: [],
      };
      
      // localStorage에서 마지막 카메라 번호 읽기
      const savedCam1 = localStorage.getItem('pokerHandLogger_lastCam1') || '';
      const savedCam2 = localStorage.getItem('pokerHandLogger_lastCam2') || '';

      console.log('📷 새 핸드 - 카메라 번호 유지 (증가 안함):');
      console.log(`  localStorage cam1: ${savedCam1 || '없음'}`);
      console.log(`  localStorage cam2: ${savedCam2 || '없음'}`);
      console.log(`  현재 cam1: ${lastCam1 || '없음'}`);
      console.log(`  현재 cam2: ${lastCam2 || '없음'}`);

      // 카메라 번호 유지 (자동 증가 제거)
      // cam1 처리: 현재 번호 유지, 없으면 초기값
      const cam1Current = lastCam1 || savedCam1 || '1';
      window.state.camNumbers.cam1no = String(cam1Current);
      el.cam1.textContent = `${window.state.camPreset.cam1}${pad4(cam1Current)}`;
      console.log(`  → ${window.state.camPreset.cam1} 현재 번호 유지: ${cam1Current}`);

      // cam2 처리: 현재 번호 유지, 없으면 초기값
      const cam2Current = lastCam2 || savedCam2 || '1';
      window.state.camNumbers.cam2no = String(cam2Current);
      el.cam2.textContent = `${window.state.camPreset.cam2}${pad4(cam2Current)}`;
      console.log(`  → ${window.state.camPreset.cam2} 현재 번호 유지: ${cam2Current}`);

      // lastCamNo는 실제 카메라 사용 시에만 업데이트 (여기서는 업데이트 안함)
      
      // ActionOrderManagerV2 초기화 (핸드 종료)
      if (window.actionOrderManager) {
        window.actionOrderManager.endHand();
        console.log('✅ ActionOrderManagerV2 핸드 종료 및 리셋');
      }

      // 새 핸드 시작 시 ActionOrderManager 재초기화
      if (window.actionOrderManager && window.state.playersInHand.length > 0) {
        // 버튼 위치 찾기 (기본값: 첫 번째 플레이어의 시트)
        const buttonPosition = parseSeatNumber(window.state.playersInHand[0]?.seat) || 1;
        const handNumber = window.state.actionState.handNumber;

        console.log('새 핸드 ActionOrderManager 초기화:', {
          playersCount: window.state.playersInHand.length,
          buttonPosition,
          handNumber
        });

        window.actionOrderManager.initializeHand(
          window.state.playersInHand,
          buttonPosition,
          String(handNumber)
        );

        console.log('✅ 새 핸드 ActionOrderManager 초기화 완료');
      }

      renderAll(); saveActionState();

      // Ante 체크박스 상태 동기화 (v3.4.23)
      syncAnteCheckbox();

      el.handNumberDisplay.textContent = `#${window.state.actionState.handNumber}`;
    }
    function showFeedback(msg,isErr=false){
      el.feedbackMessage.textContent = msg;
      el.feedbackMessage.className = `text-center h-4 text-xs font-semibold ${isErr?'text-red-400':'text-green-400'}`;
    }

    // 전역에서 접근 가능하도록 설정 (v3.4.9)
    window.showFeedback = showFeedback;
    window.openCardSelector = openCardSelector;

    // ====== EVENT LISTENERS ======
    function setupEventListeners(){
      el.loadHandBtn.onclick = openLoadHandModal;
      el.refreshDataBtn.onclick = () => executeWithLock(loadInitial, '데이터 새로고침', '최신 데이터를 불러오고 있습니다...');
      el.resetBtn.onclick = () => executeWithLock(resetApp, '앱 리셋', '앱을 초기화하고 있습니다...');
      
      // Cam 버튼 클릭 - 바로 키패드 열기
      el.cam1.addEventListener('click', ()=>{
        const prefill = computeCamPrefill('cam1');
        openKeypad(null, { purpose:'cam', cam:'cam1', prefill });
      });

      el.cam2.addEventListener('click', ()=>{
        const prefill = computeCamPrefill('cam2');
        openKeypad(null, { purpose:'cam', cam:'cam2', prefill });
      });
      // "시트 전송" 버튼을 누르면 → 바로 전송 (노트 기능 제거)
      el.sendToSheetBtn.onclick = () => { sendDataToGoogleSheet(); };
      
      // SB/BB 버튼 이벤트 추가
      const smallBlindBtn = document.getElementById('small-blind-btn');
      const bigBlindBtn = document.getElementById('big-blind-btn');
      
      if(smallBlindBtn) {
        smallBlindBtn.onclick = () => {
          const currentValue = window.state.actionState.smallBlind || '0';
          const html = `<div class="bg-gray-800 rounded-lg p-4 w-full max-w-xs">
            <h3 class="text-center text-amber-400 font-bold mb-3">Small Blind 설정</h3>
            <div class="text-xs text-gray-400 text-center mb-2">현재: ${formatNumber(currentValue)}</div>
            <input type="text" id="blind-text-input" class="w-full bg-gray-900 text-white p-2 rounded mb-3 text-center" placeholder="0" value="0">
            <div id="keypad-display" class="bg-gray-900 text-right text-2xl font-mono p-2 rounded mb-2 h-12">0</div>
            <div class="grid grid-cols-3 gap-2 text-xl font-bold">
              ${['7','8','9','4','5','6','1','2','3','0','00','000'].map(k=>`<button class="keypad-btn btn bg-gray-700 p-3 rounded-md">${k}</button>`).join('')}
            </div>
            <div class="grid grid-cols-2 gap-2 mt-2">
              <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">C</button>
              <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">←</button>
            </div>
            <div class="grid grid-cols-2 gap-2 mt-2">
              <button id="keypad-cancel" class="btn bg-red-600 p-3 rounded-md">취소</button>
              <button id="keypad-confirm" class="btn bg-green-600 p-3 rounded-md">확인</button>
            </div>
          </div>`;
          
          // 키패드 옵션 설정
          window.state.modalState.keypadOptions = {
            purpose: 'smallBlind'
          };
          
          openModal(el.keypadModal, html);
          
          setTimeout(() => {
            const textInput = document.getElementById('blind-text-input');
            const display = document.getElementById('keypad-display');
            let currentInput = '0';
            
            if(textInput && display) {
              // 텍스트 입력 이벤트
              textInput.addEventListener('input', () => {
                currentInput = unformatNumber(textInput.value) || '0';
                display.textContent = formatNumber(currentInput);
              });
              
              // 키패드 버튼 이벤트는 전역 키패드 모달 이벤트에서 처리
              // (중복 이벤트 리스너 제거)
              
              // 취소 버튼
              document.getElementById('keypad-cancel').onclick = () => {
                closeModal(el.keypadModal);
              };
              
              // 확인 버튼은 전역 키패드 모달 이벤트에서 처리
              // (중복 이벤트 리스너 제거)
            }
          }, 10);
        };
      }
      
      if(bigBlindBtn) {
        bigBlindBtn.onclick = () => {
          const currentValue = window.state.actionState.bigBlind || '0';
          const html = `<div class="bg-gray-800 rounded-lg p-4 w-full max-w-xs">
            <h3 class="text-center text-amber-400 font-bold mb-3">Big Blind 설정</h3>
            <div class="text-xs text-gray-400 text-center mb-2">현재: ${formatNumber(currentValue)}</div>
            <input type="text" id="blind-text-input" class="w-full bg-gray-900 text-white p-2 rounded mb-3 text-center" placeholder="0" value="0">
            <div id="keypad-display" class="bg-gray-900 text-right text-2xl font-mono p-2 rounded mb-2 h-12">0</div>
            <div class="grid grid-cols-3 gap-2 text-xl font-bold">
              ${['7','8','9','4','5','6','1','2','3','0','00','000'].map(k=>`<button class="keypad-btn btn bg-gray-700 p-3 rounded-md">${k}</button>`).join('')}
            </div>
            <div class="grid grid-cols-2 gap-2 mt-2">
              <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">C</button>
              <button class="keypad-btn btn bg-gray-600 text-amber-400 p-3 rounded-md">←</button>
            </div>
            <div class="grid grid-cols-2 gap-2 mt-2">
              <button id="keypad-cancel" class="btn bg-red-600 p-3 rounded-md">취소</button>
              <button id="keypad-confirm" class="btn bg-green-600 p-3 rounded-md">확인</button>
            </div>
          </div>`;
          
          // 키패드 옵션 설정
          window.state.modalState.keypadOptions = {
            purpose: 'bigBlind'
          };
          
          openModal(el.keypadModal, html);
          
          setTimeout(() => {
            const textInput = document.getElementById('blind-text-input');
            const display = document.getElementById('keypad-display');
            let currentInput = '0';
            
            if(textInput && display) {
              // 텍스트 입력 이벤트
              textInput.addEventListener('input', () => {
                currentInput = unformatNumber(textInput.value) || '0';
                display.textContent = formatNumber(currentInput);
              });
              
              // 키패드 버튼 이벤트는 전역 키패드 모달 이벤트에서 처리
              // (중복 이벤트 리스너 제거)
              
              // 취소 버튼
              document.getElementById('keypad-cancel').onclick = () => {
                closeModal(el.keypadModal);
              };
              
              // 확인 버튼은 전역 키패드 모달 이벤트에서 처리
              // (중복 이벤트 리스너 제거)
            }
          }, 10);
        };
      }
      
      // 노트 모달 관련 이벤트 제거 (노트 기능 삭제)
      
      el.showLogBtn.onclick = openLogModal;
      el.closeLogModalBtn.onclick = closeLogModal;
      
      // 로그 모달 배경 클릭 시 닫기
      el.logModal.addEventListener('click', (e)=>{
        if(e.target === el.logModal) {
          closeLogModal();
        }
      });

      // 테이블 선택 버튼 및 모달 이벤트
      el.tableSelectorBtn.onclick = openTableSelectorModal;
      document.getElementById('close-table-selector').onclick = closeTableSelectorModal;

      // 관리 모달의 테이블 변경 버튼
      document.getElementById('change-table-btn')?.addEventListener('click', () => {
        window.isTableManagementMode = true;
        openTableSelectorModal();
      });
      
      // 테이블 모달 검색 및 필터
      document.getElementById('table-search').oninput = (e) => {
        tableModalState.searchTerm = e.target.value;
        tableModalState.currentPage = 1;
        renderTableGrid();
      };
      
      // 필터 버튼들
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.onclick = () => {
          // 모든 필터 버튼 비활성화
          document.querySelectorAll('.filter-btn').forEach(b => {
            b.classList.remove('bg-blue-600', 'text-white');
            b.classList.add('bg-gray-600', 'hover:bg-gray-500');
          });
          // 클릭된 버튼 활성화
          btn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
          btn.classList.add('bg-blue-600', 'text-white');
          
          tableModalState.currentFilter = btn.id.replace('filter-', '');
          tableModalState.currentPage = 1;
          renderTableGrid();
        };
      });
      
      // 페이지 네비게이션
      document.getElementById('prev-page').onclick = () => {
        if (tableModalState.currentPage > 1) {
          tableModalState.currentPage--;
          renderTableGrid();
        }
      };
      
      document.getElementById('next-page').onclick = () => {
        const filteredTables = getFilteredTables();
        const totalPages = Math.ceil(filteredTables.length / tableModalState.tablesPerPage);
        if (tableModalState.currentPage < totalPages) {
          tableModalState.currentPage++;
          renderTableGrid();
        }
      };
      
      // 모달 외부 클릭시 닫기
      el.tableSelectorModal.onclick = (e) => {
        if (e.target === el.tableSelectorModal) {
          closeTableSelectorModal();
        }
      };
      el.timezoneSelector.onchange = (e)=>{ window.state.selectedTimezone=e.target.value; updateTimeDisplay(); renderAll(); };
      
      // Smart Mode 토글
      document.getElementById('smart-mode-toggle').onchange = (e) => {
        window.state.smartCheckCall = e.target.checked;
        showFeedback(window.state.smartCheckCall ? 'Smart Mode 활성화' : 'Smart Mode 비활성화');
      };

      // 좌석 플레이어 선택/해제 (새로운 10개 좌석 구조)
      document.getElementById('seat-buttons')?.addEventListener('click', (e)=>{
        const btn = e.target.closest('button'); 
        if(!btn) return;
        
        const playerName = btn.dataset.playerName;
        const seatNum = btn.dataset.seat;
        
        if(playerName) {
          // 플레이어가 있는 좌석 클릭 - 게임 참여 토글
          togglePlayerInHand(playerName);
        } else {
          // 빈 좌석 클릭 - 나중에 필요시 플레이어 추가 기능
          console.log(`빈 좌석 ${seatNum} 클릭`);
        }
      });

      // 플레이어 카드/칩 입력
      el.playerDetailsSection.addEventListener('click', (e)=>{
        const cardPlaceholder = e.target.closest('.card-placeholder');
        const keypadBtn = e.target.closest('.keypad-icon-btn');
        const playerCard = e.target.closest('.player-card');
        if(!playerCard) return;
        if(cardPlaceholder){
          window.state.modalState.cardTarget = { target:'playerHand', player:cardPlaceholder.dataset.playerName, count:parseInt(cardPlaceholder.dataset.count) };
          openCardSelector();
        }else if(keypadBtn){
          const pn = playerCard.dataset.playerName;
          const p = window.state.playersInHand.find(pp=>pp.name===pn);
          if(p) {
            // 개선된 칩 입력 함수 사용
            openChipInput(p, false);
          }
        }
      });

      // 승자 토글
      el.winnerButtons.addEventListener('click', (e)=>{
        const btn=e.target.closest('.set-winner-btn'); if(!btn) return;
        setPlayerRole(btn.dataset.playerName);
      });

      // 칩 입력 포맷팅
      el.playerDetailsSection.addEventListener('input', (e)=>{
        if(!e.target.classList.contains('player-chip-input')) return;
        const parent = e.target.closest('.player-card');
        const player = window.state.playersInHand.find(p=>p.name===parent.dataset.playerName);
        const raw = unformatNumber(e.target.value);
        e.target.value = formatNumber(raw);
        
        if (player){
          const oldChips = player.chips;
          player.chips = raw;
          player.chipsUpdatedAt = new Date().toISOString();
          
          // 항상 현재 입력된 칩 값을 시작칩으로 업데이트
          // (사용자가 수동으로 칩을 변경하면 그것이 새로운 시작칩이 됨)
          player.initialChips = raw;
          console.log(`🎰 ${player.name}의 시작칩 업데이트: ${oldChips} → ${raw}`);
        }
      });

      // 보드 카드 선택
      el.boardCardPlaceholders.addEventListener('click', (e)=>{
        const ph = e.target.closest('.card-placeholder'); if(!ph) return;
        window.state.modalState.cardTarget = { target:'board', index:parseInt(ph.dataset.index), count:parseInt(ph.dataset.count) };
        openCardSelector();
      });

      // 카드 선택 모달 이벤트
      el.cardSelectorModal.addEventListener('click', (e)=>{
        // 모달 배경 클릭 시 닫기
        if(e.target === el.cardSelectorModal) {
          closeModal(el.cardSelectorModal);
          return;
        }
        // 닫기 버튼 클릭
        if(e.target.id==='close-card-modal') closeModal(el.cardSelectorModal);
      });

      // 스트리트 버튼(추가/되돌리기/Pot 교정/스트리트 선택)
      el.streetLogsContainer.addEventListener('click', (e)=>{
        const streetBtn = e.target.closest('.street-select-btn');
        const addBtn = e.target.closest('.add-action-btn');
        const undoBtn = e.target.closest('.undo-action-btn');
        const potBtn = e.target.closest('.pot-keypad-btn');
        
        if(streetBtn) {
          const selectedStreet = streetBtn.dataset.street;
          window.state.currentStreet = selectedStreet;
          renderActionStreets(); // 하이라이트 업데이트

          // 스트릿 선택 시 바로 액션 패드 열기
          openActionPad(selectedStreet);
        }
        if(addBtn) openActionPad(addBtn.dataset.street);
        if(undoBtn) undoLastAction(undoBtn.dataset.street);
        if(potBtn){
          window.state.modalState.actionPadStreet = potBtn.dataset.street;
          openKeypad(null, { purpose:'pot', currentPot: potBtn.dataset.currentPot });
        }
      });

      // 새로운 액션 패드 내부 버튼 이벤트
      el.actionPadModal.addEventListener('click', (e)=>{
        // 모달 배경 클릭 시 닫기
        if(e.target === el.actionPadModal) {
          closeModal(el.actionPadModal);
          return;
        }

        const btn = e.target.closest('button');
        if(!btn) {
          console.log('🚫 버튼이 아닌 요소 클릭됨:', e.target);
          return;
        }

        console.log('🔍 버튼 클릭됨:', {
          id: btn.id,
          className: btn.className,
          dataset: btn.dataset,
          parentId: btn.parentElement?.id,
          actionMode: window.actionOrderManager?.actionMode,
          actionOrderManagerExists: !!window.actionOrderManager,
          actionOrderManagerType: typeof window.actionOrderManager
        });

        // 닫기 버튼
        if(btn.id==='close-action-pad'){
          closeModal(el.actionPadModal);
          return;
        }

        // 액션 모드 토글
        if(btn.id==='toggle-action-mode') {
          const newMode = window.actionOrderManager.toggleMode();
          showFeedback(`액션 모드: ${newMode === 'auto' ? '🤖 자동 순서' : '👆 수동 선택'}`, false);
          // 모달 다시 열기 (UI 업데이트)
          openActionPad(window.actionOrderManager.currentStreet);
          return;
        }

        // 현재 플레이어 스킵
        if(btn.id==='skip-current-player') {
          const nextPlayer = window.actionOrderManager.moveToNextPlayer();
          showFeedback(`플레이어 스킵됨. ${nextPlayer ? `다음: ${nextPlayer.name || nextPlayer.player}` : '스트릿 완료'}`, false);
          openActionPad(window.actionOrderManager.currentStreet);
          return;
        }

        // 자동 모드에서 현재 플레이어 액션 (current-player-actions 또는 data-player 속성)
        if(btn.dataset.player && (window.actionOrderManager?.actionMode === 'auto' || btn.parentElement?.id === 'current-player-actions')) {
          console.log('✅ 자동 모드 액션 실행:', {
            player: btn.dataset.player,
            action: btn.dataset.action
          });
          const playerName = btn.dataset.player;
          const action = btn.dataset.action;

          // 액션 실행
          executePlayerAction(playerName, action, btn);
          return;
        }

        // 수동 모드 플레이어 선택
        const modal = el.actionPadModal;
        if(btn.parentElement?.id==='action-pad-players'){
          window.state.modalState.actionPadPlayer = btn.dataset.playerName;
          const actionSection = modal.querySelector('#action-pad-actions');
          if(actionSection) {
            modal.querySelector('#action-pad-players').classList.add('hidden');
            actionSection.classList.remove('hidden');

            // 수동 모드 Check/Call 버튼 업데이트
            const smartBtn = modal.querySelector('#manual-smart-check-call-btn');
            if(smartBtn) {
              const playerName = btn.dataset.playerName;
              const street = window.state.modalState.actionPadStreet;
              const smartAction = getSmartCheckCallAction(playerName, street);

              // 버튼 색상과 텍스트 업데이트
              if(smartAction.action === 'Checks') {
                smartBtn.className = 'btn bg-green-600 hover:bg-green-700 p-3 rounded-md';
                smartBtn.innerHTML = '✅ Check';
              } else {
                smartBtn.className = 'btn bg-blue-600 hover:bg-blue-700 p-3 rounded-md';
                smartBtn.innerHTML = `📞 Call ${formatNumber(smartAction.amount)}`;
              }
              smartBtn.dataset.smartAction = JSON.stringify(smartAction);
            }
          }
          return;
        }

        // 수동 모드 액션 처리 (action-pad-actions 또는 current-player-actions)
        if(btn.parentElement?.id==='action-pad-actions' || btn.parentElement?.id==='current-player-actions'){
          console.log('✅ 수동 모드 액션 실행:', {
            action: btn.dataset.action,
            playerName: window.state.modalState.actionPadPlayer,
            dataPlayer: btn.dataset.player
          });
          const action = btn.dataset.action;
          let playerName = window.state.modalState.actionPadPlayer;

          // current-player-actions의 경우 data-player 속성에서 플레이어 이름 가져오기
          if(!playerName && btn.dataset.player) {
            playerName = btn.dataset.player;
            window.state.modalState.actionPadPlayer = playerName;
          }

          if(!playerName) {
            console.log('❌ 플레이어 선택되지 않음');
            showFeedback('플레이어를 선택해주세요.', true);
            return;
          }

          // 수동 모드에서 액션 실행
          console.log('🚀 executePlayerAction 호출:', { playerName, action });
          executePlayerAction(playerName, action, btn);
          return;
        }

        // 어떤 조건도 만족하지 않는 경우
        console.log('⚠️ 처리되지 않은 버튼 클릭:', {
          buttonId: btn.id,
          parentId: btn.parentElement?.id,
          hasDataPlayer: !!btn.dataset.player,
          actionMode: window.actionOrderManager?.actionMode,
          dataAction: btn.dataset.action
        });

        // 기존 호환성을 위한 처리 (삭제 예정)
        if(btn.parentElement?.id==='action-pad-actions-legacy'){
          const action = btn.dataset.action;
          if(action==='Bet/Raises'){
            const st = window.state.modalState.actionPadStreet;
            const hasBet = window.state.actionState[st].some(a=>/BET|RAISE/i.test(a.action||''));
            window.state.modalState.actionPadCurrentAction = hasBet ? 'Raises' : 'Bets';
            closeModal(el.actionPadModal); openKeypad(null, { purpose:'bet' });
          }else if(action==='SmartCheckCall'){
            // 스마트 Check/Call 처리
            const smartBtn = btn;
            const smartAction = JSON.parse(smartBtn.dataset.smartAction || '{}');
            if(smartAction.action) {
              addActionToLog(smartAction.action, smartAction.amount);
            }
          }else if(action==='All In'){
            const p = window.state.playersInHand.find(pp=>pp.name===window.state.modalState.actionPadPlayer);
            if(p) addActionToLog('All In', p.chips);
          }else if(action==='Calls'){
            const st = window.state.modalState.actionPadStreet;
            const p = window.state.playersInHand.find(pp=>pp.name===window.state.modalState.actionPadPlayer);
            
            // 현재 스트리트와 이전 스트리트에서 마지막 베팅/레이즈 찾기
            let lastBet = null;
            let requiredAmt = 0;
            
            // 현재 스트리트에서 찾기
            lastBet = [...window.state.actionState[st]].reverse().find(a=>/BET|RAISE|All In/i.test(a.action||''));
            
            if(!lastBet && st !== 'preflop') {
              // 현재 스트리트에 베팅이 없으면 이전 스트리트 확인
              const streetOrder = ['preflop', 'flop', 'turn', 'river'];
              const currentIdx = streetOrder.indexOf(st);
              for(let i = currentIdx - 1; i >= 0; i--) {
                lastBet = [...window.state.actionState[streetOrder[i]]].reverse().find(a=>/BET|RAISE|All In/i.test(a.action||''));
                if(lastBet) break;
              }
            }
            
            // 콜 금액 결정
            if(lastBet) {
              requiredAmt = lastBet.amount;
            } else if(st === 'preflop') {
              // 프리플랍에서 아무도 베팅하지 않았으면 빅블라인드 콜
              requiredAmt = unformatNumber(window.state.actionState.bigBlind);
            } else {
              // 포스트플랍에서 베팅이 없으면 체크해야 함
              showFeedback('베팅이 없어 체크를 선택해주세요', true);
              return;
            }
            
            // 플레이어 현재 칩
            const playerChips = p ? parseInt(unformatNumber(p.chips), 10) : 0;
            
            // 올인 콜 체크: 필요 금액이 플레이어 칩보다 크면 올인
            if(playerChips > 0 && playerChips <= parseInt(unformatNumber(requiredAmt), 10)){
              // 올인 콜 (플레이어의 모든 칩)
              addActionToLog('All In', p.chips);
            } else {
              // 일반 콜
              addActionToLog('Calls', requiredAmt);
            }
          }else{
            addActionToLog(action);
          }
        }
      });

      // 바깥쪽 키패드 버튼(SB/BB 등)
      document.body.addEventListener('click', (e)=>{
        const kb = e.target.closest('.keypad-icon-btn');
        if(kb && !kb.closest('.player-card')) openKeypad(kb.previousElementSibling, { purpose:'input' });
      });

      // 🚀 스마트폰 키보드 수준 키패드 입력 (v3.4.17 성능 최적화)
      // 버튼별 누름 상태 추적
      const buttonPressState = new Map();

      // 기존 click 이벤트 대신 down/up 이벤트로 즉시 반응
      el.keypadModal.addEventListener('mousedown', handleKeypadDown, { passive: false });
      el.keypadModal.addEventListener('touchstart', handleKeypadDown, { passive: false });
      el.keypadModal.addEventListener('mouseup', handleKeypadUp);
      el.keypadModal.addEventListener('touchend', handleKeypadUp);
      el.keypadModal.addEventListener('mouseleave', handleKeypadUp);

      function handleKeypadDown(e) {
        // 모달 배경 클릭 시 닫기
        if(e.target === el.keypadModal) {
          closeModal(el.keypadModal);
          return;
        }

        const btn = e.target.closest('button');
        if(!btn) return;

        // 🔧 모바일 확인/취소 버튼 즉시 반응 처리
        if(btn.id === 'keypad-confirm' || btn.id === 'keypad-cancel') {
          // 터치 즉시 반응 (300ms 지연 제거)
          btn.style.transform = 'scale(0.95)';
          btn.style.filter = 'brightness(1.2)';

          // 즉시 클릭 실행
          setTimeout(() => {
            btn.style.transform = '';
            btn.style.filter = '';
            btn.click(); // 기존 click 이벤트 트리거
          }, 100);

          e.preventDefault(); // 300ms 지연 방지
          return;
        }

        // 이미 눌린 상태면 무시 (물리적 누름 상태만 체크)
        if (buttonPressState.get(btn)) return;

        // 즉시 처리 시작
        buttonPressState.set(btn, true);

        // 즉시 시각적 피드백
        btn.style.transform = 'scale(0.95)';
        btn.style.filter = 'brightness(1.2)';

        // 키패드 버튼만 즉시 처리
        if(btn.classList.contains('keypad-btn')) {
          processKeypadInputImmediate(btn);
          // 키패드 버튼만 preventDefault 적용
          e.preventDefault();
        }
      }

      function handleKeypadUp(e) {
        const btn = e.target.closest('button');
        if(!btn) return;

        // 누름 상태 해제
        buttonPressState.set(btn, false);

        // 시각적 복구
        btn.style.transform = '';
        btn.style.filter = '';
      }

      // 즉시 입력 처리 함수
      function processKeypadInputImmediate(btn) {
        const display = el.keypadModal.querySelector('#keypad-display');
        const key = btn.textContent;

        if(key==='C'){
          display.textContent='0';
        }else if(key==='←'){
          const current = unformatNumber(display.textContent);
          const newValue = current.slice(0,-1) || '0';
          display.textContent = formatNumber(newValue);
        }else if(btn.dataset.action === 'max') {
          const { purpose } = window.state.modalState.keypadOptions;
          if(purpose === 'bet') {
            const playerName = window.state.modalState.keypadOptions.playerName ||
                              window.state.modalState.actionPadPlayer;
            const player = window.state.playersInHand.find(p => p.name === playerName);
            if(player) {
              display.textContent = player.chips;
              const warning = el.keypadModal.querySelector('#keypad-warning');
              if(warning) {
                warning.classList.remove('hidden');
                warning.textContent = `💰 최대 베팅 - 보유 칩 전체(${formatNumber(player.chips)})`;
                warning.className = 'text-xs text-blue-400 text-center mb-2';
              }
            }
          }
        }else{
          // 숫자 입력 처리
          const current = unformatNumber(display.textContent);
          let newValue;
          if(current === '0') {
            newValue = key;
          } else {
            newValue = current + key;
          }
          display.textContent = formatNumber(newValue);
        }

        // DOM 강제 렌더링으로 즉시 반영
        display.offsetHeight;
      }

      // 확인/취소 버튼은 기존 click 이벤트 유지
      el.keypadModal.addEventListener('click', (e)=>{
        const btn = e.target.closest('button');
        if(!btn) return;

        // 키패드 버튼은 이미 down 이벤트에서 처리됨
        if(btn.classList.contains('keypad-btn')) return;

        const display = el.keypadModal.querySelector('#keypad-display');

        // MAX 버튼 처리
        if(btn.dataset.action === 'max') {
          const { purpose } = window.state.modalState.keypadOptions;
          if(purpose === 'bet') {
            const playerName = window.state.modalState.keypadOptions.playerName ||
                              window.state.modalState.actionPadPlayer;
            const player = window.state.playersInHand.find(p => p.name === playerName);
            if(player) {
              display.textContent = player.chips; // 모든 칩을 베팅
              const warning = el.keypadModal.querySelector('#keypad-warning');
              if(warning) {
                warning.classList.remove('hidden');
                warning.textContent = `💰 최대 베팅 - 보유 칩 전체(${formatNumber(player.chips)})`;
                warning.className = 'text-xs text-blue-400 text-center mb-2';
              }
            }
          }
          return;
        }

        if(btn.id==='keypad-confirm'){
          const finalAmt = unformatNumber(display.textContent);
          const { purpose, currentPot } = window.state.modalState.keypadOptions;
          if(purpose==='cam'){
            const which = window.state.modalState.keypadOptions.cam; // 'cam1'|'cam2'
            // 안전한 숫자 변환: 숫자가 아닌 문자 제거 후 parseInt
            const cleanAmt = String(finalAmt).replace(/\D/g, '');
            const numValue = parseInt(cleanAmt, 10) || 0;
            const numValueStr = String(numValue); // 순수 숫자를 문자열로
            const padded = pad4(numValue); // 패딩된 표시용

            console.log(`🔧 카메라 번호 저장: 입력="${finalAmt}" → 정제="${cleanAmt}" → 숫자=${numValue} → 문자열="${numValueStr}"`);

            if (which==='cam1'){
              window.state.camNumbers.cam1no = numValueStr; // 순수 숫자를 문자열로 저장
              window.state.lastCamNo = numValueStr;
              el.cam1.textContent = `${window.state.camPreset.cam1}${padded}`; // 표시는 패딩된 형태로
              localStorage.setItem('pokerHandLogger_lastCam1', numValueStr); // localStorage에 숫자로 저장
              showFeedback(`${window.state.camPreset.cam1 || 'Cam1'}${padded} 입력됨`);
              console.log(`📷 cam1 저장: ${window.state.camPreset.cam1}=${numValueStr}`);
            }else if (which==='cam2'){
              window.state.camNumbers.cam2no = numValueStr; // 순수 숫자를 문자열로 저장
              window.state.lastCamNo = numValueStr;
              el.cam2.textContent = `${window.state.camPreset.cam2}${padded}`; // 표시는 패딩된 형태로
              localStorage.setItem('pokerHandLogger_lastCam2', numValueStr); // localStorage에 숫자로 저장
              console.log(`📷 cam2 저장: ${window.state.camPreset.cam2}=${numValueStr}`);
              showFeedback(`${window.state.camPreset.cam2 || 'Cam2'}${padded} 입력됨`);
            }
          }else if(purpose==='bet'){
            const { playerName } = window.state.modalState.keypadOptions;
            if(finalAmt) {
              // 칩 초과 검증 추가
              const actualPlayerName = playerName || window.state.modalState.actionPadPlayer;
              const player = window.state.playersInHand.find(p => p.name === actualPlayerName);
              if(player) {
                const playerChips = parseInt(unformatNumber(player.chips), 10);
                const betAmount = parseInt(finalAmt, 10);

                // 베팅 금액이 보유 칩을 초과하는 경우 경고만 표시 (진행은 허용)
                if(betAmount > playerChips) {
                  showFeedback(`⚠️ 주의: 칩 초과 베팅 (보유: ${formatNumber(playerChips)}, 베팅: ${formatNumber(betAmount)})`, true);
                  const resultingChips = playerChips - betAmount;
                  showFeedback(`💰 칩이 ${formatNumber(resultingChips)}가 됩니다`, false);
                  // 경고만 하고 진행은 계속함
                }
              }

              addActionToLog(window.state.modalState.actionPadCurrentAction, finalAmt, actualPlayerName);

              // 자동 모드에서 다음 플레이어로 이동
              if(window.actionOrderManager && window.actionOrderManager.actionMode === 'auto') {
                const nextPlayer = window.actionOrderManager.moveToNextPlayer();
                showFeedback(`${playerName} ${window.state.modalState.actionPadCurrentAction} ${formatNumber(finalAmt)}`, false);

                if(nextPlayer) {
                  openActionPad(window.actionOrderManager.currentStreet);
                } else {
                  setTimeout(() => {
                    showFeedback(`${window.actionOrderManager.currentStreet.toUpperCase()} 스트릿 완료`, false);
                  }, 500);
                }
              }
            }
          }else if(purpose==='pot'){
            // Pot correction: 입력한 값 그대로 저장 (이전 팟 크기를 빼지 않음)
            const potSize = finalAmt; // 포맷된 값 그대로 사용
            if(potSize){
              const st = window.state.modalState.actionPadStreet;
              // Pot Correction은 player 없이 저장 (시스템 액션)
              window.state.actionState[st].push({ 
                action:'Pot Correction', 
                amount:potSize,  // 포맷된 값 그대로 저장
                timestamp:new Date().toISOString() 
              });
              saveActionState(); renderAll();
            }
          }else if(purpose==='input'){
            if(window.state.modalState.keypadTarget){
              window.state.modalState.keypadTarget.value = display.textContent;
              window.state.modalState.keypadTarget.dispatchEvent(new Event('input',{bubbles:true}));
            }
          }else if(purpose==='chip'){
            // openChipInput에서 호출된 경우
            const { playerName } = window.state.modalState.keypadOptions;
            const player = window.state.playersInHand.find(p => p.name === playerName);
            if(player) {
              const value = unformatNumber(display.textContent) || '0';
              player.chips = value;
              player.initialChips = value;
              player.chipsUpdatedAt = new Date().toISOString();
              renderPlayerDetails();
            }
          }else if(purpose==='smallBlind'){
            // SB 버튼에서 호출된 경우
            const value = unformatNumber(display.textContent) || '0';
            window.state.actionState.smallBlind = value;
            const smallBlindBtn = document.getElementById('small-blind-btn');
            if(smallBlindBtn) {
              smallBlindBtn.textContent = formatNumber(value);
            }
            saveActionState();
          }else if(purpose==='bigBlind'){
            // BB 버튼에서 호출된 경우
            const value = unformatNumber(display.textContent) || '0';
            window.state.actionState.bigBlind = value;
            const bigBlindBtn = document.getElementById('big-blind-btn');
            if(bigBlindBtn) {
              bigBlindBtn.textContent = formatNumber(value);
            }
            saveActionState();
          }else if(purpose==='quickBet'){
            // 퀵 벳/레이즈 처리
            const { player, street } = window.state.modalState.keypadOptions;
            const amount = unformatNumber(display.textContent);
            if(amount && player && street) {
              // 현재 스트리트에 베팅이 있는지 확인
              const hasBet = window.state.actionState[street].some(a => 
                /BET|RAISE/i.test(a.action || '')
              );
              const action = hasBet ? 'Raises' : 'Bets';
              
              // 액션 추가
              window.state.actionState[street].push({
                player: player,
                action: action,
                amount: amount,
                timestamp: new Date().toISOString()
              });
              
              // 다음 플레이어 계산
              window.state.nextActionPlayer = calculateNextActionPlayer(street);
              
              saveActionState();
              renderAll();
              showFeedback(`${player} ${action} ${formatNumber(amount)}`);
            }
          }
          closeModal(el.keypadModal);
        }else if(btn.id==='keypad-cancel'){
          closeModal(el.keypadModal);
        }
        // 나머지 버튼들은 기존 로직 유지 (키패드 버튼은 down 이벤트에서 처리됨)
      });

      // SB/BB/Ante 체크
      document.querySelectorAll('.number-input').forEach(inp=>{
        inp.addEventListener('input', (e)=>{
          const raw = unformatNumber(e.target.value);
          const fmt = formatNumber(raw);
          if(e.target.value!==fmt) e.target.value=fmt;
          const k = toCamelCase(e.target.id.replace('-input','')); // small-blind-input -> smallBlind
          if(k in window.state.actionState) window.state.actionState[k]=raw;
          saveActionState();
        });
      });
      // Ante 체크박스 이벤트 핸들러 개선 (v3.4.23)
      el.bbAnteCheckbox.onchange = (e)=>{
        window.state.actionState.hasBBAnte = e.target.checked;
        saveActionState();
        // renderAll() 제거하여 반응성 개선
        console.log(`Ante 체크박스 상태 변경: ${e.target.checked}`);
      };

      // Load Hand 모달 내부 클릭
      el.loadHandModal.addEventListener('click', (e)=>{
        // 핸드 항목 클릭 우선 처리
        const itemBtn = e.target.closest('.load-hand-item-btn');
        if(itemBtn){
          const no = itemBtn.dataset.no;
          const dt = itemBtn.dataset.date || null;
          loadHandData(no, dt);
          return;
        }
        
        // 닫기 버튼 클릭
        const closeBtn = e.target.closest('#close-load-hand-modal');
        if(closeBtn) {
          closeModal(el.loadHandModal);
          return;
        }
        
        // 모달 컨텐츠 영역 클릭은 무시
        const content = e.target.closest('.bg-gray-800');
        if(content) return;
        
        // 모달 배경 클릭 시 닫기
        if (e.target === el.loadHandModal) {
          closeModal(el.loadHandModal);
        }
      });
    }

    // ====== 관리 모달 관련 함수 ======
    function openRegistrationModal() {
      const modal = el.registrationModal;
      if (modal) {
        modal.classList.remove('hidden');
        modal.classList.remove('opacity-0');
      }
    }
    
    function closeRegistrationModal() {
      const modal = el.registrationModal;
      if (modal) {
        modal.classList.add('opacity-0');
        modal.classList.add('hidden');
      }
    }
    
    
    // 관리 모달 이벤트 리스너
    if (el.managePlayersBtn) {
      el.managePlayersBtn.addEventListener('click', () => {
        openRegistrationModal();
        // 초기화: 모든 섹션 숨기기
        document.getElementById('management-menu').classList.remove('hidden');
        document.getElementById('player-management-content').classList.add('hidden');

        // Google Sheets URL 표시
        const currentUrlSpan = document.getElementById('management-current-url');
        const spreadsheetInput = document.getElementById('management-spreadsheet-id-input');
        const urlStatus = document.getElementById('url-save-status');

        if (currentUrlSpan) {
          const currentUrl = localStorage.getItem('googleSheetsDefaultUrl') || '설정되지 않음';
          currentUrlSpan.textContent = currentUrl;
          // URL이 설정되었는지에 따라 색상 변경
          const hasUrl = currentUrl !== '설정되지 않음';
          currentUrlSpan.className = hasUrl ?
            'text-xs text-green-400 break-all font-mono' :
            'text-xs text-amber-400 break-all font-mono';
        }

        if (spreadsheetInput) {
          spreadsheetInput.value = '';
          spreadsheetInput.placeholder = '새 Google Sheets URL을 입력하세요';
        }

        if (urlStatus) {
          urlStatus.classList.add('hidden');
        }
      });
    }

    // Google Sheets URL 저장 버튼 - 지연 실행으로 DOM 로드 보장
    setTimeout(() => {
      const saveSpreadsheetIdBtn = document.getElementById('save-spreadsheet-id-btn');
      console.log('🔗 Google Sheets URL 저장 버튼:', saveSpreadsheetIdBtn);

      if (saveSpreadsheetIdBtn) {
        saveSpreadsheetIdBtn.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('🔗 Google Sheets URL 저장 버튼 클릭됨');

          const spreadsheetInput = document.getElementById('management-spreadsheet-id-input');
          const urlStatus = document.getElementById('url-save-status');
          const currentUrlSpan = document.getElementById('management-current-url');
          const inputUrl = spreadsheetInput?.value.trim();

          console.log('🔗 입력된 URL:', inputUrl);
          console.log('🔗 현재 저장된 URL:', localStorage.getItem('googleSheetsDefaultUrl'));

          // 상태 메시지 표시 함수
          function showUrlStatus(message, isSuccess) {
            if (urlStatus) {
              urlStatus.textContent = message;
              urlStatus.className = isSuccess ?
                'text-xs p-2 rounded bg-green-600 text-white' :
                'text-xs p-2 rounded bg-red-600 text-white';
              urlStatus.classList.remove('hidden');

              // 3초 후 자동 숨김
              setTimeout(() => {
                urlStatus.classList.add('hidden');
              }, 3000);
            }
          }

          if (inputUrl) {
            // Google Sheets URL 형식 검증
            if (inputUrl.includes('docs.google.com/spreadsheets')) {
              // URL에서 Spreadsheet ID 추출
              const extractedId = extractSpreadsheetIdFromUrl(inputUrl);

              if (extractedId) {
                // Spreadsheet ID와 URL 저장
                localStorage.setItem('googleSheetsSpreadsheetId', extractedId);
                localStorage.setItem('googleSheetsDefaultUrl', inputUrl);

                if (window.googleSheetsAPI) {
                  window.googleSheetsAPI.setSpreadsheetId(extractedId);
                }

                // 성공 시 UI 업데이트
                if (currentUrlSpan) {
                  currentUrlSpan.textContent = inputUrl;
                  currentUrlSpan.className = 'text-xs text-green-400 break-all font-mono';
                }
                showUrlStatus('✅ Google Sheets URL이 성공적으로 저장되었습니다!', true);
                showFeedback('✅ Google Sheets URL이 저장되었습니다 (ID: ' + extractedId + ')');

                console.log('✅ 추출된 Spreadsheet ID:', extractedId);

                // 입력 필드 초기화 및 플레이스홀더 업데이트
                spreadsheetInput.value = '';
                spreadsheetInput.placeholder = '저장 완료! 다른 URL을 입력하려면 여기에 입력하세요';

                // 저장 버튼 임시 비활성화 및 텍스트 변경
                saveSpreadsheetIdBtn.disabled = true;
                saveSpreadsheetIdBtn.textContent = '✅ 저장 완료';
                saveSpreadsheetIdBtn.className = 'w-full bg-green-600 py-1.5 rounded text-sm font-medium';

                setTimeout(() => {
                  saveSpreadsheetIdBtn.disabled = false;
                  saveSpreadsheetIdBtn.textContent = '💾 새 URL 저장';
                  saveSpreadsheetIdBtn.className = 'w-full bg-amber-600 hover:bg-amber-700 py-1.5 rounded text-sm font-medium';
                }, 2000);
              } else {
                showUrlStatus('❌ URL에서 Spreadsheet ID를 추출할 수 없습니다', false);
                showFeedback('❌ 올바른 Google Sheets URL 형식이 아닙니다', true);
              }
            } else {
              showUrlStatus('❌ 올바른 Google Sheets URL 형식이 아닙니다', false);
              showFeedback('❌ Google Sheets URL을 올바르게 입력해주세요', true);
            }
          } else {
            showUrlStatus('⚠️ Google Sheets URL을 입력해주세요', false);
            showFeedback('Google Sheets URL을 입력해주세요', true);
          }
        });
        console.log('[v3.5.42] Google Sheets URL 저장 버튼 이벤트 리스너 등록 완료');
      } else {
        console.error('[v3.5.42] save-spreadsheet-id-btn 요소를 찾을 수 없습니다');
      }
    }, 100);

    // 테이블 관리 버튼 클릭 - 바로 테이블 선택 모달 열기
    document.getElementById('open-table-management-btn')?.addEventListener('click', () => {
      // 테이블 관리 모드 활성화 플래그 설정
      window.isTableManagementMode = true;

      // 바로 테이블 선택 모달 열기
      openTableSelectorModal();
    });

    // 중복 플레이어 제거 버튼 클릭 핸들러
    document.getElementById('remove-duplicates-btn')?.addEventListener('click', async () => {
      try {
        // 앱 초기화 확인
        if (!window.state || !window.state.playerDataByTable) {
          alert('⚠️ 앱이 아직 초기화되지 않았습니다. 잠시 후 다시 시도해주세요.');
          return;
        }

        // Apps Script URL 확인
        if (typeof APPS_SCRIPT_URL === 'undefined' || !APPS_SCRIPT_URL) {
          alert('⚠️ Apps Script URL이 설정되지 않았습니다. 관리 모달에서 URL을 먼저 설정해주세요.');
          return;
        }

        // 확인 대화상자 표시
        const confirmResult = confirm(
          '🧹 중복 플레이어 제거를 실행하시겠습니까?\n\n' +
          '• 같은 테이블 + 같은 이름 + 같은 좌석의 중복 플레이어를 찾아 제거합니다.\n' +
          '• 구글 시트에서 직접 데이터가 삭제됩니다.\n' +
          '• 이 작업은 되돌릴 수 없습니다.'
        );
        
        if (!confirmResult) {
          return;
        }

        // 버튼 비활성화 및 로딩 상태로 변경
        const button = document.getElementById('remove-duplicates-btn');
        const originalContent = button.innerHTML;
        button.disabled = true;
        button.innerHTML = `
          <span class="text-2xl mb-1 animate-spin">⚙️</span>
          <span>검사 중...</span>
        `;

        // 중복 제거 실행
        console.log('[Phase5] 수동 중복 제거 실행 시작');
        
        // duplicate-remover.js 모듈이 로드되지 않았으므로 동적으로 로드
        if (typeof window.removeDuplicatePlayers !== 'function') {
          console.log('[Phase5] duplicate-remover.js 모듈 동적 로드 중...');
          
          // 스크립트 동적 로드
          const script = document.createElement('script');
          script.src = 'src/js/duplicate-remover.js?v=3.4.16';
          script.onload = async () => {
            console.log('[Phase5] duplicate-remover.js 로드 완료');
            await executeRemoveDuplicates(button, originalContent);
          };
          script.onerror = () => {
            console.error('[Phase5] duplicate-remover.js 로드 실패');
            alert('❌ 중복 제거 모듈을 로드할 수 없습니다.');
            button.disabled = false;
            button.innerHTML = originalContent;
          };
          document.head.appendChild(script);
        } else {
          await executeRemoveDuplicates(button, originalContent);
        }

      } catch (error) {
        console.error('[Phase5] 중복 제거 버튼 오류:', error);
        alert('❌ 중복 제거 중 오류가 발생했습니다: ' + error.message);
        
        // 버튼 복원
        const button = document.getElementById('remove-duplicates-btn');
        button.disabled = false;
        button.innerHTML = originalContent;
      }
    });

    // 중복 제거 실행 함수
    async function executeRemoveDuplicates(button, originalContent) {
      try {
        const result = await window.removeDuplicatePlayers(false); // 모달 열기 스킵하지 않음
        
        // 결과 표시
        if (result.success) {
          if (result.removedCount > 0) {
            alert(`✅ 중복 제거 완료

` +
                 `• 제거된 중복 플레이어: ${result.removedCount}명
` +
                 `• ${result.message}`);
            
            // 데이터 새로고침
            console.log('[Phase5] 중복 제거 완료 후 데이터 새로고침');
            if (window.loadAllData && typeof window.loadAllData === 'function') {
              await window.loadAllData();
            }
          } else {
            alert('✅ 중복 검사 완료\n\n시트가 깨끗습니다. 중복 플레이어가 없습니다.');


          }
        } else {
          alert('❌ 중복 제거 실패\n\n작업이 실패했습니다.');


        }
        
      } catch (error) {
        console.error('[Phase5] executeRemoveDuplicates 오류:', error);
        alert('❌ 중복 제거 실행 중 오류가 발생했습니다: ' + error.message);
      } finally {
        // 버튼 복원
        button.disabled = false;
        button.innerHTML = originalContent;
      }
    }

    // 플레이어 관리 시스템 상태 - 전역 스코프로 노출
    window.managementState = {
      selectedTable: '',
      originalPlayers: [],
      currentPlayers: [],
      changes: {
        added: [],
        modified: [],
        deleted: []
      }
    };

    // 플레이어 관리 초기화
    function initPlayerManagement() {
      // 초기 상태로 리셋
      window.managementState = {
        selectedTable: '',
        originalPlayers: [],
        currentPlayers: [],
        changes: { added: [], modified: [], deleted: [] }
      };

      // UI 초기화 - 즉시 선택 방식으로 변경
      document.getElementById('selected-table-info').classList.add('hidden');
      document.getElementById('player-add-section').classList.add('hidden');
      document.getElementById('player-list-section').classList.add('hidden');
      document.getElementById('batch-actions').classList.add('hidden');
      document.getElementById('sync-status').textContent = '';
    }

    // 관리 모달에서 테이블 선택 처리 - selectTable에서 호출됨
    function onManagementTableSelected(tableName) {
      console.log('[DEBUG] onManagementTableSelected 호출됨, tableName:', tableName);
      if (!tableName) return;

      window.managementState.selectedTable = tableName;
      window.managementState.originalPlayers = JSON.parse(JSON.stringify(
        window.state.playerDataByTable[tableName] || []
      ));
      window.managementState.currentPlayers = JSON.parse(JSON.stringify(
        window.managementState.originalPlayers
      ));
      window.managementState.changes = { added: [], modified: [], deleted: [] };

      console.log('[DEBUG] managementState 설정됨:', window.managementState);

      // UI 업데이트 - 테이블 정보는 항상 표시
      document.getElementById('selected-table-name').textContent = tableName;
      document.getElementById('player-add-section').classList.remove('hidden');
      document.getElementById('player-list-section').classList.remove('hidden');
      document.getElementById('batch-actions').classList.remove('hidden');

      // 플레이어 목록 렌더링
      renderManagementPlayersList();
      updateChangesSummary();
    }


    // 로컬 플레이어 목록 렌더링 - 10개 시트 고정 방식
    function renderManagementPlayersList() {
      console.log('[DEBUG] renderManagementPlayersList 호출됨');
      const listContainer = document.getElementById('current-players-list');
      const countDisplay = document.getElementById('player-count');

      if (!listContainer) {
        console.log('[DEBUG] listContainer를 찾을 수 없음');
        return;
      }

      const players = window.managementState.currentPlayers;
      console.log('[DEBUG] 렌더링할 플레이어:', players);
      countDisplay.textContent = `${players.length}/10명`;

      // 10개 시트 배열 생성 (1번부터 10번까지)
      const seats = [];
      for (let i = 1; i <= 10; i++) {
        seats.push({
          seatNumber: i,
          // v3.5.41: #1 형식 좌석 처리
          player: players.find(p => {
            const seatStr = String(p.seat || '');
            const seatNumber = seatStr.replace(/[#]/g, ''); // # 제거
            return parseInt(seatNumber, 10) === i;
          }) || null
        });
      }

      // 2열 5개씩 그리드 레이아웃 (컴팩트)
      listContainer.innerHTML = `
        <div class="grid grid-cols-2 gap-1">
          ${seats.map(({ seatNumber, player }) => {
            const index = player ? players.indexOf(player) : -1;
            const isModified = player && window.managementState.changes.modified.includes(player.name);
            const isAdded = player && window.managementState.changes.added.includes(player.name);
            const isEmpty = !player;

            return `
            <div class="seat-slot bg-gray-700 p-1 rounded ${
              isEmpty ? 'opacity-40' : ''
            } ${
              isAdded ? 'border border-green-500' : isModified ? 'border border-yellow-500' : 'border border-gray-600'
            }" data-seat="${seatNumber}">
              <div class="flex items-center justify-between h-9">
                <div class="flex items-center gap-1 flex-1">
                  <span class="text-sm font-bold text-gray-400 w-6 text-center">
                    ${seatNumber}
                  </span>
                  ${player ? `
                    <div class="flex-1">
                      <input type="text" class="bg-gray-800 px-1 py-0.5 rounded text-xs w-full player-name-input"
                             value="${player.name}"
                             data-index="${index}"
                             data-seat="${seatNumber}">
                    </div>
                  ` : `
                    <div class="flex-1">
                      <input type="text" class="bg-gray-800 px-1 py-0.5 rounded text-xs w-full empty-seat-input"
                             placeholder="이름 입력"
                             data-seat="${seatNumber}">
                    </div>
                  `}
                </div>
                <div class="flex items-center gap-1">
                  ${player ? `
                    <input type="text" class="bg-gray-800 px-1 py-0.5 rounded text-xs w-16 local-chips-input"
                           value="${formatNumber(player.chips || '0')}"
                           placeholder="칩"
                           data-index="${index}">
                    <button class="text-red-400 hover:text-red-300 text-xs local-delete-btn px-1"
                            data-index="${index}"
                            onclick="deleteLocalPlayer(${index})">✕</button>
                  ` : `
                    <span class="text-gray-500 text-xs w-16 text-center">-</span>
                  `}
                </div>
              </div>
              ${player && (isAdded || isModified) ? `
                <div class="text-xs px-6">
                  ${isAdded ? '<span class="text-green-400 text-xs">✓</span>' : ''}
                  ${isModified ? '<span class="text-yellow-400 text-xs">✓</span>' : ''}
                </div>
              ` : ''}
            </div>
          `;
          }).join('')}
        </div>
      `;

      // 이벤트 리스너 추가

      // 빈 자리 입력 처리
      listContainer.querySelectorAll('.empty-seat-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const seatNumber = parseSeatNumber(e.target.dataset.seat);
          const playerName = e.target.value.trim();

          if (playerName) {
            addPlayerToSeat(playerName, seatNumber);
            e.target.value = '';
          }
        });
      });

      // 플레이어 이름 수정
      listContainer.querySelectorAll('.player-name-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const index = parseInt(e.target.dataset.index);
          const newName = e.target.value.trim();

          if (index >= 0 && newName) {
            const player = window.managementState.currentPlayers[index];
            if (player && player.name !== newName) {
              player.name = newName;

              if (!window.managementState.changes.added.includes(player.name)) {
                if (!window.managementState.changes.modified.includes(player.name)) {
                  window.managementState.changes.modified.push(player.name);
                }
              }
              updateChangesSummary();
            }
          }
        });
      });

      // 칩 입력 처리
      listContainer.querySelectorAll('.local-chips-input').forEach(input => {
        input.addEventListener('input', (e) => {
          const index = parseInt(e.target.dataset.index);
          const newChips = unformatNumber(e.target.value);
          e.target.value = formatNumber(newChips);
          updateLocalPlayerChips(index, newChips);
        });
      });

      // 삭제 버튼 이벤트는 인라인 onclick으로 처리됨
      console.log('[DEBUG] 삭제 버튼 개수:', listContainer.querySelectorAll('.local-delete-btn').length);
    }

    // 특정 시트에 플레이어 추가
    function addPlayerToSeat(name, seatNumber) {
      if (!name) return;

      // 중복 체크
      if (window.managementState.currentPlayers.some(p => p.name === name)) {
        showFeedback(`${name}은(는) 이미 존재합니다`, true);
        return;
      }

      // 좌석 중복 체크
      if (window.managementState.currentPlayers.some(p => parseSeatNumber(p.seat) === seatNumber)) {
        showFeedback(`좌석 ${seatNumber}번은 이미 사용 중입니다`, true);
        return;
      }

      // 플레이어 수 제한 (10명)
      if (window.managementState.currentPlayers.length >= 10) {
        showFeedback('최대 10명까지만 등록 가능합니다', true);
        return;
      }

      // 추가
      const newPlayer = {
        name: name,
        seat: String(seatNumber),
        chips: '100000', // 기본 칩
        table: window.managementState.selectedTable,
        notable: false,
        status: 'IN'
      };

      window.managementState.currentPlayers.push(newPlayer);
      window.managementState.changes.added.push(name);

      renderManagementPlayersList();
      updateChangesSummary();
      showFeedback(`${name} 좌석 ${seatNumber}번에 추가됨`);
    }

    // 기존 플레이어 추가 UI 숨기기 (10개 시트에서 직접 입력하므로)
    const addPlayerBtn = document.getElementById('add-player-local-btn');
    if (addPlayerBtn) {
      addPlayerBtn.style.display = 'none';
    }
    const addSection = document.getElementById('player-add-section');
    if (addSection) {
      addSection.style.display = 'none';
    }

    // 로컬 플레이어 좌석 업데이트
    function updateLocalPlayerSeat(index, newSeat) {
      const player = window.managementState.currentPlayers[index];
      if (!player) return;

      // 좌석 중복 체크
      if (newSeat && window.managementState.currentPlayers.some((p, i) => i !== index && p.seat === newSeat)) {
        showFeedback(`좌석 ${newSeat}번은 이미 사용 중입니다`, true);
        renderManagementPlayersList();
        return;
      }

      player.seat = newSeat;

      // 변경 사항 추적
      if (!window.managementState.changes.added.includes(player.name)) {
        if (!window.managementState.changes.modified.includes(player.name)) {
          window.managementState.changes.modified.push(player.name);
        }
      }

      updateChangesSummary();
    }

    // 로컬 플레이어 칩 업데이트
    function updateLocalPlayerChips(index, newChips) {
      const player = window.managementState.currentPlayers[index];
      if (!player) return;

      player.chips = newChips;

      // 변경 사항 추적
      if (!window.managementState.changes.added.includes(player.name)) {
        if (!window.managementState.changes.modified.includes(player.name)) {
          window.managementState.changes.modified.push(player.name);
        }
      }

      updateChangesSummary();
    }

    // 로컬 플레이어 삭제 - 전역 스코프로 노출 (서버 통신 없음)
    window.deleteLocalPlayer = function(index) {
      const player = window.managementState.currentPlayers[index];
      if (!player) {
        console.log('[v3.3.1] 삭제할 플레이어 없음:', index);
        return;
      }

      console.log('[v3.3.1] 플레이어 삭제:', player.name, 'index:', index);

      // ActionHistory를 사용한 즉시 삭제
      const originalIndex = index;
      const originalPlayer = { ...player };
      const originalName = player.name;  // 이름 별도 저장

      // 즉시 UI 업데이트
      window.managementState.currentPlayers.splice(index, 1);

      // 변경 사항 추적
      if (window.managementState.changes.added.includes(originalName)) {
        // 새로 추가한 항목이면 added에서 제거
        window.managementState.changes.added = window.managementState.changes.added.filter(n => n !== originalName);
      } else {
        // 기존 항목이면 deleted에 추가
        if (!window.managementState.changes.deleted.includes(originalName)) {
          window.managementState.changes.deleted.push(originalName);
        }
        // modified에서 제거
        window.managementState.changes.modified = window.managementState.changes.modified.filter(n => n !== originalName);
      }

      console.log('[v3.3.1] 삭제 후 changes:', window.managementState.changes);

      renderManagementPlayersList();
      updateChangesSummary();

      // 스낵바 표시 (실행취소 가능)
      if (window.actionHistory) {
        window.actionHistory.showSnackbar(`${player.name} 삭제됨 (로컬)`, () => {
          // 실행 취소 로직
          window.managementState.currentPlayers.splice(originalIndex, 0, originalPlayer);

          // 변경 사항 복구
          if (window.managementState.changes.deleted.includes(originalPlayer.name)) {
            window.managementState.changes.deleted = window.managementState.changes.deleted.filter(n => n !== originalPlayer.name);
          }

          renderManagementPlayersList();
          updateChangesSummary();
        });
      } else {
        showFeedback(`${player.name} 삭제됨 (미등록)`);
      }
    }

    // 변경 사항 요약 업데이트
    function updateChangesSummary() {
      const summary = document.getElementById('changes-summary');
      const { added, modified, deleted } = window.managementState.changes;

      const parts = [];
      if (added.length > 0) parts.push(`추가: ${added.length}명`);
      if (modified.length > 0) parts.push(`수정: ${modified.length}명`);
      if (deleted.length > 0) parts.push(`삭제: ${deleted.length}명`);

      if (parts.length > 0) {
        summary.innerHTML = `<span class="text-yellow-400">⚠️ 미등록 변경사항:</span> ${parts.join(', ')}<br>
        <span class="text-xs text-gray-500">일괄 등록 버튼을 눌러 서버에 저장하세요</span>`;
        summary.classList.remove('text-gray-400');
        summary.classList.add('text-amber-300');
      } else {
        summary.textContent = '변경 사항 없음';
        summary.classList.remove('text-amber-300');
        summary.classList.add('text-gray-400');
      }
    }

    // 변경 사항 초기화
    document.getElementById('reset-changes-btn')?.addEventListener('click', () => {
      // 백업 데이터 생성 (실행취소용)
      const backup = {
        players: JSON.parse(JSON.stringify(window.managementState.currentPlayers)),
        changes: JSON.parse(JSON.stringify(window.managementState.changes))
      };

      // 원본 데이터로 복원
      window.managementState.currentPlayers = JSON.parse(JSON.stringify(
        window.managementState.originalPlayers
      ));
      window.managementState.changes = { added: [], modified: [], deleted: [] };

      renderManagementPlayersList();
      updateChangesSummary();

      // 스낵바 표시 (실행취소 가능)
      if (window.actionHistory) {
        window.actionHistory.showSnackbar('변경 사항이 초기화되었습니다', () => {
          // 실행 취소 - 이전 상태로 복구
          window.managementState.currentPlayers = backup.players;
          window.managementState.changes = backup.changes;
          renderManagementPlayersList();
          updateChangesSummary();
        });
      } else {
        showFeedback('변경 사항이 초기화되었습니다');
      }
    });

    // 일괄 등록
    document.getElementById('batch-register-btn')?.addEventListener('click', async () => {
      const { added, modified, deleted } = window.managementState.changes;

      if (added.length === 0 && modified.length === 0 && deleted.length === 0) {
        if (window.actionHistory) {
          window.actionHistory.showSnackbar('변경 사항이 없습니다', null, 'warning');
        } else {
          showFeedback('변경 사항이 없습니다', true);
        }
        return;
      }

      // 변경사항 메시지 표시
      const changeMessage = `추가: ${added.length}명, 수정: ${modified.length}명, 삭제: ${deleted.length}명`;
      if (window.actionHistory) {
        window.actionHistory.showSnackbar(`등록 중... ${changeMessage}`, null, 'info');
      }

      const syncStatus = document.getElementById('sync-status');
      syncStatus.textContent = '동기화 중...';
      syncStatus.className = 'text-xs text-yellow-400';

      await executeWithLock(async () => {

      try {
        console.log('[v3.3.1] === 일괄 등록 시작 ===');
        console.log('[v3.3.1] 선택된 테이블:', window.managementState.selectedTable);
        console.log('[v3.3.1] 현재 플레이어 수:', window.managementState.currentPlayers.length);
        console.log('[v3.3.1] 추가될 플레이어:', added);
        console.log('[v3.3.1] 수정될 플레이어:', modified);
        console.log('[v3.3.1] 삭제될 플레이어:', deleted);
        console.log('[v3.3.1] Apps Script URL:', APPS_SCRIPT_URL);

        // 삭제 대상 플레이어 상세 정보 확인
        console.log('[v3.3.1] === 삭제 대상 상세 정보 ===');
        deleted.forEach((playerName, index) => {
          console.log(`[v3.3.1] 삭제[${index}]: "${playerName}" (길이: ${playerName.length})`);
        });

        // 일괄 처리 요청
        const formData = new FormData();
        formData.append('action', 'batchUpdate');
        formData.append('table', window.managementState.selectedTable);
        formData.append('players', JSON.stringify(window.managementState.currentPlayers));
        formData.append('deleted', JSON.stringify(deleted));

        console.log('[v3.3.1] FormData 생성 완료');
        console.log('[v3.3.1] 전송할 플레이어 데이터:', JSON.stringify(window.managementState.currentPlayers, null, 2));
        console.log('[v3.3.1] 삭제할 플레이어 이름들:', JSON.stringify(deleted, null, 2));

        // FormData 내용 확인
        console.log('[v3.3.1] === FormData 내용 확인 ===');
        for (let [key, value] of formData.entries()) {
          console.log(`[v3.3.1] FormData[${key}]:`, typeof value === 'string' ? value.substring(0, 200) + '...' : value);
        }

        const response = await fetch(APPS_SCRIPT_URL, {
          method: 'POST',
          body: formData
        });

        console.log('[v3.3.1] 응답 수신:', response.status, response.statusText);

        if (!response.ok) {
          console.log(`HTTP ${response.status}: ${response.statusText}`);
          showFeedback('서버 통신 오류', true);
          return;
        }

        const result = await response.json();
        console.log('[v3.3.1] 응답 데이터:', result);

        if (result.success) {
          console.log('[v3.3.1] 일괄 등록 성공:', result);
          syncStatus.textContent = '✅ 동기화 완료';
          syncStatus.className = 'text-xs text-green-400';

          // 스낵바로 성공 메시지 표시 (정렬 포함)
          if (window.actionHistory) {
            window.actionHistory.showSnackbar('✅ 모든 변경 사항이 등록되고 시트가 정렬되었습니다', null, 'success');
          } else {
            showFeedback('✅ 모든 변경 사항이 등록되고 시트가 정렬되었습니다');
          }

          // 데이터 새로고침 - CSV 방식 사용
          try {
            console.log('[v3.3.1] 데이터 새로고침 시작...');
            console.log('[v3.3.1] CSV_TYPE_URL:', CSV_TYPE_URL);

            const csv = await fetch(CSV_TYPE_URL).then(r => {
              console.log('[v3.3.1] CSV 응답 상태:', r.status, r.statusText);
              return r.text();
            });

            console.log('[v3.3.1] CSV 데이터 길이:', csv.length);
            console.log('[v3.3.1] CSV 첫 100자:', csv.substring(0, 100));

            const rows = parseCSV(csv);
            console.log('[v3.3.1] 파싱된 행 수:', rows.length);

            buildTypeFromCsv(rows);
            console.log('[v3.3.1] Type 데이터 빌드 완료');
            console.log('[v3.3.1] 업데이트된 테이블:', Object.keys(window.state.playerDataByTable));
          } catch (refreshError) {
            console.error('[v3.3.1] 데이터 새로고침 실패:', refreshError);
            showFeedback('⚠️ 데이터 새로고침 실패, 페이지를 새로고침해주세요', true);
          }

          // 상태 리셋
          try {
            console.log('[v3.3.1] 상태 리셋 시작...');
            console.log('[v3.3.1] 선택된 테이블:', window.managementState.selectedTable);

            const refreshedPlayers = window.state.playerDataByTable[window.managementState.selectedTable] || [];
            console.log('[v3.3.1] 새로고침된 플레이어 수:', refreshedPlayers.length);

            window.managementState.originalPlayers = JSON.parse(JSON.stringify(refreshedPlayers));
            window.managementState.currentPlayers = JSON.parse(JSON.stringify(refreshedPlayers));
            window.managementState.changes = { added: [], modified: [], deleted: [] };

            console.log('[v3.3.1] 상태 리셋 완료');
          } catch (resetError) {
            console.error('[v3.3.1] 상태 리셋 실패:', resetError);
          }

          try {
            console.log('[v3.3.1] UI 업데이트 시작...');
            renderManagementPlayersList();
            updateChangesSummary();
            renderPlayerSelection(); // 메인 화면 업데이트

            // 전체 UI 새로고침 (즉시 반영을 위해)
            if (typeof renderAll === 'function') {
              renderAll();
              console.log('[v3.3.1] 전체 UI 새로고침 완료');
            }

            // 플레이어 데이터 다시 렌더링
            if (typeof updatePlayersDisplay === 'function') {
              updatePlayersDisplay();
              console.log('[v3.3.1] 플레이어 디스플레이 새로고침 완료');
            }

            console.log('[v3.3.1] UI 업데이트 완료 - 모든 변경사항이 즉시 적용됨');
          } catch (uiError) {
            console.error('[v3.3.1] UI 업데이트 실패:', uiError);
          }

          // 모달 자동 닫기 및 대시보드 리다이렉트
          if (typeof autoCloseManagementModal === 'function') {
            console.log('[v3.3.1] 모달 자동 닫기 실행...');
            autoCloseManagementModal();
          } else {
            // 폴백: 수동으로 모달 닫기
            setTimeout(() => {
              const modal = document.getElementById('management-modal');
              if (modal) {
                modal.classList.add('hidden', 'opacity-0');
                console.log('[v3.3.1] 모달 수동 닫기 완료');
              }
            }, 2000);
          }
        } else {
          // 오류 처리
          syncStatus.textContent = '❌ 동기화 실패';
          syncStatus.className = 'text-xs text-red-400';

          const errorMessage = result.message && result.message.includes('Unknown action')
            ? 'Apps Script 재배포가 필요합니다'
            : result.message || '등록 실패';

          // 스낵바로 에러 메시지 표시
          if (window.actionHistory) {
            window.actionHistory.showSnackbar(errorMessage, null, 'error');
          } else {
            showFeedback(errorMessage, true);
          }

          // UI 활성화
          if (typeof enableModalUI === 'function') {
            enableModalUI();
          }
        }
      } catch(err) {
        console.error('[v3.3.1] === 일괄 등록 오류 ===');
        console.error('[v3.3.1] 오류 타입:', err.constructor.name);
        console.error('[v3.3.1] 오류 메시지:', err.message);
        console.error('[v3.3.1] 오류 스택:', err.stack);
        console.error('[v3.3.1] 전체 오류 객체:', err);

        syncStatus.textContent = '❌ 동기화 실패';
        syncStatus.className = 'text-xs text-red-400';

        // 상세한 에러 분석
        let errorMessage = err.message;
        let debugInfo = '';

        if (err.message.includes('loadTypeSheet is not defined')) {
          errorMessage = '데이터 새로고침 함수 오류 (이미 수정됨)';
          debugInfo = '페이지를 새로고침한 후 다시 시도해주세요';
        } else if (err.message.includes('Apps Script 재배포')) {
          errorMessage = '⚠️ Apps Script 재배포 필요 (관리 메뉴 참조)';
        } else if (err.message.includes('NetworkError') || err.message.includes('fetch')) {
          errorMessage = '네트워크 연결 오류';
          debugInfo = 'Apps Script URL을 확인하고 인터넷 연결을 확인해주세요';
        } else if (err.message.includes('JSON')) {
          errorMessage = 'Apps Script 응답 파싱 오류';
          debugInfo = 'Apps Script가 올바른 JSON을 반환하지 않습니다';
        }

        console.error('[v3.3.1] 분석된 오류:', errorMessage);
        console.error('[v3.3.1] 디버그 정보:', debugInfo);

        showFeedback(`❌ ${errorMessage}${debugInfo ? ` (${debugInfo})` : ''}`, true);

        // UI 활성화
        if (typeof enableModalUI === 'function') {
          enableModalUI();
        }
      } finally {
        console.log('[v3.3.1] === 일괄 등록 종료 ===');
      }
    }, '플레이어 등록', '플레이어 정보를 서버에 저장하고 있습니다...');
    });

    // 기존 플레이어 목록 로드 함수 (구버전 호환용)
    function loadPlayersList() {
      const listContainer = document.getElementById('current-players-list');
      if (!listContainer) return;

      const table = window.state.selectedTable;
      if (!table) {
        listContainer.innerHTML = '<p class="text-gray-400 text-xs">테이블을 선택하면 플레이어가 표시됩니다.</p>';
        return;
      }

      const players = window.state.playerDataByTable[table] || [];
      if (players.length === 0) {
        listContainer.innerHTML = '<p class="text-gray-400 text-xs">플레이어가 없습니다.</p>';
        return;
      }

      listContainer.innerHTML = players.map(player => `
        <div class="flex items-center justify-between bg-gray-600 p-2 rounded player-list-item" data-player="${player.name}">
          <div class="flex-1">
            <span class="font-medium">${player.name}</span>
            ${player.seat ? `<span class="text-xs text-gray-400 ml-2">좌석 ${player.seat}</span>` : ''}
          </div>
          <div class="flex items-center gap-2">
            <input type="number" class="bg-gray-700 px-2 py-1 rounded text-sm w-16 seat-input"
                   value="${player.seat || ''}" placeholder="좌석" min="1" max="10"
                   data-player="${player.name}">
            <input type="text" class="bg-gray-700 px-2 py-1 rounded text-sm w-20 chips-input"
                   value="${formatNumber(player.chips || '0')}" placeholder="칩"
                   data-player="${player.name}">
            <button class="text-red-500 hover:text-red-400 delete-player-btn" data-player="${player.name}">🗑️</button>
          </div>
        </div>
      `).join('');

      // 이벤트 리스너 추가
      listContainer.querySelectorAll('.seat-input').forEach(input => {
        input.addEventListener('change', (e) => {
          const playerName = e.target.dataset.player;
          const newSeat = e.target.value;
          updatePlayerSeat(playerName, newSeat);
        });
      });

      listContainer.querySelectorAll('.chips-input').forEach(input => {
        input.addEventListener('input', (e) => {
          const playerName = e.target.dataset.player;
          const newChips = unformatNumber(e.target.value);
          e.target.value = formatNumber(newChips);
          updatePlayerChips(playerName, newChips);
        });
      });

      // 구버전 삭제 버튼 - 사용하지 않음
      /*
      listContainer.querySelectorAll('.delete-player-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const playerName = e.target.dataset.player;
          // confirm 제거, 즉시 삭제 실행
          deletePlayer(playerName);
        });
      });
      */
    }

    // 플레이어 추가 버튼 이벤트
    document.getElementById('add-player-btn')?.addEventListener('click', () => {
      const nameInput = document.getElementById('new-player-name');
      const seatInput = document.getElementById('new-player-seat');
      const chipsInput = document.getElementById('new-player-chips');

      const name = nameInput.value.trim();
      const seat = seatInput.value;
      const chips = unformatNumber(chipsInput.value) || '0';

      if (!name) {
        showFeedback('플레이어 이름을 입력하세요', true);
        return;
      }

      if (!window.state.selectedTable) {
        showFeedback('먼저 테이블을 선택하세요', true);
        return;
      }

      addNewPlayer(name, seat, chips);

      // 입력 필드 초기화
      nameInput.value = '';
      seatInput.value = '';
      chipsInput.value = '';
    });


    // 플레이어 추가 함수 - 중복 체크 강화
    // Phase 4: 원본 함수를 내부 함수로 변경
    async function _addNewPlayer_internal(name, seat, chips) {
      try {
        // 프론트엔드에서 먼저 중복 체크
        const existingPlayer = window.state.playersByTable[window.state.selectedTable]?.find(p =>
          p.name === name && p.status === 'IN'
        );

        if (existingPlayer) {
          showFeedback(`❌ 이미 존재하는 플레이어입니다: ${name}`, true);
          return;
        }

        const formData = new FormData();
        formData.append('action', 'addPlayer');
        formData.append('table', window.state.selectedTable);
        formData.append('player', name);
        formData.append('seat', seat || '');
        formData.append('chips', chips);
        formData.append('status', 'IN');

        const response = await fetch(APPS_SCRIPT_URL, {
          method: 'POST',
          body: formData
        });

        const result = await response.json();
        if (result.success) {
          console.log('[v3.3.1] 플레이어 추가 성공:', result);
          showFeedback(`✅ ${name} 추가됨`);

          // 데이터 새로고침 - CSV 방식 사용
          try {
            console.log('[v3.3.1] 플레이어 추가 후 데이터 새로고침...');
            const csv = await fetch(CSV_TYPE_URL).then(r => r.text());
            const rows = parseCSV(csv);
            buildTypeFromCsv(rows);
            console.log('[v3.3.1] 플레이어 추가 후 새로고침 완료');
          } catch (refreshError) {
            console.error('[v3.3.1] 플레이어 추가 후 새로고침 실패:', refreshError);
          }

          loadPlayersList();
          renderPlayerSelection();
        } else {
          console.error('[v3.3.1] 플레이어 추가 실패:', result);
          showFeedback(`❌ 추가 실패: ${result.error}`, true);
        }
      } catch(err) {
        console.error('플레이어 추가 오류:', err);
        showFeedback('플레이어 추가 중 오류 발생', true);
      }
    }

    // Phase 4: 보호된 플레이어 추가 함수
    async function addNewPlayer(name, seat, chips) {
      console.log('👤 Phase 4: 보호된 플레이어 추가 시작', { name, seat, chips });

      // 입력 검증
      if (!name || typeof name !== 'string' || name.trim().length === 0) {
        showFeedback('❌ 플레이어 이름을 입력해주세요', true);
        return;
      }

      if (chips !== undefined && (isNaN(chips) || chips < 0)) {
        showFeedback('❌ 올바른 칩 수량을 입력해주세요', true);
        return;
      }

      // Phase 4 보호 시스템 활성화 확인
      if (typeof window.protectedApiCall !== 'function') {
        console.error('❌ Phase 4 보호 시스템이 로드되지 않았습니다.');
        await _addNewPlayer_internal(name, seat, chips);
        return;
      }

      try {
        await window.protectedApiCall(
          'addPlayer',
          { name: name.trim(), seat, chips, table: window.state.selectedTable },
          {
            priority: 'normal',
            timeout: 15000,
            useCache: false,
            onRetry: (attempt, delay) => {
              console.log(`🔄 플레이어 추가 재시도... ${attempt}번째 시도 (${delay/1000}초 후)`);
            },
            customHandler: () => _addNewPlayer_internal(name, seat, chips)
          }
        );

      } catch (error) {
        console.error('❌ Phase 4 보호 플레이어 추가 실패:', error);

        // 사용자 친화적 에러 메시지 표시
        if (typeof window.getUserFriendlyErrorMessage === 'function') {
          const friendlyError = window.getUserFriendlyErrorMessage(error, 'addPlayer');
          showFeedback(`❌ ${friendlyError.title}`, true);
        } else {
          showFeedback(`❌ 플레이어 추가 실패: ${error.message}`, true);
        }
      }
    }

    // Phase 4: 원본 함수를 내부 함수로 변경
    async function _updatePlayerSeat_internal(playerName, newSeat) {
      try {
        const formData = new FormData();
        formData.append('action', 'updateSeat');
        formData.append('table', window.state.selectedTable);
        formData.append('player', playerName);
        formData.append('seat', newSeat || '');

        const response = await fetch(APPS_SCRIPT_URL, {
          method: 'POST',
          body: formData
        });

        const result = await response.json();
        if (result.success) {
          showFeedback(`✅ ${playerName} 좌석 ${newSeat}으로 변경`);
          // 메모리 업데이트
          const player = window.state.playerDataByTable[window.state.selectedTable]?.find(p => p.name === playerName);
          if (player) player.seat = newSeat;
          renderPlayerSelection();
        } else {
          showFeedback(`❌ 좌석 변경 실패: ${result.error}`, true);
        }
      } catch(err) {
        console.error('좌석 업데이트 오류:', err);
        showFeedback('좌석 변경 중 오류 발생', true);
      }
    }

    // Phase 4: 보호된 플레이어 좌석 업데이트 함수
    async function updatePlayerSeat(playerName, newSeat) {
      console.log('🪑 Phase 4: 보호된 좌석 업데이트 시작', { playerName, newSeat });

      // 입력 검증
      if (!playerName || typeof playerName !== 'string' || playerName.trim().length === 0) {
        showFeedback('❌ 플레이어 이름이 필요합니다', true);
        return;
      }

      if (newSeat !== undefined && newSeat !== '' && (isNaN(newSeat) || newSeat < 1 || newSeat > 10)) {
        showFeedback('❌ 좌석 번호는 1-10 범위여야 합니다', true);
        return;
      }

      // Phase 4 보호 시스템 활성화 확인
      if (typeof window.protectedApiCall !== 'function') {
        console.error('❌ Phase 4 보호 시스템이 로드되지 않았습니다.');
        await _updatePlayerSeat_internal(playerName, newSeat);
        return;
      }

      try {
        await window.protectedApiCall(
          'updateSeat',
          { playerName: playerName.trim(), newSeat, table: window.state.selectedTable },
          {
            priority: 'normal',
            timeout: 10000,
            useCache: false,
            onRetry: (attempt, delay) => {
              console.log(`🔄 좌석 업데이트 재시도... ${attempt}번째 시도 (${delay/1000}초 후)`);
            },
            customHandler: () => _updatePlayerSeat_internal(playerName, newSeat)
          }
        );

      } catch (error) {
        console.error('❌ Phase 4 보호 좌석 업데이트 실패:', error);

        if (typeof window.getUserFriendlyErrorMessage === 'function') {
          const friendlyError = window.getUserFriendlyErrorMessage(error, 'updateSeat');
          showFeedback(`❌ ${friendlyError.title}`, true);
        } else {
          showFeedback(`❌ 좌석 변경 실패: ${error.message}`, true);
        }
      }
    }

    // Phase 4: 원본 함수를 내부 함수로 변경
    async function _updatePlayerChips_internal(playerName, newChips) {
      try {
        const formData = new FormData();
        formData.append('action', 'updateChips');
        formData.append('table', window.state.selectedTable);
        formData.append('player', playerName);
        formData.append('chips', newChips);

        const response = await fetch(APPS_SCRIPT_URL, {
          method: 'POST',
          body: formData
        });

        const result = await response.json();
        if (result.success) {
          // 메모리 업데이트
          const player = window.state.playerDataByTable[window.state.selectedTable]?.find(p => p.name === playerName);
          if (player) player.chips = newChips;
        }
      } catch(err) {
        console.error('칩 업데이트 오류:', err);
      }
    }

    // Phase 4: 보호된 플레이어 칩 업데이트 함수
    async function updatePlayerChips(playerName, newChips) {
      console.log('💰 Phase 4: 보호된 칩 업데이트 시작', { playerName, newChips });

      // 입력 검증
      if (!playerName || typeof playerName !== 'string' || playerName.trim().length === 0) {
        showFeedback('❌ 플레이어 이름이 필요합니다', true);
        return;
      }

      if (newChips !== undefined && (isNaN(newChips) || newChips < 0)) {
        showFeedback('❌ 칩 수량은 0 이상이어야 합니다', true);
        return;
      }

      // Phase 4 보호 시스템 활성화 확인
      if (typeof window.protectedApiCall !== 'function') {
        console.error('❌ Phase 4 보호 시스템이 로드되지 않았습니다.');
        await _updatePlayerChips_internal(playerName, newChips);
        return;
      }

      try {
        await window.protectedApiCall(
          'updateChips',
          { playerName: playerName.trim(), newChips, table: window.state.selectedTable },
          {
            priority: 'normal',
            timeout: 10000,
            useCache: false,
            onRetry: (attempt, delay) => {
              console.log(`🔄 칩 업데이트 재시도... ${attempt}번째 시도 (${delay/1000}초 후)`);
            },
            customHandler: () => _updatePlayerChips_internal(playerName, newChips)
          }
        );

      } catch (error) {
        console.error('❌ Phase 4 보호 칩 업데이트 실패:', error);

        if (typeof window.getUserFriendlyErrorMessage === 'function') {
          const friendlyError = window.getUserFriendlyErrorMessage(error, 'updateChips');
          showFeedback(`❌ ${friendlyError.title}`, true);
        } else {
          showFeedback(`❌ 칩 변경 실패: ${error.message}`, true);
        }
      }
    }

    // 플레이어 삭제 (구버전 - 사용하지 않음)
    // 새로운 관리 시스템에서는 deleteLocalPlayer를 사용하고
    // 서버 동기화는 일괄 등록 시에만 처리
    /*
    async function deletePlayer(playerName) {
      try {
        const formData = new FormData();
        formData.append('action', 'deletePlayer');
        formData.append('table', window.state.selectedTable);
        formData.append('player', playerName);

        const response = await fetch(APPS_SCRIPT_URL, {
          method: 'POST',
          body: formData
        });

        const result = await response.json();
        if (result.success) {
          showFeedback(`✅ ${playerName} 삭제됨`);
          // 메모리에서 제거
          const players = window.state.playerDataByTable[window.state.selectedTable];
          if (players) {
            const index = players.findIndex(p => p.name === playerName);
            if (index !== -1) players.splice(index, 1);
          }
          loadPlayersList();
          renderPlayerSelection();
        } else {
          showFeedback(`❌ 삭제 실패: ${result.error}`, true);
        }
      } catch(err) {
        console.error('플레이어 삭제 오류:', err);
        showFeedback('플레이어 삭제 중 오류 발생', true);
      }
    }
    */
    
    // ========================================
    // 설정 모달 이벤트 핸들러
    // ========================================
    
    // 설정 모달 열기
    if (el.settingsBtn) {
      el.settingsBtn.addEventListener('click', () => {
        // 현재 Spreadsheet ID 표시
        const currentSpreadsheetId = localStorage.getItem('googleSheetsSpreadsheetId') || '';
        el.currentSpreadsheetId.textContent = currentSpreadsheetId || '설정되지 않음';
        el.googleSpreadsheetIdInput.value = currentSpreadsheetId;
        
        // 칩 검증 설정 로드
        const chipValidation = localStorage.getItem('chipValidation') !== 'false';
        el.chipValidationToggle.checked = chipValidation;
        
        // 액션 입력 모드 설정 로드
        const actionInputMode = localStorage.getItem('actionInputMode') === 'auto';
        const actionInputToggle = document.getElementById('action-input-mode-toggle');
        if (actionInputToggle) {
          actionInputToggle.checked = actionInputMode;
        }
        
        // 클라우드 동기화 UI 업데이트
        updateCloudSyncUI();

        // 버전 정보 업데이트
        const versionInfo = el.settingsModal.querySelector('.text-gray-400');
        if (versionInfo) {
          el.settingsModal.querySelectorAll('.text-gray-400').forEach((elem, idx) => {
            if (idx === 0) elem.textContent = APP_VERSION;
            if (idx === 1) elem.textContent = VERSION_DATE;
          });
        }
        
        // 모달 열기
        el.settingsModal.classList.remove('hidden');
      });
    }
    
    // 설정 모달 닫기
    const closeSettings = () => {
      el.settingsModal.classList.add('hidden');
    };
    
    if (el.closeSettingsBtn) {
      el.closeSettingsBtn.addEventListener('click', closeSettings);
    }
    
    if (el.cancelSettingsBtn) {
      el.cancelSettingsBtn.addEventListener('click', closeSettings);
    }
    
    // 설정 저장
    if (el.saveSettingsBtn) {
      el.saveSettingsBtn.addEventListener('click', () => {
        // Google Spreadsheet ID 저장
        const newSpreadsheetId = el.googleSpreadsheetIdInput.value.trim();
        const currentSpreadsheetId = localStorage.getItem('googleSheetsSpreadsheetId') || '';
        
        if (newSpreadsheetId && newSpreadsheetId !== currentSpreadsheetId) {
          localStorage.setItem('googleSheetsSpreadsheetId', newSpreadsheetId);
          console.log('✅ Google Spreadsheet ID 업데이트 완료:', newSpreadsheetId);
          
          // Google Sheets API 모듈에 새 ID 적용
          if (window.googleSheetsAPI) {
            window.googleSheetsAPI.spreadsheetId = newSpreadsheetId;
          }
          
          showFeedback('✅ Google Spreadsheet ID 업데이트 완료', false);
        }
        
        // 칩 검증 설정 저장
        const chipValidation = el.chipValidationToggle.checked;
        localStorage.setItem('chipValidation', chipValidation.toString());
        window.state.chipValidation = chipValidation;
        console.log(`✅ 칩 검증 설정: ${chipValidation ? '활성화' : '비활성화'}`);
        
        // 액션 입력 모드 설정 저장
        const actionInputToggle = document.getElementById('action-input-mode-toggle');
        if (actionInputToggle) {
          const actionInputMode = actionInputToggle.checked ? 'auto' : 'manual';
          localStorage.setItem('actionInputMode', actionInputMode);
          window.state.actionInputMode = actionInputMode;
          console.log(`✅ 액션 입력 모드: ${actionInputMode === 'auto' ? '자동 매핑' : '수동 선택'}`);
          
          // UI 업데이트
          renderAll();
        }
        
        showFeedback('✅ 설정이 저장되었습니다');
        closeSettings();
      });
    }

    // 클라우드 동기화 버튼 이벤트 핸들러
    if (el.syncNowBtn) {
      el.syncNowBtn.addEventListener('click', syncCloudNow);
    }

    if (el.resetCloudBtn) {
      el.resetCloudBtn.addEventListener('click', resetCloudConfig);
    }

    // ESC 키로 닫기
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !el.settingsModal.classList.contains('hidden')) {
        closeSettings();
      }
    });
    
    const closeBtn = document.getElementById('close-registration-modal');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeRegistrationModal);
    }


    // 버튼 위치 선택 이벤트 - renderPlayerSelection에서 처리하도록 제거
    // (renderPlayerSelection 함수 내에서 이미 처리중)

    // ====== INIT ======
    async function initializeApp(){
      await executeWithLock(async () => {
        el.logDisplay.innerHTML='';
        openLogModal();
        logMessage(`🎯 ${VERSION_INFO}`);
        logMessage(`📅 초기화 시작: ${new Date().toLocaleString('ko-KR')}`);
        populateTimezones(); loadActionState();
        try{
          await loadInitial();
          renderTableSelection();
          initializeSeatGrid();  // 좌석 그리드 초기화
          if(timeUpdater) clearInterval(timeUpdater);
          timeUpdater = setInterval(updateTimeDisplay, 1000);
          updateTimeDisplay();
          logMessage(`✅ ${APP_VERSION} 준비 완료!`);

          // 중복 검사 실행 (직접 호출로 이중 실행 방지)
          logMessage(`🔍 중복 플레이어 검사 시작...`);
          if (window.removeDuplicatePlayers && typeof window.removeDuplicatePlayers === 'function') {
            try {
              // skipModalOpen=true로 모달 중복 열기 방지
              const result = await window.removeDuplicatePlayers(true);
              if (result.success) {
                if (result.removedCount > 0) {
                  logMessage(`✅ 중복 제거 완료: ${result.removedCount}명 제거`);
                } else {
                  logMessage(`✅ 중복 없음 - 시트가 깨끗합니다`);
                }
              }
            } catch (duplicateError) {
              console.error('중복 검사 오류:', duplicateError);
              logMessage(`⚠️ 중복 검사 실패: ${duplicateError.message}`, true);
            }
          }
        }catch(err){
          console.error(err); logMessage(`초기화 실패: ${err.message}`, true);
        }finally{
          setTimeout(closeLogModal, 3000); // 중복 검사 완료 후 닫기 위해 시간 연장
        }
      }, '앱 초기화', '데이터를 로드하고 있습니다...');
    }

    // DOMContentLoaded 이벤트 리스너 안에서 함수 호출
    setupEventListeners();
    initializeApp();
  });
  </script>

  <!-- 로딩 오버레이 -->
  <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-75 z-60 hidden flex items-center justify-center">
    <div class="bg-gray-800 rounded-lg p-6 max-w-sm w-full mx-4">
      <div class="flex items-center space-x-3">
        <div class="animate-spin h-5 w-5 border-2 border-amber-500 border-t-transparent rounded-full"></div>
        <div>
          <div id="loading-title" class="text-white font-medium">처리 중...</div>
          <div id="loading-message" class="text-gray-400 text-sm mt-1">잠시만 기다려주세요</div>
        </div>
      </div>
      <div class="mt-4 text-xs text-gray-500">
        작업이 완료될 때까지 다른 버튼을 클릭하지 마세요
      </div>
    </div>
  </div>

  <!-- 스낵바 컴포넌트 -->
  <div id="snackbar" class="snackbar"></div>

  <!-- JWT 라이브러리 (서명용) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/10.8.6/jsrsasign-all-min.js"></script>
  
  <!-- Google Sheets API 모듈 로드 -->
  <script src="./src/js/google-sheets-api.js"></script>

</body>
</html>
